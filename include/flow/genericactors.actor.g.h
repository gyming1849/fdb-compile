#define POST_ACTOR_COMPILER 1
#line 1 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
/*
 * genericactors.actor.h
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2013-2022 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

// When actually compiled (NO_INTELLISENSE), include the generated version of this file.  In intellisense use the source
// version.
#include "flow/Error.h"
#include "flow/FastRef.h"
#include "flow/TaskPriority.h"
#include "flow/network.h"
#include "flow/swift_support.h"
#include <utility>
#include <functional>
#include <unordered_set>
#if defined(NO_INTELLISENSE) && !defined(FLOW_GENERICACTORS_ACTOR_G_H)
#define FLOW_GENERICACTORS_ACTOR_G_H
#include "flow/genericactors.actor.g.h"
#elif !defined(GENERICACTORS_ACTOR_H)
#define GENERICACTORS_ACTOR_H

#include <list>
#include <utility>

#include "flow/flow.h"
#include "flow/Knobs.h"
#include "flow/Util.h"
#include "flow/IndexedSet.h"
#include "flow/actorcompiler.h" // This must be the last #include.

#ifdef _MSC_VER
#pragma warning(disable : 4355) // 'this' : used in base member initializer list
#endif

															#line 54 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via traceAfter()
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class X, class TraceAfterActor>
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TraceAfterActorState {
															#line 61 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TraceAfterActorState(Future<T> const& what,const char* const& type,const char* const& key,X const& value,bool const& traceErrors = false) 
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   type(type),
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   key(key),
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   value(value),
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   traceErrors(traceErrors)
															#line 76 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("traceAfter", reinterpret_cast<unsigned long>(this));

	}
	~TraceAfterActorState() 
	{
		fdb_probe_actor_destroy("traceAfter", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 55 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = what;
															#line 55 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<TraceAfterActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 94 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<TraceAfterActor*>(this)->actor_wait_state = 1;
															#line 55 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TraceAfterActor, 0, T >*>(static_cast<TraceAfterActor*>(this)));
															#line 99 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TraceAfterActorState();
		static_cast<TraceAfterActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 59 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (traceErrors)
															#line 129 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 60 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				TraceEvent(type).errorUnsuppressed(e).detail(key, value);
															#line 133 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 61 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(e, loopDepth);
															#line 137 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& val,int loopDepth) 
	{
															#line 56 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		TraceEvent(type).detail(key, value);
															#line 57 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TraceAfterActor*>(this)->SAV<T>::futures) { (void)(val); this->~TraceAfterActorState(); static_cast<TraceAfterActor*>(this)->destroy(); return 0; }
															#line 153 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TraceAfterActor*>(this)->SAV< T >::value()) T(val);
		this->~TraceAfterActorState();
		static_cast<TraceAfterActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(T && val,int loopDepth) 
	{
															#line 56 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		TraceEvent(type).detail(key, value);
															#line 57 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TraceAfterActor*>(this)->SAV<T>::futures) { (void)(val); this->~TraceAfterActorState(); static_cast<TraceAfterActor*>(this)->destroy(); return 0; }
															#line 167 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TraceAfterActor*>(this)->SAV< T >::value()) T(val);
		this->~TraceAfterActorState();
		static_cast<TraceAfterActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& val,int loopDepth) 
	{
		loopDepth = a_body1cont2(val, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && val,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(val), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TraceAfterActor*>(this)->actor_wait_state > 0) static_cast<TraceAfterActor*>(this)->actor_wait_state = 0;
		static_cast<TraceAfterActor*>(this)->ActorCallback< TraceAfterActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< TraceAfterActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("traceAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TraceAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("traceAfter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TraceAfterActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("traceAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TraceAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("traceAfter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TraceAfterActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("traceAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TraceAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("traceAfter", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	const char* type;
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	const char* key;
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	X value;
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	bool traceErrors;
															#line 260 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via traceAfter()
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class X>
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TraceAfterActor final : public Actor<T>, public ActorCallback< TraceAfterActor<T, X>, 0, T >, public FastAllocated<TraceAfterActor<T, X>>, public TraceAfterActorState<T, X, TraceAfterActor<T, X>> {
															#line 267 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TraceAfterActor<T, X>>::operator new;
	using FastAllocated<TraceAfterActor<T, X>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(526659857948983296UL, 4514416614346154496UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TraceAfterActor<T, X>, 0, T >;
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TraceAfterActor(Future<T> const& what,const char* const& type,const char* const& key,X const& value,bool const& traceErrors = false) 
															#line 284 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   TraceAfterActorState<T, X, TraceAfterActor<T, X>>(what, type, key, value, traceErrors),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("traceAfter", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(1345027834026654720UL, 9550825359764015360UL);
		ActorExecutionContextHelper __helper(static_cast<TraceAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("traceAfter");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("traceAfter", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TraceAfterActor<T, X>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class X>
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> traceAfter( Future<T> const& what, const char* const& type, const char* const& key, X const& value, bool const& traceErrors = false ) {
															#line 52 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new TraceAfterActor<T, X>(what, type, key, value, traceErrors));
															#line 319 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 64 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 324 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via traceAfterCall()
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class X, class TraceAfterCallActor>
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TraceAfterCallActorState {
															#line 331 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TraceAfterCallActorState(Future<T> const& what,const char* const& type,const char* const& key,X const& func,bool const& traceErrors = false) 
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   type(type),
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   key(key),
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   func(func),
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   traceErrors(traceErrors)
															#line 346 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("traceAfterCall", reinterpret_cast<unsigned long>(this));

	}
	~TraceAfterCallActorState() 
	{
		fdb_probe_actor_destroy("traceAfterCall", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 68 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = what;
															#line 68 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<TraceAfterCallActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 364 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<TraceAfterCallActor*>(this)->actor_wait_state = 1;
															#line 68 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TraceAfterCallActor, 0, T >*>(static_cast<TraceAfterCallActor*>(this)));
															#line 369 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TraceAfterCallActorState();
		static_cast<TraceAfterCallActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 76 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (traceErrors)
															#line 399 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 77 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				TraceEvent(type).errorUnsuppressed(e);
															#line 403 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 78 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(e, loopDepth);
															#line 407 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(int loopDepth) 
	{
		try {
															#line 70 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			TraceEvent(type).detail(key, func(val));
															#line 422 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1cont5(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1cont2Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont2Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1when1(T const& __val,int loopDepth) 
	{
															#line 68 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		val = __val;
															#line 437 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && __val,int loopDepth) 
	{
		val = std::move(__val);
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TraceAfterCallActor*>(this)->actor_wait_state > 0) static_cast<TraceAfterCallActor*>(this)->actor_wait_state = 0;
		static_cast<TraceAfterCallActor*>(this)->ActorCallback< TraceAfterCallActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< TraceAfterCallActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("traceAfterCall", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TraceAfterCallActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("traceAfterCall", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TraceAfterCallActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("traceAfterCall", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TraceAfterCallActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("traceAfterCall", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TraceAfterCallActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("traceAfterCall", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TraceAfterCallActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("traceAfterCall", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 74 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TraceAfterCallActor*>(this)->SAV<T>::futures) { (void)(val); this->~TraceAfterCallActorState(); static_cast<TraceAfterCallActor*>(this)->destroy(); return 0; }
															#line 516 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TraceAfterCallActor*>(this)->SAV< T >::value()) T(std::move(val)); // state_var_RVO
		this->~TraceAfterCallActorState();
		static_cast<TraceAfterCallActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 72 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			TraceEvent(SevError, "TraceAfterCallError").error(e);
															#line 529 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1cont3(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch2(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch2(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont5(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont3(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch2(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch2(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	const char* type;
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	const char* key;
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	X func;
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	bool traceErrors;
															#line 68 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	T val;
															#line 565 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via traceAfterCall()
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class X>
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TraceAfterCallActor final : public Actor<T>, public ActorCallback< TraceAfterCallActor<T, X>, 0, T >, public FastAllocated<TraceAfterCallActor<T, X>>, public TraceAfterCallActorState<T, X, TraceAfterCallActor<T, X>> {
															#line 572 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TraceAfterCallActor<T, X>>::operator new;
	using FastAllocated<TraceAfterCallActor<T, X>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(10290103528097603072UL, 1212449202902266368UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TraceAfterCallActor<T, X>, 0, T >;
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TraceAfterCallActor(Future<T> const& what,const char* const& type,const char* const& key,X const& func,bool const& traceErrors = false) 
															#line 589 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   TraceAfterCallActorState<T, X, TraceAfterCallActor<T, X>>(what, type, key, func, traceErrors),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("traceAfterCall", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(3779267792497716480UL, 9186379876595564288UL);
		ActorExecutionContextHelper __helper(static_cast<TraceAfterCallActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("traceAfterCall");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("traceAfterCall", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TraceAfterCallActor<T, X>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class X>
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> traceAfterCall( Future<T> const& what, const char* const& type, const char* const& key, X const& func, bool const& traceErrors = false ) {
															#line 65 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new TraceAfterCallActor<T, X>(what, type, key, func, traceErrors));
															#line 624 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 81 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 629 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via stopAfter()
															#line 82 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class StopAfterActor>
															#line 82 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class StopAfterActorState {
															#line 636 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 82 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	StopAfterActorState(Future<T> const& what) 
															#line 82 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 82 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 84 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   ret(T())
															#line 645 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("stopAfter", reinterpret_cast<unsigned long>(this));

	}
	~StopAfterActorState() 
	{
		fdb_probe_actor_destroy("stopAfter", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 86 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = what;
															#line 86 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<StopAfterActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 663 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<StopAfterActor*>(this)->actor_wait_state = 1;
															#line 86 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< StopAfterActor, 0, T >*>(static_cast<StopAfterActor*>(this)));
															#line 668 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~StopAfterActorState();
		static_cast<StopAfterActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 97 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		g_network->stop();
															#line 98 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<StopAfterActor*>(this)->SAV<Optional<T>>::futures) { (void)(ret); this->~StopAfterActorState(); static_cast<StopAfterActor*>(this)->destroy(); return 0; }
															#line 699 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<StopAfterActor*>(this)->SAV< Optional<T> >::value()) Optional<T>(std::move(ret)); // state_var_RVO
		this->~StopAfterActorState();
		static_cast<StopAfterActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 89 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			bool ok = e.code() == error_code_please_reboot || e.code() == error_code_please_reboot_delete || e.code() == error_code_actor_cancelled || e.code() == error_code_local_config_changed;
															#line 91 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			TraceEvent(ok ? SevInfo : SevError, "StopAfterError").error(e);
															#line 92 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (!ok)
															#line 716 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 93 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				fprintf(stderr, "Fatal Error: %s\n", e.what());
															#line 94 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				ret = Optional<T>();
															#line 722 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& _,int loopDepth) 
	{
															#line 87 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		ret = Optional<T>(_);
															#line 738 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(T && _,int loopDepth) 
	{
															#line 87 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		ret = Optional<T>(_);
															#line 747 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1when1(T const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<StopAfterActor*>(this)->actor_wait_state > 0) static_cast<StopAfterActor*>(this)->actor_wait_state = 0;
		static_cast<StopAfterActor*>(this)->ActorCallback< StopAfterActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< StopAfterActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("stopAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<StopAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("stopAfter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< StopAfterActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("stopAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<StopAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("stopAfter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< StopAfterActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("stopAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<StopAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("stopAfter", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont4(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
															#line 82 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 84 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Optional<T> ret;
															#line 844 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via stopAfter()
															#line 82 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 82 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class StopAfterActor final : public Actor<Optional<T>>, public ActorCallback< StopAfterActor<T>, 0, T >, public FastAllocated<StopAfterActor<T>>, public StopAfterActorState<T, StopAfterActor<T>> {
															#line 851 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<StopAfterActor<T>>::operator new;
	using FastAllocated<StopAfterActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(8648011393475684864UL, 520766956210230016UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Optional<T>>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< StopAfterActor<T>, 0, T >;
															#line 82 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	StopAfterActor(Future<T> const& what) 
															#line 868 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Optional<T>>(),
		   StopAfterActorState<T, StopAfterActor<T>>(what),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("stopAfter", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(18375464497900749312UL, 15065832257037953024UL);
		ActorExecutionContextHelper __helper(static_cast<StopAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("stopAfter");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("stopAfter", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< StopAfterActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 82 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 82 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Optional<T>> stopAfter( Future<T> const& what ) {
															#line 82 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Optional<T>>(new StopAfterActor<T>(what));
															#line 903 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 100 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

template <class T>
T sorted(T range) {
	std::sort(range.begin(), range.end());
	return range;
}

template <class T>
std::vector<T> parseStringToVector(std::string str, char delim) {
	std::vector<T> result;
	std::stringstream stream(str);
	std::string token;
	while (stream.good()) {
		getline(stream, token, delim);
		std::istringstream tokenStream(token);
		T item;
		tokenStream >> item;
		result.push_back(item);
	}
	return result;
}

template <class T>
std::unordered_set<T> parseStringToUnorderedSet(std::string str, char delim) {
	std::unordered_set<T> result;
	std::stringstream stream(str);
	std::string token;
	while (stream.good()) {
		getline(stream, token, delim);
		std::istringstream tokenStream(token);
		T item;
		tokenStream >> item;
		result.emplace(item);
	}
	return result;
}

template <class T>
ErrorOr<T> errorOr(T t) {
	return ErrorOr<T>(t);
}

															#line 949 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via errorOr()
															#line 142 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class ErrorOrActor>
															#line 142 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ErrorOrActorState {
															#line 956 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 142 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ErrorOrActorState(Future<T> const& f) 
															#line 142 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 142 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : f(f)
															#line 963 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("errorOr", reinterpret_cast<unsigned long>(this));

	}
	~ErrorOrActorState() 
	{
		fdb_probe_actor_destroy("errorOr", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 145 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = f;
															#line 145 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<ErrorOrActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 981 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<ErrorOrActor*>(this)->actor_wait_state = 1;
															#line 145 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ErrorOrActor, 0, T >*>(static_cast<ErrorOrActor*>(this)));
															#line 986 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ErrorOrActorState();
		static_cast<ErrorOrActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 148 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (!static_cast<ErrorOrActor*>(this)->SAV<ErrorOr<T>>::futures) { (void)(ErrorOr<T>(e)); this->~ErrorOrActorState(); static_cast<ErrorOrActor*>(this)->destroy(); return 0; }
															#line 1016 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			new (&static_cast<ErrorOrActor*>(this)->SAV< ErrorOr<T> >::value()) ErrorOr<T>(ErrorOr<T>(e));
			this->~ErrorOrActorState();
			static_cast<ErrorOrActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& t,int loopDepth) 
	{
															#line 146 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ErrorOrActor*>(this)->SAV<ErrorOr<T>>::futures) { (void)(ErrorOr<T>(t)); this->~ErrorOrActorState(); static_cast<ErrorOrActor*>(this)->destroy(); return 0; }
															#line 1034 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ErrorOrActor*>(this)->SAV< ErrorOr<T> >::value()) ErrorOr<T>(ErrorOr<T>(t));
		this->~ErrorOrActorState();
		static_cast<ErrorOrActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(T && t,int loopDepth) 
	{
															#line 146 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ErrorOrActor*>(this)->SAV<ErrorOr<T>>::futures) { (void)(ErrorOr<T>(t)); this->~ErrorOrActorState(); static_cast<ErrorOrActor*>(this)->destroy(); return 0; }
															#line 1046 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ErrorOrActor*>(this)->SAV< ErrorOr<T> >::value()) ErrorOr<T>(ErrorOr<T>(t));
		this->~ErrorOrActorState();
		static_cast<ErrorOrActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
		loopDepth = a_body1cont2(t, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(t), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ErrorOrActor*>(this)->actor_wait_state > 0) static_cast<ErrorOrActor*>(this)->actor_wait_state = 0;
		static_cast<ErrorOrActor*>(this)->ActorCallback< ErrorOrActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< ErrorOrActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("errorOr", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ErrorOrActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("errorOr", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ErrorOrActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("errorOr", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ErrorOrActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("errorOr", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ErrorOrActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("errorOr", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ErrorOrActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("errorOr", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 142 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> f;
															#line 1131 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via errorOr()
															#line 142 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 142 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ErrorOrActor final : public Actor<ErrorOr<T>>, public ActorCallback< ErrorOrActor<T>, 0, T >, public FastAllocated<ErrorOrActor<T>>, public ErrorOrActorState<T, ErrorOrActor<T>> {
															#line 1138 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<ErrorOrActor<T>>::operator new;
	using FastAllocated<ErrorOrActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(6134063679998316544UL, 4931078291239366912UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<ErrorOr<T>>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< ErrorOrActor<T>, 0, T >;
															#line 142 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ErrorOrActor(Future<T> const& f) 
															#line 1155 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<ErrorOr<T>>(),
		   ErrorOrActorState<T, ErrorOrActor<T>>(f),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("errorOr", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(11716412140799802112UL, 5954230370677982464UL);
		ActorExecutionContextHelper __helper(static_cast<ErrorOrActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("errorOr");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("errorOr", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ErrorOrActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 142 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 142 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<ErrorOr<T>> errorOr( Future<T> const& f ) {
															#line 142 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<ErrorOr<T>>(new ErrorOrActor<T>(f));
															#line 1190 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 151 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 1195 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via throwErrorOr()
															#line 152 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class ThrowErrorOrActor>
															#line 152 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ThrowErrorOrActorState {
															#line 1202 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 152 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ThrowErrorOrActorState(Future<ErrorOr<T>> const& f) 
															#line 152 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 152 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : f(f)
															#line 1209 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("throwErrorOr", reinterpret_cast<unsigned long>(this));

	}
	~ThrowErrorOrActorState() 
	{
		fdb_probe_actor_destroy("throwErrorOr", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<ErrorOr<T>> __when_expr_0 = f;
															#line 154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<ThrowErrorOrActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 1226 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<ThrowErrorOrActor*>(this)->actor_wait_state = 1;
															#line 154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ThrowErrorOrActor, 0, ErrorOr<T> >*>(static_cast<ThrowErrorOrActor*>(this)));
															#line 1231 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ThrowErrorOrActorState();
		static_cast<ThrowErrorOrActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(ErrorOr<T> const& t,int loopDepth) 
	{
															#line 155 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (t.isError())
															#line 1254 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 156 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(t.getError(), loopDepth);
															#line 1258 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 157 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ThrowErrorOrActor*>(this)->SAV<T>::futures) { (void)(t.get()); this->~ThrowErrorOrActorState(); static_cast<ThrowErrorOrActor*>(this)->destroy(); return 0; }
															#line 1262 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ThrowErrorOrActor*>(this)->SAV< T >::value()) T(t.get());
		this->~ThrowErrorOrActorState();
		static_cast<ThrowErrorOrActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(ErrorOr<T> && t,int loopDepth) 
	{
															#line 155 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (t.isError())
															#line 1274 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 156 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(t.getError(), loopDepth);
															#line 1278 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 157 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ThrowErrorOrActor*>(this)->SAV<T>::futures) { (void)(t.get()); this->~ThrowErrorOrActorState(); static_cast<ThrowErrorOrActor*>(this)->destroy(); return 0; }
															#line 1282 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ThrowErrorOrActor*>(this)->SAV< T >::value()) T(t.get());
		this->~ThrowErrorOrActorState();
		static_cast<ThrowErrorOrActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(ErrorOr<T> const& t,int loopDepth) 
	{
		loopDepth = a_body1cont1(t, loopDepth);

		return loopDepth;
	}
	int a_body1when1(ErrorOr<T> && t,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(t), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ThrowErrorOrActor*>(this)->actor_wait_state > 0) static_cast<ThrowErrorOrActor*>(this)->actor_wait_state = 0;
		static_cast<ThrowErrorOrActor*>(this)->ActorCallback< ThrowErrorOrActor, 0, ErrorOr<T> >::remove();

	}
	void a_callback_fire(ActorCallback< ThrowErrorOrActor, 0, ErrorOr<T> >*,ErrorOr<T> const& value) 
	{
		fdb_probe_actor_enter("throwErrorOr", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ThrowErrorOrActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("throwErrorOr", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ThrowErrorOrActor, 0, ErrorOr<T> >*,ErrorOr<T> && value) 
	{
		fdb_probe_actor_enter("throwErrorOr", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ThrowErrorOrActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("throwErrorOr", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ThrowErrorOrActor, 0, ErrorOr<T> >*,Error err) 
	{
		fdb_probe_actor_enter("throwErrorOr", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ThrowErrorOrActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("throwErrorOr", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 152 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<ErrorOr<T>> f;
															#line 1367 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via throwErrorOr()
															#line 152 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 152 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ThrowErrorOrActor final : public Actor<T>, public ActorCallback< ThrowErrorOrActor<T>, 0, ErrorOr<T> >, public FastAllocated<ThrowErrorOrActor<T>>, public ThrowErrorOrActorState<T, ThrowErrorOrActor<T>> {
															#line 1374 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<ThrowErrorOrActor<T>>::operator new;
	using FastAllocated<ThrowErrorOrActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(8872135941628877568UL, 796472394065171968UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< ThrowErrorOrActor<T>, 0, ErrorOr<T> >;
															#line 152 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ThrowErrorOrActor(Future<ErrorOr<T>> const& f) 
															#line 1391 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   ThrowErrorOrActorState<T, ThrowErrorOrActor<T>>(f),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("throwErrorOr", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(2769770343984196352UL, 5857954321368918784UL);
		ActorExecutionContextHelper __helper(static_cast<ThrowErrorOrActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("throwErrorOr");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("throwErrorOr", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ThrowErrorOrActor<T>, 0, ErrorOr<T> >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 152 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 152 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> throwErrorOr( Future<ErrorOr<T>> const& f ) {
															#line 152 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new ThrowErrorOrActor<T>(f));
															#line 1426 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 159 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 1431 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via transformErrors()
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class TransformErrorsActor>
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TransformErrorsActorState {
															#line 1438 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TransformErrorsActorState(Future<T> const& f,Error const& err) 
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : f(f),
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   err(err)
															#line 1447 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("transformErrors", reinterpret_cast<unsigned long>(this));

	}
	~TransformErrorsActorState() 
	{
		fdb_probe_actor_destroy("transformErrors", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 163 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = f;
															#line 163 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<TransformErrorsActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 1465 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<TransformErrorsActor*>(this)->actor_wait_state = 1;
															#line 163 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TransformErrorsActor, 0, T >*>(static_cast<TransformErrorsActor*>(this)));
															#line 1470 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TransformErrorsActorState();
		static_cast<TransformErrorsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 166 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == error_code_actor_cancelled)
															#line 1500 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				return a_body1Catch1(e, loopDepth);
															#line 1504 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 168 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(err, loopDepth);
															#line 1508 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& t,int loopDepth) 
	{
															#line 164 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TransformErrorsActor*>(this)->SAV<T>::futures) { (void)(t); this->~TransformErrorsActorState(); static_cast<TransformErrorsActor*>(this)->destroy(); return 0; }
															#line 1522 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TransformErrorsActor*>(this)->SAV< T >::value()) T(t);
		this->~TransformErrorsActorState();
		static_cast<TransformErrorsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(T && t,int loopDepth) 
	{
															#line 164 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TransformErrorsActor*>(this)->SAV<T>::futures) { (void)(t); this->~TransformErrorsActorState(); static_cast<TransformErrorsActor*>(this)->destroy(); return 0; }
															#line 1534 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TransformErrorsActor*>(this)->SAV< T >::value()) T(t);
		this->~TransformErrorsActorState();
		static_cast<TransformErrorsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
		loopDepth = a_body1cont2(t, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(t), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TransformErrorsActor*>(this)->actor_wait_state > 0) static_cast<TransformErrorsActor*>(this)->actor_wait_state = 0;
		static_cast<TransformErrorsActor*>(this)->ActorCallback< TransformErrorsActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< TransformErrorsActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("transformErrors", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TransformErrorsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transformErrors", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TransformErrorsActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("transformErrors", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TransformErrorsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transformErrors", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TransformErrorsActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("transformErrors", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TransformErrorsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transformErrors", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> f;
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Error err;
															#line 1621 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via transformErrors()
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TransformErrorsActor final : public Actor<T>, public ActorCallback< TransformErrorsActor<T>, 0, T >, public FastAllocated<TransformErrorsActor<T>>, public TransformErrorsActorState<T, TransformErrorsActor<T>> {
															#line 1628 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TransformErrorsActor<T>>::operator new;
	using FastAllocated<TransformErrorsActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(12966940416914181632UL, 17726312748881727488UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TransformErrorsActor<T>, 0, T >;
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TransformErrorsActor(Future<T> const& f,Error const& err) 
															#line 1645 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   TransformErrorsActorState<T, TransformErrorsActor<T>>(f, err),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("transformErrors", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(11657275394851593984UL, 6624815060724573696UL);
		ActorExecutionContextHelper __helper(static_cast<TransformErrorsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("transformErrors");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("transformErrors", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TransformErrorsActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> transformErrors( Future<T> const& f, Error const& err ) {
															#line 160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new TransformErrorsActor<T>(f, err));
															#line 1680 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 171 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 1685 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via transformError()
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class TransformErrorActor>
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TransformErrorActorState {
															#line 1692 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TransformErrorActorState(Future<T> const& f,Error const& inErr,Error const& outErr) 
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : f(f),
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   inErr(inErr),
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   outErr(outErr)
															#line 1703 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("transformError", reinterpret_cast<unsigned long>(this));

	}
	~TransformErrorActorState() 
	{
		fdb_probe_actor_destroy("transformError", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 175 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = f;
															#line 175 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<TransformErrorActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 1721 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<TransformErrorActor*>(this)->actor_wait_state = 1;
															#line 175 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TransformErrorActor, 0, T >*>(static_cast<TransformErrorActor*>(this)));
															#line 1726 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TransformErrorActorState();
		static_cast<TransformErrorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 178 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == inErr.code())
															#line 1756 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 179 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				return a_body1Catch1(outErr, loopDepth);
															#line 1760 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 180 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(e, loopDepth);
															#line 1764 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& t,int loopDepth) 
	{
															#line 176 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TransformErrorActor*>(this)->SAV<T>::futures) { (void)(t); this->~TransformErrorActorState(); static_cast<TransformErrorActor*>(this)->destroy(); return 0; }
															#line 1778 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TransformErrorActor*>(this)->SAV< T >::value()) T(t);
		this->~TransformErrorActorState();
		static_cast<TransformErrorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(T && t,int loopDepth) 
	{
															#line 176 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TransformErrorActor*>(this)->SAV<T>::futures) { (void)(t); this->~TransformErrorActorState(); static_cast<TransformErrorActor*>(this)->destroy(); return 0; }
															#line 1790 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TransformErrorActor*>(this)->SAV< T >::value()) T(t);
		this->~TransformErrorActorState();
		static_cast<TransformErrorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
		loopDepth = a_body1cont2(t, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(t), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TransformErrorActor*>(this)->actor_wait_state > 0) static_cast<TransformErrorActor*>(this)->actor_wait_state = 0;
		static_cast<TransformErrorActor*>(this)->ActorCallback< TransformErrorActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< TransformErrorActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("transformError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TransformErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transformError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TransformErrorActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("transformError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TransformErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transformError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TransformErrorActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("transformError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TransformErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transformError", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> f;
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Error inErr;
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Error outErr;
															#line 1879 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via transformError()
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TransformErrorActor final : public Actor<T>, public ActorCallback< TransformErrorActor<T>, 0, T >, public FastAllocated<TransformErrorActor<T>>, public TransformErrorActorState<T, TransformErrorActor<T>> {
															#line 1886 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TransformErrorActor<T>>::operator new;
	using FastAllocated<TransformErrorActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(7803510751690994944UL, 9016358815206065408UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TransformErrorActor<T>, 0, T >;
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TransformErrorActor(Future<T> const& f,Error const& inErr,Error const& outErr) 
															#line 1903 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   TransformErrorActorState<T, TransformErrorActor<T>>(f, inErr, outErr),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("transformError", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9980958667131008256UL, 637528603381318400UL);
		ActorExecutionContextHelper __helper(static_cast<TransformErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("transformError");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("transformError", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TransformErrorActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> transformError( Future<T> const& f, Error const& inErr, Error const& outErr ) {
															#line 172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new TransformErrorActor<T>(f, inErr, outErr));
															#line 1938 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 183 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// Note that the RequestStream<T> version of forwardPromise doesn't exist, because what to do with errors?

															#line 1945 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via forwardEvent()
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class ForwardEventActor>
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ForwardEventActorState {
															#line 1952 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ForwardEventActorState(Event* const& ev,Future<T> const& input) 
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : ev(ev),
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   input(input)
															#line 1961 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("forwardEvent", reinterpret_cast<unsigned long>(this));

	}
	~ForwardEventActorState() 
	{
		fdb_probe_actor_destroy("forwardEvent", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 189 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = input;
															#line 189 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 1979 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				static_cast<ForwardEventActor*>(this)->actor_wait_state = 1;
															#line 189 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ForwardEventActor, 0, T >*>(static_cast<ForwardEventActor*>(this)));
															#line 1983 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		delete static_cast<ForwardEventActor*>(this);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 192 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		ev->set();
															#line 2011 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1Catch2(const Error& __current_error,int loopDepth=0) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& value,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(T && value,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when1(T const& value,int loopDepth) 
	{
		loopDepth = a_body1cont2(value, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && value,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(value), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ForwardEventActor*>(this)->actor_wait_state > 0) static_cast<ForwardEventActor*>(this)->actor_wait_state = 0;
		static_cast<ForwardEventActor*>(this)->ActorCallback< ForwardEventActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< ForwardEventActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("forwardEvent", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardEventActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forwardEvent", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ForwardEventActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("forwardEvent", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardEventActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forwardEvent", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ForwardEventActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("forwardEvent", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardEventActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forwardEvent", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont5(int loopDepth) 
	{
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		delete static_cast<ForwardEventActor*>(this);
															#line 2133 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		return 0;

		return loopDepth;
	}
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Event* ev;
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> input;
															#line 2142 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via forwardEvent()
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ForwardEventActor final : public Actor<void>, public ActorCallback< ForwardEventActor<T>, 0, T >, public FastAllocated<ForwardEventActor<T>>, public ForwardEventActorState<T, ForwardEventActor<T>> {
															#line 2149 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<ForwardEventActor<T>>::operator new;
	using FastAllocated<ForwardEventActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(8087554455476141312UL, 13539559892440549120UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() {{
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<void>*>(this)->~Actor();
        operator delete(this);
    }}
#pragma clang diagnostic pop
friend struct ActorCallback< ForwardEventActor<T>, 0, T >;
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ForwardEventActor(Event* const& ev,Future<T> const& input) 
															#line 2166 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<void>(),
		   ForwardEventActorState<T, ForwardEventActor<T>>(ev, input),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("forwardEvent", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(6200645388654390528UL, 9166489727541313536UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardEventActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("forwardEvent");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("forwardEvent", reinterpret_cast<unsigned long>(this), -1);

	}
};
} // namespace
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
void forwardEvent( Event* const& ev, Future<T> const& input ) {
															#line 186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	new ForwardEventActor<T>(ev, input);
															#line 2192 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 2197 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via forwardEvent()
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class ForwardEventActor1>
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ForwardEventActor1State {
															#line 2204 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ForwardEventActor1State(Event* const& ev,T* const& t,Error* const& err,FutureStream<T> const& input) 
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : ev(ev),
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   t(t),
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   err(err),
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   input(input)
															#line 2217 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("forwardEvent", reinterpret_cast<unsigned long>(this));

	}
	~ForwardEventActor1State() 
	{
		fdb_probe_actor_destroy("forwardEvent", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 198 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				FutureStream<T> __when_expr_0 = input;
															#line 198 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.pop(), loopDepth); };
															#line 2235 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				static_cast<ForwardEventActor1*>(this)->actor_wait_state = 1;
															#line 198 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< ForwardEventActor1, 0, T >*>(static_cast<ForwardEventActor1*>(this)));
															#line 2239 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		delete static_cast<ForwardEventActor1*>(this);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 202 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			*err = e;
															#line 203 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			ev->set();
															#line 2276 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& value,int loopDepth) 
	{
															#line 199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		*t = std::move(value);
															#line 200 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		ev->set();
															#line 2293 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(T && value,int loopDepth) 
	{
															#line 199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		*t = std::move(value);
															#line 200 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		ev->set();
															#line 2304 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1when1(T const& value,int loopDepth) 
	{
		loopDepth = a_body1cont2(value, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && value,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(value), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ForwardEventActor1*>(this)->actor_wait_state > 0) static_cast<ForwardEventActor1*>(this)->actor_wait_state = 0;
		static_cast<ForwardEventActor1*>(this)->ActorSingleCallback< ForwardEventActor1, 0, T >::remove();

	}
	void a_callback_fire(ActorSingleCallback< ForwardEventActor1, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("forwardEvent", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardEventActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forwardEvent", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< ForwardEventActor1, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("forwardEvent", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardEventActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forwardEvent", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< ForwardEventActor1, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("forwardEvent", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardEventActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forwardEvent", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont4(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont5(int loopDepth) 
	{
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		delete static_cast<ForwardEventActor1*>(this);
															#line 2401 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		return 0;

		return loopDepth;
	}
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Event* ev;
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	T* t;
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Error* err;
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FutureStream<T> input;
															#line 2414 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via forwardEvent()
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ForwardEventActor1 final : public Actor<void>, public ActorSingleCallback< ForwardEventActor1<T>, 0, T >, public FastAllocated<ForwardEventActor1<T>>, public ForwardEventActor1State<T, ForwardEventActor1<T>> {
															#line 2421 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<ForwardEventActor1<T>>::operator new;
	using FastAllocated<ForwardEventActor1<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(8087554455476141312UL, 13539559892440549120UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() {{
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<void>*>(this)->~Actor();
        operator delete(this);
    }}
#pragma clang diagnostic pop
friend struct ActorSingleCallback< ForwardEventActor1<T>, 0, T >;
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ForwardEventActor1(Event* const& ev,T* const& t,Error* const& err,FutureStream<T> const& input) 
															#line 2438 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<void>(),
		   ForwardEventActor1State<T, ForwardEventActor1<T>>(ev, t, err, input),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("forwardEvent", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(14562188606497896192UL, 2586663270842488832UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardEventActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("forwardEvent");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("forwardEvent", reinterpret_cast<unsigned long>(this), -1);

	}
};
} // namespace
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
void forwardEvent( Event* const& ev, T* const& t, Error* const& err, FutureStream<T> const& input ) {
															#line 195 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	new ForwardEventActor1<T>(ev, t, err, input);
															#line 2464 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 206 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 2469 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via waitForAllReady()
															#line 207 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class WaitForAllReadyActor>
															#line 207 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class WaitForAllReadyActorState {
															#line 2476 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 207 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	WaitForAllReadyActorState(std::vector<Future<T>> const& results) 
															#line 207 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 207 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : results(results),
															#line 209 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   i(0)
															#line 2485 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("waitForAllReady", reinterpret_cast<unsigned long>(this));

	}
	~WaitForAllReadyActorState() 
	{
		fdb_probe_actor_destroy("waitForAllReady", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 210 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 2500 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WaitForAllReadyActorState();
		static_cast<WaitForAllReadyActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 211 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (i == results.size())
															#line 2530 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 212 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (!static_cast<WaitForAllReadyActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WaitForAllReadyActorState(); static_cast<WaitForAllReadyActor*>(this)->destroy(); return 0; }
															#line 2534 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			new (&static_cast<WaitForAllReadyActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~WaitForAllReadyActorState();
			static_cast<WaitForAllReadyActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		try {
															#line 214 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = results[i];
															#line 214 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<WaitForAllReadyActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 2545 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<WaitForAllReadyActor*>(this)->actor_wait_state = 1;
															#line 214 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WaitForAllReadyActor, 0, T >*>(static_cast<WaitForAllReadyActor*>(this)));
															#line 2550 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
															#line 218 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		i++;
															#line 2565 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& __current_error,int loopDepth=0) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3(T const& t,int loopDepth) 
	{
															#line 215 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		(void)t;
															#line 2587 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3(T && t,int loopDepth) 
	{
															#line 215 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		(void)t;
															#line 2596 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T const& t,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(t, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T && t,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(std::move(t), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WaitForAllReadyActor*>(this)->actor_wait_state > 0) static_cast<WaitForAllReadyActor*>(this)->actor_wait_state = 0;
		static_cast<WaitForAllReadyActor*>(this)->ActorCallback< WaitForAllReadyActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< WaitForAllReadyActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("waitForAllReady", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<WaitForAllReadyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForAllReady", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WaitForAllReadyActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("waitForAllReady", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<WaitForAllReadyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForAllReady", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WaitForAllReadyActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("waitForAllReady", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<WaitForAllReadyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForAllReady", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont5(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
															#line 207 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	std::vector<Future<T>> results;
															#line 209 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	int i;
															#line 2693 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via waitForAllReady()
															#line 207 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 207 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class WaitForAllReadyActor final : public Actor<Void>, public ActorCallback< WaitForAllReadyActor<T>, 0, T >, public FastAllocated<WaitForAllReadyActor<T>>, public WaitForAllReadyActorState<T, WaitForAllReadyActor<T>> {
															#line 2700 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<WaitForAllReadyActor<T>>::operator new;
	using FastAllocated<WaitForAllReadyActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(6039226283946069504UL, 8259242651293351680UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< WaitForAllReadyActor<T>, 0, T >;
															#line 207 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	WaitForAllReadyActor(std::vector<Future<T>> const& results) 
															#line 2717 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   WaitForAllReadyActorState<T, WaitForAllReadyActor<T>>(results),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("waitForAllReady", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(10563470008250428928UL, 627497100362957824UL);
		ActorExecutionContextHelper __helper(static_cast<WaitForAllReadyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("waitForAllReady");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("waitForAllReady", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WaitForAllReadyActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 207 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 207 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> waitForAllReady( std::vector<Future<T>> const& results ) {
															#line 207 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new WaitForAllReadyActor<T>(results));
															#line 2752 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 221 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 2757 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via timeout()
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class TimeoutActor>
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TimeoutActorState {
															#line 2764 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TimeoutActorState(Future<T> const& what,double const& time,T const& timedoutValue,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   time(time),
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   timedoutValue(timedoutValue),
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   taskID(taskID)
															#line 2777 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("timeout", reinterpret_cast<unsigned long>(this));

	}
	~TimeoutActorState() 
	{
		fdb_probe_actor_destroy("timeout", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 224 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			Future<Void> end = delay(time, taskID);
															#line 226 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = what;
															#line 225 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<TimeoutActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 2796 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 229 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_1 = end;
															#line 2800 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1when2(__when_expr_1.get(), loopDepth); };
			static_cast<TimeoutActor*>(this)->actor_wait_state = 1;
															#line 226 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TimeoutActor, 0, T >*>(static_cast<TimeoutActor*>(this)));
															#line 229 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< TimeoutActor, 1, Void >*>(static_cast<TimeoutActor*>(this)));
															#line 2807 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TimeoutActorState();
		static_cast<TimeoutActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
															#line 227 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TimeoutActor*>(this)->SAV<T>::futures) { (void)(t); this->~TimeoutActorState(); static_cast<TimeoutActor*>(this)->destroy(); return 0; }
															#line 2830 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TimeoutActor*>(this)->SAV< T >::value()) T(t);
		this->~TimeoutActorState();
		static_cast<TimeoutActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
															#line 227 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TimeoutActor*>(this)->SAV<T>::futures) { (void)(t); this->~TimeoutActorState(); static_cast<TimeoutActor*>(this)->destroy(); return 0; }
															#line 2842 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TimeoutActor*>(this)->SAV< T >::value()) T(t);
		this->~TimeoutActorState();
		static_cast<TimeoutActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when2(Void const& _,int loopDepth) 
	{
															#line 230 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TimeoutActor*>(this)->SAV<T>::futures) { (void)(timedoutValue); this->~TimeoutActorState(); static_cast<TimeoutActor*>(this)->destroy(); return 0; }
															#line 2854 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TimeoutActor*>(this)->SAV< T >::value()) T(std::move(timedoutValue)); // state_var_RVO
		this->~TimeoutActorState();
		static_cast<TimeoutActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when2(Void && _,int loopDepth) 
	{
															#line 230 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TimeoutActor*>(this)->SAV<T>::futures) { (void)(timedoutValue); this->~TimeoutActorState(); static_cast<TimeoutActor*>(this)->destroy(); return 0; }
															#line 2866 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TimeoutActor*>(this)->SAV< T >::value()) T(std::move(timedoutValue)); // state_var_RVO
		this->~TimeoutActorState();
		static_cast<TimeoutActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TimeoutActor*>(this)->actor_wait_state > 0) static_cast<TimeoutActor*>(this)->actor_wait_state = 0;
		static_cast<TimeoutActor*>(this)->ActorCallback< TimeoutActor, 0, T >::remove();
		static_cast<TimeoutActor*>(this)->ActorCallback< TimeoutActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TimeoutActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TimeoutActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TimeoutActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TimeoutActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< TimeoutActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< TimeoutActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double time;
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	T timedoutValue;
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TaskPriority taskID;
															#line 3003 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via timeout()
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TimeoutActor final : public Actor<T>, public ActorCallback< TimeoutActor<T>, 0, T >, public ActorCallback< TimeoutActor<T>, 1, Void >, public FastAllocated<TimeoutActor<T>>, public TimeoutActorState<T, TimeoutActor<T>> {
															#line 3010 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TimeoutActor<T>>::operator new;
	using FastAllocated<TimeoutActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(2469009687630835968UL, 5200064161727014144UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TimeoutActor<T>, 0, T >;
friend struct ActorCallback< TimeoutActor<T>, 1, Void >;
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TimeoutActor(Future<T> const& what,double const& time,T const& timedoutValue,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 3028 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   TimeoutActorState<T, TimeoutActor<T>>(what, time, timedoutValue, taskID),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(13051185860954458624UL, 15486350049698238976UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("timeout");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TimeoutActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> timeout( Future<T> const& what, double const& time, T const& timedoutValue, TaskPriority const& taskID = TaskPriority::DefaultDelay ) {
															#line 222 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new TimeoutActor<T>(what, time, timedoutValue, taskID));
															#line 3063 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 3068 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via timeout()
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class TimeoutActor1>
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TimeoutActor1State {
															#line 3075 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TimeoutActor1State(Future<T> const& what,double const& time) 
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   time(time)
															#line 3084 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("timeout", reinterpret_cast<unsigned long>(this));

	}
	~TimeoutActor1State() 
	{
		fdb_probe_actor_destroy("timeout", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 237 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			Future<Void> end = delay(time);
															#line 239 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = what;
															#line 238 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<TimeoutActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 3103 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 242 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_1 = end;
															#line 3107 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1when2(__when_expr_1.get(), loopDepth); };
			static_cast<TimeoutActor1*>(this)->actor_wait_state = 1;
															#line 239 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TimeoutActor1, 0, T >*>(static_cast<TimeoutActor1*>(this)));
															#line 242 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< TimeoutActor1, 1, Void >*>(static_cast<TimeoutActor1*>(this)));
															#line 3114 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TimeoutActor1State();
		static_cast<TimeoutActor1*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
															#line 240 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TimeoutActor1*>(this)->SAV<Optional<T>>::futures) { (void)(t); this->~TimeoutActor1State(); static_cast<TimeoutActor1*>(this)->destroy(); return 0; }
															#line 3137 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TimeoutActor1*>(this)->SAV< Optional<T> >::value()) Optional<T>(t);
		this->~TimeoutActor1State();
		static_cast<TimeoutActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
															#line 240 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TimeoutActor1*>(this)->SAV<Optional<T>>::futures) { (void)(t); this->~TimeoutActor1State(); static_cast<TimeoutActor1*>(this)->destroy(); return 0; }
															#line 3149 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TimeoutActor1*>(this)->SAV< Optional<T> >::value()) Optional<T>(t);
		this->~TimeoutActor1State();
		static_cast<TimeoutActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when2(Void const& _,int loopDepth) 
	{
															#line 243 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TimeoutActor1*>(this)->SAV<Optional<T>>::futures) { (void)(Optional<T>()); this->~TimeoutActor1State(); static_cast<TimeoutActor1*>(this)->destroy(); return 0; }
															#line 3161 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TimeoutActor1*>(this)->SAV< Optional<T> >::value()) Optional<T>(Optional<T>());
		this->~TimeoutActor1State();
		static_cast<TimeoutActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when2(Void && _,int loopDepth) 
	{
															#line 243 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TimeoutActor1*>(this)->SAV<Optional<T>>::futures) { (void)(Optional<T>()); this->~TimeoutActor1State(); static_cast<TimeoutActor1*>(this)->destroy(); return 0; }
															#line 3173 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TimeoutActor1*>(this)->SAV< Optional<T> >::value()) Optional<T>(Optional<T>());
		this->~TimeoutActor1State();
		static_cast<TimeoutActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TimeoutActor1*>(this)->actor_wait_state > 0) static_cast<TimeoutActor1*>(this)->actor_wait_state = 0;
		static_cast<TimeoutActor1*>(this)->ActorCallback< TimeoutActor1, 0, T >::remove();
		static_cast<TimeoutActor1*>(this)->ActorCallback< TimeoutActor1, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TimeoutActor1, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TimeoutActor1, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TimeoutActor1, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TimeoutActor1, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< TimeoutActor1, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< TimeoutActor1, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double time;
															#line 3306 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via timeout()
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TimeoutActor1 final : public Actor<Optional<T>>, public ActorCallback< TimeoutActor1<T>, 0, T >, public ActorCallback< TimeoutActor1<T>, 1, Void >, public FastAllocated<TimeoutActor1<T>>, public TimeoutActor1State<T, TimeoutActor1<T>> {
															#line 3313 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TimeoutActor1<T>>::operator new;
	using FastAllocated<TimeoutActor1<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(2469009687630835968UL, 5200064161727014144UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Optional<T>>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TimeoutActor1<T>, 0, T >;
friend struct ActorCallback< TimeoutActor1<T>, 1, Void >;
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TimeoutActor1(Future<T> const& what,double const& time) 
															#line 3331 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Optional<T>>(),
		   TimeoutActor1State<T, TimeoutActor1<T>>(what, time),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("timeout", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(7560104613500780800UL, 5405592158884213248UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("timeout");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("timeout", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TimeoutActor1<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Optional<T>> timeout( Future<T> const& what, double const& time ) {
															#line 235 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Optional<T>>(new TimeoutActor1<T>(what, time));
															#line 3366 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 247 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 3371 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via timeoutError()
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class TimeoutErrorActor>
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TimeoutErrorActorState {
															#line 3378 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TimeoutErrorActorState(Future<T> const& what,double const& time,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   time(time),
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   taskID(taskID)
															#line 3389 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("timeoutError", reinterpret_cast<unsigned long>(this));

	}
	~TimeoutErrorActorState() 
	{
		fdb_probe_actor_destroy("timeoutError", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 250 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			Future<Void> end = delay(time, taskID);
															#line 252 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = what;
															#line 251 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<TimeoutErrorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 3408 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 255 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_1 = end;
															#line 3412 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1when2(__when_expr_1.get(), loopDepth); };
			static_cast<TimeoutErrorActor*>(this)->actor_wait_state = 1;
															#line 252 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TimeoutErrorActor, 0, T >*>(static_cast<TimeoutErrorActor*>(this)));
															#line 255 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< TimeoutErrorActor, 1, Void >*>(static_cast<TimeoutErrorActor*>(this)));
															#line 3419 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TimeoutErrorActorState();
		static_cast<TimeoutErrorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
															#line 253 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TimeoutErrorActor*>(this)->SAV<T>::futures) { (void)(t); this->~TimeoutErrorActorState(); static_cast<TimeoutErrorActor*>(this)->destroy(); return 0; }
															#line 3442 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TimeoutErrorActor*>(this)->SAV< T >::value()) T(t);
		this->~TimeoutErrorActorState();
		static_cast<TimeoutErrorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
															#line 253 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TimeoutErrorActor*>(this)->SAV<T>::futures) { (void)(t); this->~TimeoutErrorActorState(); static_cast<TimeoutErrorActor*>(this)->destroy(); return 0; }
															#line 3454 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TimeoutErrorActor*>(this)->SAV< T >::value()) T(t);
		this->~TimeoutErrorActorState();
		static_cast<TimeoutErrorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when2(Void const& _,int loopDepth) 
	{
															#line 256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(timed_out(), loopDepth);
															#line 3466 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	int a_body1when2(Void && _,int loopDepth) 
	{
															#line 256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(timed_out(), loopDepth);
															#line 3474 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TimeoutErrorActor*>(this)->actor_wait_state > 0) static_cast<TimeoutErrorActor*>(this)->actor_wait_state = 0;
		static_cast<TimeoutErrorActor*>(this)->ActorCallback< TimeoutErrorActor, 0, T >::remove();
		static_cast<TimeoutErrorActor*>(this)->ActorCallback< TimeoutErrorActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TimeoutErrorActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("timeoutError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeoutError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TimeoutErrorActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("timeoutError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeoutError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TimeoutErrorActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("timeoutError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeoutError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TimeoutErrorActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("timeoutError", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeoutError", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< TimeoutErrorActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("timeoutError", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeoutError", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< TimeoutErrorActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("timeoutError", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeoutError", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double time;
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TaskPriority taskID;
															#line 3605 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via timeoutError()
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TimeoutErrorActor final : public Actor<T>, public ActorCallback< TimeoutErrorActor<T>, 0, T >, public ActorCallback< TimeoutErrorActor<T>, 1, Void >, public FastAllocated<TimeoutErrorActor<T>>, public TimeoutErrorActorState<T, TimeoutErrorActor<T>> {
															#line 3612 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TimeoutErrorActor<T>>::operator new;
	using FastAllocated<TimeoutErrorActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(10375753750647546880UL, 5868804090468441344UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TimeoutErrorActor<T>, 0, T >;
friend struct ActorCallback< TimeoutErrorActor<T>, 1, Void >;
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TimeoutErrorActor(Future<T> const& what,double const& time,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 3630 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   TimeoutErrorActorState<T, TimeoutErrorActor<T>>(what, time, taskID),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("timeoutError", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(778417935462168064UL, 640599530370607360UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("timeoutError");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("timeoutError", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TimeoutErrorActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> timeoutError( Future<T> const& what, double const& time, TaskPriority const& taskID = TaskPriority::DefaultDelay ) {
															#line 248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new TimeoutErrorActor<T>(what, time, taskID));
															#line 3665 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 260 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 3670 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via delayed()
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class DelayedActor>
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DelayedActorState {
															#line 3677 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DelayedActorState(Future<T> const& what,double const& time = 0.0,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   time(time),
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   taskID(taskID)
															#line 3688 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("delayed", reinterpret_cast<unsigned long>(this));

	}
	~DelayedActorState() 
	{
		fdb_probe_actor_destroy("delayed", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 264 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = what;
															#line 264 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<DelayedActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 3706 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<DelayedActor*>(this)->actor_wait_state = 1;
															#line 264 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< DelayedActor, 0, T >*>(static_cast<DelayedActor*>(this)));
															#line 3711 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~DelayedActorState();
		static_cast<DelayedActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 268 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			err = e;
															#line 269 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_2 = delay(time, taskID);
															#line 269 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<DelayedActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 3745 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1Catch2when1(__when_expr_2.get(), loopDepth); };
			static_cast<DelayedActor*>(this)->actor_wait_state = 3;
															#line 269 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< DelayedActor, 2, Void >*>(static_cast<DelayedActor*>(this)));
															#line 3750 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(int loopDepth) 
	{
															#line 265 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_1 = delay(time, taskID);
															#line 265 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<DelayedActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 3767 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), loopDepth); else return a_body1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<DelayedActor*>(this)->actor_wait_state = 2;
															#line 265 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< DelayedActor, 1, Void >*>(static_cast<DelayedActor*>(this)));
															#line 3772 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(T const& __t,int loopDepth) 
	{
															#line 264 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		t = __t;
															#line 3781 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && __t,int loopDepth) 
	{
		t = std::move(__t);
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<DelayedActor*>(this)->actor_wait_state > 0) static_cast<DelayedActor*>(this)->actor_wait_state = 0;
		static_cast<DelayedActor*>(this)->ActorCallback< DelayedActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< DelayedActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("delayed", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayed", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< DelayedActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("delayed", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayed", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< DelayedActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("delayed", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayed", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(Void const& _,int loopDepth) 
	{
															#line 266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<DelayedActor*>(this)->SAV<T>::futures) { (void)(t); this->~DelayedActorState(); static_cast<DelayedActor*>(this)->destroy(); return 0; }
															#line 3860 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<DelayedActor*>(this)->SAV< T >::value()) T(std::move(t)); // state_var_RVO
		this->~DelayedActorState();
		static_cast<DelayedActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont3(Void && _,int loopDepth) 
	{
															#line 266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<DelayedActor*>(this)->SAV<T>::futures) { (void)(t); this->~DelayedActorState(); static_cast<DelayedActor*>(this)->destroy(); return 0; }
															#line 3872 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<DelayedActor*>(this)->SAV< T >::value()) T(std::move(t)); // state_var_RVO
		this->~DelayedActorState();
		static_cast<DelayedActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<DelayedActor*>(this)->actor_wait_state > 0) static_cast<DelayedActor*>(this)->actor_wait_state = 0;
		static_cast<DelayedActor*>(this)->ActorCallback< DelayedActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DelayedActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("delayed", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayed", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< DelayedActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("delayed", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayed", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< DelayedActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("delayed", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayed", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1Catch2cont1(Void const& _,int loopDepth) 
	{
															#line 270 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(err, loopDepth);
															#line 3959 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	int a_body1Catch2cont1(Void && _,int loopDepth) 
	{
															#line 270 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(err, loopDepth);
															#line 3967 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	int a_body1Catch2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1Catch2cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1Catch2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1Catch2cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<DelayedActor*>(this)->actor_wait_state > 0) static_cast<DelayedActor*>(this)->actor_wait_state = 0;
		static_cast<DelayedActor*>(this)->ActorCallback< DelayedActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DelayedActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("delayed", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose3();
		try {
			a_body1Catch2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayed", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< DelayedActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("delayed", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose3();
		try {
			a_body1Catch2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayed", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< DelayedActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("delayed", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayed", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double time;
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TaskPriority taskID;
															#line 264 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	T t;
															#line 268 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Error err;
															#line 4056 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via delayed()
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DelayedActor final : public Actor<T>, public ActorCallback< DelayedActor<T>, 0, T >, public ActorCallback< DelayedActor<T>, 1, Void >, public ActorCallback< DelayedActor<T>, 2, Void >, public FastAllocated<DelayedActor<T>>, public DelayedActorState<T, DelayedActor<T>> {
															#line 4063 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<DelayedActor<T>>::operator new;
	using FastAllocated<DelayedActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(10921215705665524480UL, 17003875950591196160UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< DelayedActor<T>, 0, T >;
friend struct ActorCallback< DelayedActor<T>, 1, Void >;
friend struct ActorCallback< DelayedActor<T>, 2, Void >;
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DelayedActor(Future<T> const& what,double const& time = 0.0,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 4082 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   DelayedActorState<T, DelayedActor<T>>(what, time, taskID),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("delayed", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(14478744964553408000UL, 13433997968188451584UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("delayed");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("delayed", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< DelayedActor<T>, 0, T >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< DelayedActor<T>, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< DelayedActor<T>, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> delayed( Future<T> const& what, double const& time = 0.0, TaskPriority const& taskID = TaskPriority::DefaultDelay ) {
															#line 261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new DelayedActor<T>(what, time, taskID));
															#line 4119 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 273 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 4124 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via trigger()
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Func, class TriggerActor>
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TriggerActorState {
															#line 4131 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TriggerActorState(Func const& what,Future<Void> const& signal) 
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   signal(signal)
															#line 4140 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("trigger", reinterpret_cast<unsigned long>(this));

	}
	~TriggerActorState() 
	{
		fdb_probe_actor_destroy("trigger", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 276 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = signal;
															#line 276 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<TriggerActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 4157 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<TriggerActor*>(this)->actor_wait_state = 1;
															#line 276 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TriggerActor, 0, Void >*>(static_cast<TriggerActor*>(this)));
															#line 4162 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TriggerActorState();
		static_cast<TriggerActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 277 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		what();
															#line 278 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TriggerActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TriggerActorState(); static_cast<TriggerActor*>(this)->destroy(); return 0; }
															#line 4187 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TriggerActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~TriggerActorState();
		static_cast<TriggerActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 277 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		what();
															#line 278 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TriggerActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TriggerActorState(); static_cast<TriggerActor*>(this)->destroy(); return 0; }
															#line 4201 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TriggerActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~TriggerActorState();
		static_cast<TriggerActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TriggerActor*>(this)->actor_wait_state > 0) static_cast<TriggerActor*>(this)->actor_wait_state = 0;
		static_cast<TriggerActor*>(this)->ActorCallback< TriggerActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TriggerActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("trigger", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TriggerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("trigger", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TriggerActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("trigger", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TriggerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("trigger", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TriggerActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("trigger", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TriggerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("trigger", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Func what;
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> signal;
															#line 4288 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via trigger()
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Func>
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TriggerActor final : public Actor<Void>, public ActorCallback< TriggerActor<Func>, 0, Void >, public FastAllocated<TriggerActor<Func>>, public TriggerActorState<Func, TriggerActor<Func>> {
															#line 4295 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TriggerActor<Func>>::operator new;
	using FastAllocated<TriggerActor<Func>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(15551197138943402752UL, 13345315071055570688UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TriggerActor<Func>, 0, Void >;
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TriggerActor(Func const& what,Future<Void> const& signal) 
															#line 4312 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   TriggerActorState<Func, TriggerActor<Func>>(what, signal),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("trigger", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(13374690680355781632UL, 17606309391711693824UL);
		ActorExecutionContextHelper __helper(static_cast<TriggerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("trigger");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("trigger", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TriggerActor<Func>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Func>
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> trigger( Func const& what, Future<Void> const& signal ) {
															#line 274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new TriggerActor<Func>(what, signal));
															#line 4347 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 280 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 4352 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via triggerOnError()
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Func, class TriggerOnErrorActor>
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TriggerOnErrorActorState {
															#line 4359 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TriggerOnErrorActorState(Func const& what,Future<Void> const& signal) 
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   signal(signal)
															#line 4368 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("triggerOnError", reinterpret_cast<unsigned long>(this));

	}
	~TriggerOnErrorActorState() 
	{
		fdb_probe_actor_destroy("triggerOnError", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 284 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<Void> __when_expr_0 = signal;
															#line 284 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<TriggerOnErrorActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 4386 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<TriggerOnErrorActor*>(this)->actor_wait_state = 1;
															#line 284 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TriggerOnErrorActor, 0, Void >*>(static_cast<TriggerOnErrorActor*>(this)));
															#line 4391 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TriggerOnErrorActorState();
		static_cast<TriggerOnErrorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 289 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TriggerOnErrorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TriggerOnErrorActorState(); static_cast<TriggerOnErrorActor*>(this)->destroy(); return 0; }
															#line 4420 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TriggerOnErrorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~TriggerOnErrorActorState();
		static_cast<TriggerOnErrorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 286 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			what();
															#line 4433 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TriggerOnErrorActor*>(this)->actor_wait_state > 0) static_cast<TriggerOnErrorActor*>(this)->actor_wait_state = 0;
		static_cast<TriggerOnErrorActor*>(this)->ActorCallback< TriggerOnErrorActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TriggerOnErrorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("triggerOnError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TriggerOnErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("triggerOnError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TriggerOnErrorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("triggerOnError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TriggerOnErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("triggerOnError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TriggerOnErrorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("triggerOnError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TriggerOnErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("triggerOnError", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Func what;
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> signal;
															#line 4548 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via triggerOnError()
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Func>
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TriggerOnErrorActor final : public Actor<Void>, public ActorCallback< TriggerOnErrorActor<Func>, 0, Void >, public FastAllocated<TriggerOnErrorActor<Func>>, public TriggerOnErrorActorState<Func, TriggerOnErrorActor<Func>> {
															#line 4555 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TriggerOnErrorActor<Func>>::operator new;
	using FastAllocated<TriggerOnErrorActor<Func>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(7099988088991533568UL, 17292171507549414656UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TriggerOnErrorActor<Func>, 0, Void >;
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TriggerOnErrorActor(Func const& what,Future<Void> const& signal) 
															#line 4572 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   TriggerOnErrorActorState<Func, TriggerOnErrorActor<Func>>(what, signal),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("triggerOnError", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(12265882325865047296UL, 1649008332912012032UL);
		ActorExecutionContextHelper __helper(static_cast<TriggerOnErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("triggerOnError");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("triggerOnError", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TriggerOnErrorActor<Func>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Func>
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> triggerOnError( Func const& what, Future<Void> const& signal ) {
															#line 281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new TriggerOnErrorActor<Func>(what, signal));
															#line 4607 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 291 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// Waits for a future to complete and cannot be cancelled
// Most situations will use the overload below, which does not require a promise
															#line 4614 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via uncancellable()
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class UncancellableActor>
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class UncancellableActorState {
															#line 4621 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	UncancellableActorState(Future<T> const& what,Promise<T> const& result) 
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   result(result)
															#line 4630 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("uncancellable", reinterpret_cast<unsigned long>(this));

	}
	~UncancellableActorState() 
	{
		fdb_probe_actor_destroy("uncancellable", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 297 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = what;
															#line 297 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 4648 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				static_cast<UncancellableActor*>(this)->actor_wait_state = 1;
															#line 297 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< UncancellableActor, 0, T >*>(static_cast<UncancellableActor*>(this)));
															#line 4652 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		delete static_cast<UncancellableActor*>(this);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 300 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			result.sendError(e);
															#line 4687 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& val,int loopDepth) 
	{
															#line 298 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		result.send(val);
															#line 4702 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(T && val,int loopDepth) 
	{
															#line 298 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		result.send(val);
															#line 4711 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1when1(T const& val,int loopDepth) 
	{
		loopDepth = a_body1cont2(val, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && val,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(val), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<UncancellableActor*>(this)->actor_wait_state > 0) static_cast<UncancellableActor*>(this)->actor_wait_state = 0;
		static_cast<UncancellableActor*>(this)->ActorCallback< UncancellableActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< UncancellableActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("uncancellable", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<UncancellableActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("uncancellable", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< UncancellableActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("uncancellable", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<UncancellableActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("uncancellable", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< UncancellableActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("uncancellable", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<UncancellableActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("uncancellable", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont4(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont5(int loopDepth) 
	{
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		delete static_cast<UncancellableActor*>(this);
															#line 4808 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		return 0;

		return loopDepth;
	}
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Promise<T> result;
															#line 4817 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via uncancellable()
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class UncancellableActor final : public Actor<void>, public ActorCallback< UncancellableActor<T>, 0, T >, public FastAllocated<UncancellableActor<T>>, public UncancellableActorState<T, UncancellableActor<T>> {
															#line 4824 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<UncancellableActor<T>>::operator new;
	using FastAllocated<UncancellableActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(12386783156974287104UL, 14988755806397420544UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() {{
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<void>*>(this)->~Actor();
        operator delete(this);
    }}
#pragma clang diagnostic pop
friend struct ActorCallback< UncancellableActor<T>, 0, T >;
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	UncancellableActor(Future<T> const& what,Promise<T> const& result) 
															#line 4841 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<void>(),
		   UncancellableActorState<T, UncancellableActor<T>>(what, result),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("uncancellable", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(16931823273241732096UL, 18269465193061821184UL);
		ActorExecutionContextHelper __helper(static_cast<UncancellableActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("uncancellable");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("uncancellable", reinterpret_cast<unsigned long>(this), -1);

	}
};
} // namespace
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
void uncancellable( Future<T> const& what, Promise<T> const& result ) {
															#line 294 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	new UncancellableActor<T>(what, result);
															#line 4867 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 303 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// Waits for a future to complete and cannot be cancelled
															#line 4873 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via uncancellable()
															#line 305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class UncancellableActor1>
															#line 305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class UncancellableActor1State {
															#line 4880 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	UncancellableActor1State(Future<T> const& what) 
															#line 305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what)
															#line 4887 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("uncancellable", reinterpret_cast<unsigned long>(this));

	}
	~UncancellableActor1State() 
	{
		fdb_probe_actor_destroy("uncancellable", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 307 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			Promise<T> resultPromise;
															#line 308 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			Future<T> result = resultPromise.getFuture();
															#line 310 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			uncancellable(what, resultPromise);
															#line 311 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = result;
															#line 311 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<UncancellableActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 4910 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<UncancellableActor1*>(this)->actor_wait_state = 1;
															#line 311 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< UncancellableActor1, 0, T >*>(static_cast<UncancellableActor1*>(this)));
															#line 4915 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~UncancellableActor1State();
		static_cast<UncancellableActor1*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T const& val,int loopDepth) 
	{
															#line 313 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<UncancellableActor1*>(this)->SAV<T>::futures) { (void)(val); this->~UncancellableActor1State(); static_cast<UncancellableActor1*>(this)->destroy(); return 0; }
															#line 4938 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<UncancellableActor1*>(this)->SAV< T >::value()) T(val);
		this->~UncancellableActor1State();
		static_cast<UncancellableActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(T && val,int loopDepth) 
	{
															#line 313 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<UncancellableActor1*>(this)->SAV<T>::futures) { (void)(val); this->~UncancellableActor1State(); static_cast<UncancellableActor1*>(this)->destroy(); return 0; }
															#line 4950 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<UncancellableActor1*>(this)->SAV< T >::value()) T(val);
		this->~UncancellableActor1State();
		static_cast<UncancellableActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& val,int loopDepth) 
	{
		loopDepth = a_body1cont1(val, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && val,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(val), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<UncancellableActor1*>(this)->actor_wait_state > 0) static_cast<UncancellableActor1*>(this)->actor_wait_state = 0;
		static_cast<UncancellableActor1*>(this)->ActorCallback< UncancellableActor1, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< UncancellableActor1, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("uncancellable", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<UncancellableActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("uncancellable", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< UncancellableActor1, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("uncancellable", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<UncancellableActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("uncancellable", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< UncancellableActor1, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("uncancellable", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<UncancellableActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("uncancellable", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 5035 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via uncancellable()
															#line 305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class UncancellableActor1 final : public Actor<T>, public ActorCallback< UncancellableActor1<T>, 0, T >, public FastAllocated<UncancellableActor1<T>>, public UncancellableActor1State<T, UncancellableActor1<T>> {
															#line 5042 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<UncancellableActor1<T>>::operator new;
	using FastAllocated<UncancellableActor1<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(12386783156974287104UL, 14988755806397420544UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< UncancellableActor1<T>, 0, T >;
															#line 305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	UncancellableActor1(Future<T> const& what) 
															#line 5059 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   UncancellableActor1State<T, UncancellableActor1<T>>(what),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("uncancellable", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(13985797382347265536UL, 8827939613289801216UL);
		ActorExecutionContextHelper __helper(static_cast<UncancellableActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("uncancellable");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("uncancellable", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< UncancellableActor1<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
Future<T> uncancellable( Future<T> const& what ) {
															#line 305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new UncancellableActor1<T>(what));
															#line 5094 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 315 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// Holds onto an object until a future either completes or is cancelled
// Used to prevent the object from being reclaimed
//
// NOTE: the order of the arguments is important. The arguments will be destructed in
// reverse order, and we need the object to be destructed last.
															#line 5104 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via holdWhile()
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class X, class HoldWhileActor>
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class HoldWhileActorState {
															#line 5111 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	HoldWhileActorState(X const& object,Future<T> const& what) 
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : object(object),
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   what(what)
															#line 5120 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("holdWhile", reinterpret_cast<unsigned long>(this));

	}
	~HoldWhileActorState() 
	{
		fdb_probe_actor_destroy("holdWhile", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 323 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = what;
															#line 323 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<HoldWhileActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 5137 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<HoldWhileActor*>(this)->actor_wait_state = 1;
															#line 323 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< HoldWhileActor, 0, T >*>(static_cast<HoldWhileActor*>(this)));
															#line 5142 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~HoldWhileActorState();
		static_cast<HoldWhileActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T const& val,int loopDepth) 
	{
															#line 324 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<HoldWhileActor*>(this)->SAV<T>::futures) { (void)(val); this->~HoldWhileActorState(); static_cast<HoldWhileActor*>(this)->destroy(); return 0; }
															#line 5165 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<HoldWhileActor*>(this)->SAV< T >::value()) T(val);
		this->~HoldWhileActorState();
		static_cast<HoldWhileActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(T && val,int loopDepth) 
	{
															#line 324 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<HoldWhileActor*>(this)->SAV<T>::futures) { (void)(val); this->~HoldWhileActorState(); static_cast<HoldWhileActor*>(this)->destroy(); return 0; }
															#line 5177 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<HoldWhileActor*>(this)->SAV< T >::value()) T(val);
		this->~HoldWhileActorState();
		static_cast<HoldWhileActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& val,int loopDepth) 
	{
		loopDepth = a_body1cont1(val, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && val,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(val), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<HoldWhileActor*>(this)->actor_wait_state > 0) static_cast<HoldWhileActor*>(this)->actor_wait_state = 0;
		static_cast<HoldWhileActor*>(this)->ActorCallback< HoldWhileActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< HoldWhileActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("holdWhile", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<HoldWhileActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("holdWhile", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< HoldWhileActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("holdWhile", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<HoldWhileActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("holdWhile", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< HoldWhileActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("holdWhile", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<HoldWhileActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("holdWhile", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	X object;
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 5264 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via holdWhile()
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class X>
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class HoldWhileActor final : public Actor<T>, public ActorCallback< HoldWhileActor<T, X>, 0, T >, public FastAllocated<HoldWhileActor<T, X>>, public HoldWhileActorState<T, X, HoldWhileActor<T, X>> {
															#line 5271 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<HoldWhileActor<T, X>>::operator new;
	using FastAllocated<HoldWhileActor<T, X>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(15324828224889620736UL, 5883947105624935936UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< HoldWhileActor<T, X>, 0, T >;
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	HoldWhileActor(X const& object,Future<T> const& what) 
															#line 5288 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   HoldWhileActorState<T, X, HoldWhileActor<T, X>>(object, what),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("holdWhile", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(4521267774877520128UL, 244137019803584000UL);
		ActorExecutionContextHelper __helper(static_cast<HoldWhileActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("holdWhile");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("holdWhile", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< HoldWhileActor<T, X>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class X>
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> holdWhile( X const& object, Future<T> const& what ) {
															#line 321 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new HoldWhileActor<T, X>(object, what));
															#line 5323 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 326 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 5328 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via holdWhileVoid()
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class X, class HoldWhileVoidActor>
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class HoldWhileVoidActorState {
															#line 5335 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	HoldWhileVoidActorState(X const& object,Future<T> const& what) 
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : object(object),
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   what(what)
															#line 5344 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("holdWhileVoid", reinterpret_cast<unsigned long>(this));

	}
	~HoldWhileVoidActorState() 
	{
		fdb_probe_actor_destroy("holdWhileVoid", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 329 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = what;
															#line 329 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<HoldWhileVoidActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 5361 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<HoldWhileVoidActor*>(this)->actor_wait_state = 1;
															#line 329 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< HoldWhileVoidActor, 0, T >*>(static_cast<HoldWhileVoidActor*>(this)));
															#line 5366 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~HoldWhileVoidActorState();
		static_cast<HoldWhileVoidActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T const& val,int loopDepth) 
	{
															#line 330 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<HoldWhileVoidActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~HoldWhileVoidActorState(); static_cast<HoldWhileVoidActor*>(this)->destroy(); return 0; }
															#line 5389 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<HoldWhileVoidActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~HoldWhileVoidActorState();
		static_cast<HoldWhileVoidActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(T && val,int loopDepth) 
	{
															#line 330 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<HoldWhileVoidActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~HoldWhileVoidActorState(); static_cast<HoldWhileVoidActor*>(this)->destroy(); return 0; }
															#line 5401 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<HoldWhileVoidActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~HoldWhileVoidActorState();
		static_cast<HoldWhileVoidActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& val,int loopDepth) 
	{
		loopDepth = a_body1cont1(val, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && val,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(val), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<HoldWhileVoidActor*>(this)->actor_wait_state > 0) static_cast<HoldWhileVoidActor*>(this)->actor_wait_state = 0;
		static_cast<HoldWhileVoidActor*>(this)->ActorCallback< HoldWhileVoidActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< HoldWhileVoidActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("holdWhileVoid", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<HoldWhileVoidActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("holdWhileVoid", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< HoldWhileVoidActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("holdWhileVoid", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<HoldWhileVoidActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("holdWhileVoid", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< HoldWhileVoidActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("holdWhileVoid", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<HoldWhileVoidActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("holdWhileVoid", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	X object;
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 5488 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via holdWhileVoid()
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class X>
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class HoldWhileVoidActor final : public Actor<Void>, public ActorCallback< HoldWhileVoidActor<T, X>, 0, T >, public FastAllocated<HoldWhileVoidActor<T, X>>, public HoldWhileVoidActorState<T, X, HoldWhileVoidActor<T, X>> {
															#line 5495 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<HoldWhileVoidActor<T, X>>::operator new;
	using FastAllocated<HoldWhileVoidActor<T, X>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(12449855084755088128UL, 2134741393069402368UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< HoldWhileVoidActor<T, X>, 0, T >;
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	HoldWhileVoidActor(X const& object,Future<T> const& what) 
															#line 5512 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   HoldWhileVoidActorState<T, X, HoldWhileVoidActor<T, X>>(object, what),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("holdWhileVoid", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(7538540040531603712UL, 16752633301447762176UL);
		ActorExecutionContextHelper __helper(static_cast<HoldWhileVoidActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("holdWhileVoid");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("holdWhileVoid", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< HoldWhileVoidActor<T, X>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class X>
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> holdWhileVoid( X const& object, Future<T> const& what ) {
															#line 327 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new HoldWhileVoidActor<T, X>(object, what));
															#line 5547 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 332 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// Assign the future value of what to out
template <class T, class X>
Future<Void> store(X& out, Future<T> what) {
	return map(what, [&out](T const& v) {
		out = v;
		return Void();
	});
}

#if false
// NOTE: Think twice whether create a new struct for a complex return type is better before using tuple.
// If we just use the return type once, is it worth to create a new struct?
// And enable the unit test in genericactors.actor.cpp
template <class A, class... Bs>
Future<Void> storeTuple(Future<std::tuple<A, Bs...>> what, A& a, Bs&... b) {
	return map(what, [&](std::tuple<A, Bs...> const& v) {
		std::tie(a, b...) = v;
		return Void();
	});
}
#endif

template <class T>
Future<Void> storeOrThrow(T& out, Future<Optional<T>> what, Error e = key_not_found()) {
	return map(what, [&out, e](Optional<T> const& o) {
		if (!o.present())
			throw e;
		out = o.get();
		return Void();
	});
}

// Waits for a future to be ready, and then applies an asynchronous function to it.
															#line 5585 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via mapAsync()
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F, class MapAsyncActor>
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class MapAsyncActorState {
															#line 5592 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	MapAsyncActorState(Future<T> const& what,F const& actorFunc) 
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   actorFunc(actorFunc)
															#line 5601 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("mapAsync", reinterpret_cast<unsigned long>(this));

	}
	~MapAsyncActorState() 
	{
		fdb_probe_actor_destroy("mapAsync", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 368 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = what;
															#line 368 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<MapAsyncActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 5618 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<MapAsyncActor*>(this)->actor_wait_state = 1;
															#line 368 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< MapAsyncActor, 0, T >*>(static_cast<MapAsyncActor*>(this)));
															#line 5623 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~MapAsyncActorState();
		static_cast<MapAsyncActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T const& val,int loopDepth) 
	{
															#line 369 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<decltype(std::declval<F>()(std::declval<T>()).getValue())> __when_expr_1 = actorFunc(val);
															#line 369 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<MapAsyncActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 5648 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<MapAsyncActor*>(this)->actor_wait_state = 2;
															#line 369 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< MapAsyncActor, 1, decltype(std::declval<F>()(std::declval<T>()).getValue()) >*>(static_cast<MapAsyncActor*>(this)));
															#line 5653 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T && val,int loopDepth) 
	{
															#line 369 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<decltype(std::declval<F>()(std::declval<T>()).getValue())> __when_expr_1 = actorFunc(val);
															#line 369 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<MapAsyncActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 5664 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<MapAsyncActor*>(this)->actor_wait_state = 2;
															#line 369 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< MapAsyncActor, 1, decltype(std::declval<F>()(std::declval<T>()).getValue()) >*>(static_cast<MapAsyncActor*>(this)));
															#line 5669 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(T const& val,int loopDepth) 
	{
		loopDepth = a_body1cont1(val, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && val,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(val), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<MapAsyncActor*>(this)->actor_wait_state > 0) static_cast<MapAsyncActor*>(this)->actor_wait_state = 0;
		static_cast<MapAsyncActor*>(this)->ActorCallback< MapAsyncActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< MapAsyncActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< MapAsyncActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< MapAsyncActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(decltype(std::declval<F>()(std::declval<T>()).getValue()) const& ret,int loopDepth) 
	{
															#line 370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<MapAsyncActor*>(this)->SAV<decltype(std::declval<F>()(std::declval<T>()).getValue())>::futures) { (void)(ret); this->~MapAsyncActorState(); static_cast<MapAsyncActor*>(this)->destroy(); return 0; }
															#line 5753 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<MapAsyncActor*>(this)->SAV< decltype(std::declval<F>()(std::declval<T>()).getValue()) >::value()) decltype(std::declval<F>()(std::declval<T>()).getValue())(ret);
		this->~MapAsyncActorState();
		static_cast<MapAsyncActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(decltype(std::declval<F>()(std::declval<T>()).getValue()) && ret,int loopDepth) 
	{
															#line 370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<MapAsyncActor*>(this)->SAV<decltype(std::declval<F>()(std::declval<T>()).getValue())>::futures) { (void)(ret); this->~MapAsyncActorState(); static_cast<MapAsyncActor*>(this)->destroy(); return 0; }
															#line 5765 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<MapAsyncActor*>(this)->SAV< decltype(std::declval<F>()(std::declval<T>()).getValue()) >::value()) decltype(std::declval<F>()(std::declval<T>()).getValue())(ret);
		this->~MapAsyncActorState();
		static_cast<MapAsyncActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(decltype(std::declval<F>()(std::declval<T>()).getValue()) const& ret,int loopDepth) 
	{
		loopDepth = a_body1cont2(ret, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(decltype(std::declval<F>()(std::declval<T>()).getValue()) && ret,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(ret), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<MapAsyncActor*>(this)->actor_wait_state > 0) static_cast<MapAsyncActor*>(this)->actor_wait_state = 0;
		static_cast<MapAsyncActor*>(this)->ActorCallback< MapAsyncActor, 1, decltype(std::declval<F>()(std::declval<T>()).getValue()) >::remove();

	}
	void a_callback_fire(ActorCallback< MapAsyncActor, 1, decltype(std::declval<F>()(std::declval<T>()).getValue()) >*,decltype(std::declval<F>()(std::declval<T>()).getValue()) const& value) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< MapAsyncActor, 1, decltype(std::declval<F>()(std::declval<T>()).getValue()) >*,decltype(std::declval<F>()(std::declval<T>()).getValue()) && value) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< MapAsyncActor, 1, decltype(std::declval<F>()(std::declval<T>()).getValue()) >*,Error err) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	F actorFunc;
															#line 5852 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via mapAsync()
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F>
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class MapAsyncActor final : public Actor<decltype(std::declval<F>()(std::declval<T>()).getValue())>, public ActorCallback< MapAsyncActor<T, F>, 0, T >, public ActorCallback< MapAsyncActor<T, F>, 1, decltype(std::declval<F>()(std::declval<T>()).getValue()) >, public FastAllocated<MapAsyncActor<T, F>>, public MapAsyncActorState<T, F, MapAsyncActor<T, F>> {
															#line 5859 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<MapAsyncActor<T, F>>::operator new;
	using FastAllocated<MapAsyncActor<T, F>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(14641293603034648320UL, 7124637501640007680UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<decltype(std::declval<F>()(std::declval<T>()).getValue())>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< MapAsyncActor<T, F>, 0, T >;
friend struct ActorCallback< MapAsyncActor<T, F>, 1, decltype(std::declval<F>()(std::declval<T>()).getValue()) >;
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	MapAsyncActor(Future<T> const& what,F const& actorFunc) 
															#line 5877 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<decltype(std::declval<F>()(std::declval<T>()).getValue())>(),
		   MapAsyncActorState<T, F, MapAsyncActor<T, F>>(what, actorFunc),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(1996485458833146880UL, 14068918914659627520UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("mapAsync");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< MapAsyncActor<T, F>, 0, T >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< MapAsyncActor<T, F>, 1, decltype(std::declval<F>()(std::declval<T>()).getValue()) >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F>
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<decltype(std::declval<F>()(std::declval<T>()).getValue())> mapAsync( Future<T> const& what, F const& actorFunc ) {
															#line 366 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<decltype(std::declval<F>()(std::declval<T>()).getValue())>(new MapAsyncActor<T, F>(what, actorFunc));
															#line 5913 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 372 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// maps a vector of futures with an asynchronous function
template <class T, class F>
auto mapAsync(std::vector<Future<T>> const& what, F const& actorFunc) {
	std::vector<std::invoke_result_t<F, T>> ret;
	ret.reserve(what.size());
	for (const auto& f : what)
		ret.push_back(mapAsync(f, actorFunc));
	return ret;
}

// maps a stream with an asynchronous function
															#line 5929 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via mapAsync()
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F, class U, class MapAsyncActor1>
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class MapAsyncActor1State {
															#line 5936 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	MapAsyncActor1State(FutureStream<T> const& input,F const& actorFunc,PromiseStream<U> const& output) 
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : input(input),
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   actorFunc(actorFunc),
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   output(output),
															#line 386 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   futures()
															#line 5949 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("mapAsync", reinterpret_cast<unsigned long>(this));

	}
	~MapAsyncActor1State() 
	{
		fdb_probe_actor_destroy("mapAsync", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 388 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 5964 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~MapAsyncActor1State();
		static_cast<MapAsyncActor1*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 409 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		;
															#line 5987 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 391 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			FutureStream<T> __when_expr_0 = input;
															#line 390 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<MapAsyncActor1*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 6006 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.pop(), loopDepth); };
															#line 394 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<U> __when_expr_1 = futures.size() == 0 ? Never() : futures.front();
															#line 6010 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
			static_cast<MapAsyncActor1*>(this)->actor_wait_state = 1;
															#line 391 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< MapAsyncActor1, 0, T >*>(static_cast<MapAsyncActor1*>(this)));
															#line 394 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< MapAsyncActor1, 1, U >*>(static_cast<MapAsyncActor1*>(this)));
															#line 6017 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 400 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == error_code_end_of_stream)
															#line 6052 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
				return a_body1break1(loopDepth==0?0:loopDepth-1); // break
			}
			else
			{
															#line 403 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				output.sendError(e);
															#line 404 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 6062 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T const& nextInput,int loopDepth) 
	{
															#line 392 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		futures.push_back(actorFunc(nextInput));
															#line 6083 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T && nextInput,int loopDepth) 
	{
															#line 392 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		futures.push_back(actorFunc(nextInput));
															#line 6092 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(U const& nextOutput,int loopDepth) 
	{
															#line 395 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(nextOutput);
															#line 396 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		futures.pop_front();
															#line 6103 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(U && nextOutput,int loopDepth) 
	{
															#line 395 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(nextOutput);
															#line 396 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		futures.pop_front();
															#line 6114 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<MapAsyncActor1*>(this)->actor_wait_state > 0) static_cast<MapAsyncActor1*>(this)->actor_wait_state = 0;
		static_cast<MapAsyncActor1*>(this)->ActorSingleCallback< MapAsyncActor1, 0, T >::remove();
		static_cast<MapAsyncActor1*>(this)->ActorCallback< MapAsyncActor1, 1, U >::remove();

	}
	void a_callback_fire(ActorSingleCallback< MapAsyncActor1, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< MapAsyncActor1, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< MapAsyncActor1, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< MapAsyncActor1, 1, U >*,U const& value) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< MapAsyncActor1, 1, U >*,U && value) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< MapAsyncActor1, 1, U >*,Error err) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont2(int loopDepth) 
	{
															#line 415 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.sendError(end_of_stream());
															#line 417 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<MapAsyncActor1*>(this)->SAV<Void>::futures) { (void)(Void()); this->~MapAsyncActor1State(); static_cast<MapAsyncActor1*>(this)->destroy(); return 0; }
															#line 6259 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<MapAsyncActor1*>(this)->SAV< Void >::value()) Void(Void());
		this->~MapAsyncActor1State();
		static_cast<MapAsyncActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 409 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!(futures.size()))
															#line 6278 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
			return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 410 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<U> __when_expr_2 = futures.front();
															#line 410 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<MapAsyncActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 6286 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1when1(__when_expr_2.get(), loopDepth); };
		static_cast<MapAsyncActor1*>(this)->actor_wait_state = 2;
															#line 410 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< MapAsyncActor1, 2, U >*>(static_cast<MapAsyncActor1*>(this)));
															#line 6291 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1break1(int loopDepth) 
	{
		try {
			return a_body1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(U const& nextOutput,int loopDepth) 
	{
															#line 411 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(nextOutput);
															#line 412 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		futures.pop_front();
															#line 6315 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(U && nextOutput,int loopDepth) 
	{
															#line 411 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(nextOutput);
															#line 412 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		futures.pop_front();
															#line 6326 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(U const& nextOutput,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(nextOutput, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(U && nextOutput,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(std::move(nextOutput), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<MapAsyncActor1*>(this)->actor_wait_state > 0) static_cast<MapAsyncActor1*>(this)->actor_wait_state = 0;
		static_cast<MapAsyncActor1*>(this)->ActorCallback< MapAsyncActor1, 2, U >::remove();

	}
	void a_callback_fire(ActorCallback< MapAsyncActor1, 2, U >*,U const& value) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< MapAsyncActor1, 2, U >*,U && value) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< MapAsyncActor1, 2, U >*,Error err) 
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FutureStream<T> input;
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	F actorFunc;
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<U> output;
															#line 386 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Deque<Future<U>> futures;
															#line 6414 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via mapAsync()
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F, class U>
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class MapAsyncActor1 final : public Actor<Void>, public ActorSingleCallback< MapAsyncActor1<T, F, U>, 0, T >, public ActorCallback< MapAsyncActor1<T, F, U>, 1, U >, public ActorCallback< MapAsyncActor1<T, F, U>, 2, U >, public FastAllocated<MapAsyncActor1<T, F, U>>, public MapAsyncActor1State<T, F, U, MapAsyncActor1<T, F, U>> {
															#line 6421 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<MapAsyncActor1<T, F, U>>::operator new;
	using FastAllocated<MapAsyncActor1<T, F, U>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(14641293603034648320UL, 7124637501640007680UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< MapAsyncActor1<T, F, U>, 0, T >;
friend struct ActorCallback< MapAsyncActor1<T, F, U>, 1, U >;
friend struct ActorCallback< MapAsyncActor1<T, F, U>, 2, U >;
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	MapAsyncActor1(FutureStream<T> const& input,F const& actorFunc,PromiseStream<U> const& output) 
															#line 6440 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   MapAsyncActor1State<T, F, U, MapAsyncActor1<T, F, U>>(input, actorFunc, output),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("mapAsync", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(11521843967510462208UL, 16241305626006140672UL);
		ActorExecutionContextHelper __helper(static_cast<MapAsyncActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("mapAsync");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("mapAsync", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< MapAsyncActor1<T, F, U>, 0, T >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< MapAsyncActor1<T, F, U>, 2, U >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F, class U>
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> mapAsync( FutureStream<T> const& input, F const& actorFunc, PromiseStream<U> const& output ) {
															#line 384 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new MapAsyncActor1<T, F, U>(input, actorFunc, output));
															#line 6476 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 419 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// Waits for a future to be ready, and then applies a function to it.
															#line 6482 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via map()
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F, class MapActor>
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class MapActorState {
															#line 6489 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	MapActorState(Future<T> const& what,F const& func) 
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   func(func)
															#line 6498 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("map", reinterpret_cast<unsigned long>(this));

	}
	~MapActorState() 
	{
		fdb_probe_actor_destroy("map", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 423 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = what;
															#line 423 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<MapActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 6515 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<MapActor*>(this)->actor_wait_state = 1;
															#line 423 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< MapActor, 0, T >*>(static_cast<MapActor*>(this)));
															#line 6520 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~MapActorState();
		static_cast<MapActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T const& val,int loopDepth) 
	{
															#line 424 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<MapActor*>(this)->SAV<std::invoke_result_t<F, T>>::futures) { (void)(func(val)); this->~MapActorState(); static_cast<MapActor*>(this)->destroy(); return 0; }
															#line 6543 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<MapActor*>(this)->SAV< std::invoke_result_t<F, T> >::value()) std::invoke_result_t<F, T>(func(val));
		this->~MapActorState();
		static_cast<MapActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(T && val,int loopDepth) 
	{
															#line 424 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<MapActor*>(this)->SAV<std::invoke_result_t<F, T>>::futures) { (void)(func(val)); this->~MapActorState(); static_cast<MapActor*>(this)->destroy(); return 0; }
															#line 6555 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<MapActor*>(this)->SAV< std::invoke_result_t<F, T> >::value()) std::invoke_result_t<F, T>(func(val));
		this->~MapActorState();
		static_cast<MapActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& val,int loopDepth) 
	{
		loopDepth = a_body1cont1(val, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && val,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(val), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<MapActor*>(this)->actor_wait_state > 0) static_cast<MapActor*>(this)->actor_wait_state = 0;
		static_cast<MapActor*>(this)->ActorCallback< MapActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< MapActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("map", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("map", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< MapActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("map", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("map", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< MapActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("map", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<MapActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("map", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	F func;
															#line 6642 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via map()
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F>
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class MapActor final : public Actor<std::invoke_result_t<F, T>>, public ActorCallback< MapActor<T, F>, 0, T >, public FastAllocated<MapActor<T, F>>, public MapActorState<T, F, MapActor<T, F>> {
															#line 6649 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<MapActor<T, F>>::operator new;
	using FastAllocated<MapActor<T, F>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(18044388308570910720UL, 17543060528314782464UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<std::invoke_result_t<F, T>>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< MapActor<T, F>, 0, T >;
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	MapActor(Future<T> const& what,F const& func) 
															#line 6666 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<std::invoke_result_t<F, T>>(),
		   MapActorState<T, F, MapActor<T, F>>(what, func),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("map", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(12390511040070023168UL, 10073700351581680896UL);
		ActorExecutionContextHelper __helper(static_cast<MapActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("map");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("map", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< MapActor<T, F>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F>
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<std::invoke_result_t<F, T>> map( Future<T> const& what, F const& func ) {
															#line 421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<std::invoke_result_t<F, T>>(new MapActor<T, F>(what, func));
															#line 6701 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 426 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// maps a vector of futures
template <class T, class F>
auto map(std::vector<Future<T>> const& what, F const& func) {
	std::vector<Future<std::invoke_result_t<F, T>>> ret;
	ret.reserve(what.size());
	for (const auto& f : what)
		ret.push_back(map(f, func));
	return ret;
}

// maps a stream
															#line 6717 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via map()
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F, class MapActor1>
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class MapActor1State {
															#line 6724 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	MapActor1State(FutureStream<T> const& input,F const& func,PromiseStream<std::invoke_result_t<F, T>> const& output) 
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : input(input),
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   func(func),
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   output(output)
															#line 6735 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("map", reinterpret_cast<unsigned long>(this));

	}
	~MapActor1State() 
	{
		fdb_probe_actor_destroy("map", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 440 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 6750 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~MapActor1State();
		static_cast<MapActor1*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 452 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.sendError(end_of_stream());
															#line 454 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<MapActor1*>(this)->SAV<Void>::futures) { (void)(Void()); this->~MapActor1State(); static_cast<MapActor1*>(this)->destroy(); return 0; }
															#line 6775 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<MapActor1*>(this)->SAV< Void >::value()) Void(Void());
		this->~MapActor1State();
		static_cast<MapActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 442 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			FutureStream<T> __when_expr_0 = input;
															#line 442 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<MapActor1*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 6797 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.pop(), loopDepth); };
			static_cast<MapActor1*>(this)->actor_wait_state = 1;
															#line 442 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< MapActor1, 0, T >*>(static_cast<MapActor1*>(this)));
															#line 6802 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 445 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == error_code_end_of_stream)
															#line 6837 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
				return a_body1break1(loopDepth==0?0:loopDepth-1); // break
			}
			else
			{
															#line 448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 6845 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(T const& nextInput,int loopDepth) 
	{
															#line 443 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(func(nextInput));
															#line 6860 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2(T && nextInput,int loopDepth) 
	{
															#line 443 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(func(nextInput));
															#line 6869 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T const& nextInput,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(nextInput, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T && nextInput,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(nextInput), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<MapActor1*>(this)->actor_wait_state > 0) static_cast<MapActor1*>(this)->actor_wait_state = 0;
		static_cast<MapActor1*>(this)->ActorSingleCallback< MapActor1, 0, T >::remove();

	}
	void a_callback_fire(ActorSingleCallback< MapActor1, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("map", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("map", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< MapActor1, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("map", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MapActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("map", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< MapActor1, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("map", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<MapActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("map", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont4(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FutureStream<T> input;
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	F func;
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<std::invoke_result_t<F, T>> output;
															#line 6968 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via map()
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F>
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class MapActor1 final : public Actor<Void>, public ActorSingleCallback< MapActor1<T, F>, 0, T >, public FastAllocated<MapActor1<T, F>>, public MapActor1State<T, F, MapActor1<T, F>> {
															#line 6975 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<MapActor1<T, F>>::operator new;
	using FastAllocated<MapActor1<T, F>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(18044388308570910720UL, 17543060528314782464UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< MapActor1<T, F>, 0, T >;
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	MapActor1(FutureStream<T> const& input,F const& func,PromiseStream<std::invoke_result_t<F, T>> const& output) 
															#line 6992 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   MapActor1State<T, F, MapActor1<T, F>>(input, func, output),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("map", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(13260455609048177152UL, 7454665086589192704UL);
		ActorExecutionContextHelper __helper(static_cast<MapActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("map");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("map", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< MapActor1<T, F>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F>
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> map( FutureStream<T> const& input, F const& func, PromiseStream<std::invoke_result_t<F, T>> const& output ) {
															#line 438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new MapActor1<T, F>(input, func, output));
															#line 7027 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 456 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// X + Y will wait for X, then wait for and return the result of Y
															#line 7033 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via operatorPlus()
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class A, class B, class OperatorPlusActor>
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class OperatorPlusActorState {
															#line 7040 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	OperatorPlusActorState(Future<A> const& a,Future<B> const& b) 
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : a(a),
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   b(b)
															#line 7049 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("operatorPlus", reinterpret_cast<unsigned long>(this));

	}
	~OperatorPlusActorState() 
	{
		fdb_probe_actor_destroy("operatorPlus", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 460 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<A> __when_expr_0 = a;
															#line 460 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<OperatorPlusActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7066 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<OperatorPlusActor*>(this)->actor_wait_state = 1;
															#line 460 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< OperatorPlusActor, 0, A >*>(static_cast<OperatorPlusActor*>(this)));
															#line 7071 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~OperatorPlusActorState();
		static_cast<OperatorPlusActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(A const& resultA,int loopDepth) 
	{
															#line 461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		(void)resultA;
															#line 462 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<B> __when_expr_1 = b;
															#line 462 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<OperatorPlusActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7098 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<OperatorPlusActor*>(this)->actor_wait_state = 2;
															#line 462 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< OperatorPlusActor, 1, B >*>(static_cast<OperatorPlusActor*>(this)));
															#line 7103 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(A && resultA,int loopDepth) 
	{
															#line 461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		(void)resultA;
															#line 462 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<B> __when_expr_1 = b;
															#line 462 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<OperatorPlusActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7116 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<OperatorPlusActor*>(this)->actor_wait_state = 2;
															#line 462 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< OperatorPlusActor, 1, B >*>(static_cast<OperatorPlusActor*>(this)));
															#line 7121 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(A const& resultA,int loopDepth) 
	{
		loopDepth = a_body1cont1(resultA, loopDepth);

		return loopDepth;
	}
	int a_body1when1(A && resultA,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(resultA), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<OperatorPlusActor*>(this)->actor_wait_state > 0) static_cast<OperatorPlusActor*>(this)->actor_wait_state = 0;
		static_cast<OperatorPlusActor*>(this)->ActorCallback< OperatorPlusActor, 0, A >::remove();

	}
	void a_callback_fire(ActorCallback< OperatorPlusActor, 0, A >*,A const& value) 
	{
		fdb_probe_actor_enter("operatorPlus", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<OperatorPlusActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("operatorPlus", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< OperatorPlusActor, 0, A >*,A && value) 
	{
		fdb_probe_actor_enter("operatorPlus", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<OperatorPlusActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("operatorPlus", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< OperatorPlusActor, 0, A >*,Error err) 
	{
		fdb_probe_actor_enter("operatorPlus", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<OperatorPlusActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("operatorPlus", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(B const& resultB,int loopDepth) 
	{
															#line 463 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<OperatorPlusActor*>(this)->SAV<B>::futures) { (void)(resultB); this->~OperatorPlusActorState(); static_cast<OperatorPlusActor*>(this)->destroy(); return 0; }
															#line 7205 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<OperatorPlusActor*>(this)->SAV< B >::value()) B(resultB);
		this->~OperatorPlusActorState();
		static_cast<OperatorPlusActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(B && resultB,int loopDepth) 
	{
															#line 463 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<OperatorPlusActor*>(this)->SAV<B>::futures) { (void)(resultB); this->~OperatorPlusActorState(); static_cast<OperatorPlusActor*>(this)->destroy(); return 0; }
															#line 7217 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<OperatorPlusActor*>(this)->SAV< B >::value()) B(resultB);
		this->~OperatorPlusActorState();
		static_cast<OperatorPlusActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(B const& resultB,int loopDepth) 
	{
		loopDepth = a_body1cont2(resultB, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(B && resultB,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(resultB), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<OperatorPlusActor*>(this)->actor_wait_state > 0) static_cast<OperatorPlusActor*>(this)->actor_wait_state = 0;
		static_cast<OperatorPlusActor*>(this)->ActorCallback< OperatorPlusActor, 1, B >::remove();

	}
	void a_callback_fire(ActorCallback< OperatorPlusActor, 1, B >*,B const& value) 
	{
		fdb_probe_actor_enter("operatorPlus", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<OperatorPlusActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("operatorPlus", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< OperatorPlusActor, 1, B >*,B && value) 
	{
		fdb_probe_actor_enter("operatorPlus", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<OperatorPlusActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("operatorPlus", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< OperatorPlusActor, 1, B >*,Error err) 
	{
		fdb_probe_actor_enter("operatorPlus", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<OperatorPlusActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("operatorPlus", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<A> a;
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<B> b;
															#line 7304 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via operatorPlus()
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class A, class B>
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class OperatorPlusActor final : public Actor<B>, public ActorCallback< OperatorPlusActor<A, B>, 0, A >, public ActorCallback< OperatorPlusActor<A, B>, 1, B >, public FastAllocated<OperatorPlusActor<A, B>>, public OperatorPlusActorState<A, B, OperatorPlusActor<A, B>> {
															#line 7311 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<OperatorPlusActor<A, B>>::operator new;
	using FastAllocated<OperatorPlusActor<A, B>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(18415800460694435072UL, 1620128525876647680UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<B>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< OperatorPlusActor<A, B>, 0, A >;
friend struct ActorCallback< OperatorPlusActor<A, B>, 1, B >;
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	OperatorPlusActor(Future<A> const& a,Future<B> const& b) 
															#line 7329 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<B>(),
		   OperatorPlusActorState<A, B, OperatorPlusActor<A, B>>(a, b),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("operatorPlus", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(7932176911111902464UL, 12071714722581229056UL);
		ActorExecutionContextHelper __helper(static_cast<OperatorPlusActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("operatorPlus");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("operatorPlus", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< OperatorPlusActor<A, B>, 0, A >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< OperatorPlusActor<A, B>, 1, B >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class A, class B>
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<B> operatorPlus( Future<A> const& a, Future<B> const& b ) {
															#line 458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<B>(new OperatorPlusActor<A, B>(a, b));
															#line 7365 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 465 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

template <class A, class B>
Future<B> operator+(Future<A> a, Future<B> b) {
	return operatorPlus(a, b);
}

// Returns if the future returns true, otherwise waits forever.
															#line 7376 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
[[nodiscard]] Future<Void> returnIfTrue( Future<bool> const& f );

#line 473 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// Returns if the future, when waited on and then evaluated with the predicate, returns true, otherwise waits forever
template <class T, class F>
Future<Void> returnIfTrue(Future<T> what, F pred) {
	return returnIfTrue(map(what, pred));
}

// filters a stream
															#line 7388 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via filter()
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F, class FilterActor>
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class FilterActorState {
															#line 7395 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FilterActorState(FutureStream<T> const& input,F const& pred,PromiseStream<T> const& output) 
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : input(input),
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   pred(pred),
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   output(output)
															#line 7406 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("filter", reinterpret_cast<unsigned long>(this));

	}
	~FilterActorState() 
	{
		fdb_probe_actor_destroy("filter", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 483 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 7421 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~FilterActorState();
		static_cast<FilterActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 496 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.sendError(end_of_stream());
															#line 498 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<FilterActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~FilterActorState(); static_cast<FilterActor*>(this)->destroy(); return 0; }
															#line 7446 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<FilterActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~FilterActorState();
		static_cast<FilterActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 485 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			FutureStream<T> __when_expr_0 = input;
															#line 485 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<FilterActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 7468 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.pop(), loopDepth); };
			static_cast<FilterActor*>(this)->actor_wait_state = 1;
															#line 485 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< FilterActor, 0, T >*>(static_cast<FilterActor*>(this)));
															#line 7473 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 489 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == error_code_end_of_stream)
															#line 7508 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
				return a_body1break1(loopDepth==0?0:loopDepth-1); // break
			}
			else
			{
															#line 492 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 7516 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(T const& nextInput,int loopDepth) 
	{
															#line 486 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (pred(nextInput))
															#line 7531 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 487 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output.send(nextInput);
															#line 7535 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2(T && nextInput,int loopDepth) 
	{
															#line 486 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (pred(nextInput))
															#line 7545 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 487 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output.send(nextInput);
															#line 7549 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T const& nextInput,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(nextInput, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T && nextInput,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(nextInput), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<FilterActor*>(this)->actor_wait_state > 0) static_cast<FilterActor*>(this)->actor_wait_state = 0;
		static_cast<FilterActor*>(this)->ActorSingleCallback< FilterActor, 0, T >::remove();

	}
	void a_callback_fire(ActorSingleCallback< FilterActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("filter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<FilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("filter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< FilterActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("filter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<FilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("filter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< FilterActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("filter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<FilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("filter", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont5(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FutureStream<T> input;
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	F pred;
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<T> output;
															#line 7649 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via filter()
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F>
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class FilterActor final : public Actor<Void>, public ActorSingleCallback< FilterActor<T, F>, 0, T >, public FastAllocated<FilterActor<T, F>>, public FilterActorState<T, F, FilterActor<T, F>> {
															#line 7656 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<FilterActor<T, F>>::operator new;
	using FastAllocated<FilterActor<T, F>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(8391437797539190272UL, 8553291567157857280UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< FilterActor<T, F>, 0, T >;
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FilterActor(FutureStream<T> const& input,F const& pred,PromiseStream<T> const& output) 
															#line 7673 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   FilterActorState<T, F, FilterActor<T, F>>(input, pred, output),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("filter", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(10068160600145463552UL, 10966321519488972800UL);
		ActorExecutionContextHelper __helper(static_cast<FilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("filter");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("filter", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< FilterActor<T, F>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F>
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> filter( FutureStream<T> const& input, F const& pred, PromiseStream<T> const& output ) {
															#line 481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new FilterActor<T, F>(input, pred, output));
															#line 7708 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 500 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// filters a stream asynchronously
															#line 7714 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via asyncFilter()
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F, class AsyncFilterActor>
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class AsyncFilterActorState {
															#line 7721 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	AsyncFilterActorState(FutureStream<T> const& input,F const& actorPred,PromiseStream<T> const& output) 
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : input(input),
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   actorPred(actorPred),
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   output(output),
															#line 504 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   futures(),
															#line 505 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   p()
															#line 7736 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("asyncFilter", reinterpret_cast<unsigned long>(this));

	}
	~AsyncFilterActorState() 
	{
		fdb_probe_actor_destroy("asyncFilter", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 507 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 7751 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AsyncFilterActorState();
		static_cast<AsyncFilterActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 528 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		;
															#line 7774 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 510 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			FutureStream<T> __when_expr_0 = input;
															#line 509 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<AsyncFilterActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 7793 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.pop(), loopDepth); };
															#line 513 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<bool> __when_expr_1 = futures.size() == 0 ? Never() : futures.front().second;
															#line 7797 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
			static_cast<AsyncFilterActor*>(this)->actor_wait_state = 1;
															#line 510 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< AsyncFilterActor, 0, T >*>(static_cast<AsyncFilterActor*>(this)));
															#line 513 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AsyncFilterActor, 1, bool >*>(static_cast<AsyncFilterActor*>(this)));
															#line 7804 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 520 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == error_code_end_of_stream)
															#line 7839 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
				return a_body1break1(loopDepth==0?0:loopDepth-1); // break
			}
			else
			{
															#line 523 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 7847 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T const& nextInput,int loopDepth) 
	{
															#line 511 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		futures.emplace_back(nextInput, actorPred(nextInput));
															#line 7868 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T && nextInput,int loopDepth) 
	{
															#line 511 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		futures.emplace_back(nextInput, actorPred(nextInput));
															#line 7877 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(bool const& pass,int loopDepth) 
	{
															#line 514 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (pass)
															#line 7886 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 515 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output.send(futures.front().first);
															#line 7890 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 516 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		futures.pop_front();
															#line 7894 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(bool && pass,int loopDepth) 
	{
															#line 514 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (pass)
															#line 7903 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 515 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output.send(futures.front().first);
															#line 7907 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 516 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		futures.pop_front();
															#line 7911 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AsyncFilterActor*>(this)->actor_wait_state > 0) static_cast<AsyncFilterActor*>(this)->actor_wait_state = 0;
		static_cast<AsyncFilterActor*>(this)->ActorSingleCallback< AsyncFilterActor, 0, T >::remove();
		static_cast<AsyncFilterActor*>(this)->ActorCallback< AsyncFilterActor, 1, bool >::remove();

	}
	void a_callback_fire(ActorSingleCallback< AsyncFilterActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("asyncFilter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncFilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("asyncFilter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< AsyncFilterActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("asyncFilter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncFilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("asyncFilter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< AsyncFilterActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("asyncFilter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncFilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("asyncFilter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AsyncFilterActor, 1, bool >*,bool const& value) 
	{
		fdb_probe_actor_enter("asyncFilter", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncFilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("asyncFilter", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AsyncFilterActor, 1, bool >*,bool && value) 
	{
		fdb_probe_actor_enter("asyncFilter", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncFilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("asyncFilter", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AsyncFilterActor, 1, bool >*,Error err) 
	{
		fdb_probe_actor_enter("asyncFilter", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncFilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("asyncFilter", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont2(int loopDepth) 
	{
															#line 536 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.sendError(end_of_stream());
															#line 538 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<AsyncFilterActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AsyncFilterActorState(); static_cast<AsyncFilterActor*>(this)->destroy(); return 0; }
															#line 8056 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<AsyncFilterActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~AsyncFilterActorState();
		static_cast<AsyncFilterActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 528 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!(futures.size()))
															#line 8075 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
			return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 529 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		p = futures.front();
															#line 530 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<bool> __when_expr_2 = p.second;
															#line 530 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<AsyncFilterActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 8085 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1when1(__when_expr_2.get(), loopDepth); };
		static_cast<AsyncFilterActor*>(this)->actor_wait_state = 2;
															#line 530 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< AsyncFilterActor, 2, bool >*>(static_cast<AsyncFilterActor*>(this)));
															#line 8090 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1break1(int loopDepth) 
	{
		try {
			return a_body1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(bool const& pass,int loopDepth) 
	{
															#line 531 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (pass)
															#line 8112 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 532 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output.send(p.first);
															#line 8116 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 533 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		futures.pop_front();
															#line 8120 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(bool && pass,int loopDepth) 
	{
															#line 531 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (pass)
															#line 8129 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 532 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output.send(p.first);
															#line 8133 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 533 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		futures.pop_front();
															#line 8137 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(bool const& pass,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(pass, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(bool && pass,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(std::move(pass), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AsyncFilterActor*>(this)->actor_wait_state > 0) static_cast<AsyncFilterActor*>(this)->actor_wait_state = 0;
		static_cast<AsyncFilterActor*>(this)->ActorCallback< AsyncFilterActor, 2, bool >::remove();

	}
	void a_callback_fire(ActorCallback< AsyncFilterActor, 2, bool >*,bool const& value) 
	{
		fdb_probe_actor_enter("asyncFilter", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncFilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("asyncFilter", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< AsyncFilterActor, 2, bool >*,bool && value) 
	{
		fdb_probe_actor_enter("asyncFilter", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncFilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("asyncFilter", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< AsyncFilterActor, 2, bool >*,Error err) 
	{
		fdb_probe_actor_enter("asyncFilter", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncFilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("asyncFilter", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FutureStream<T> input;
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	F actorPred;
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<T> output;
															#line 504 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Deque<std::pair<T, Future<bool>>> futures;
															#line 505 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	std::pair<T, Future<bool>> p;
															#line 8227 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via asyncFilter()
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F>
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class AsyncFilterActor final : public Actor<Void>, public ActorSingleCallback< AsyncFilterActor<T, F>, 0, T >, public ActorCallback< AsyncFilterActor<T, F>, 1, bool >, public ActorCallback< AsyncFilterActor<T, F>, 2, bool >, public FastAllocated<AsyncFilterActor<T, F>>, public AsyncFilterActorState<T, F, AsyncFilterActor<T, F>> {
															#line 8234 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<AsyncFilterActor<T, F>>::operator new;
	using FastAllocated<AsyncFilterActor<T, F>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(12195544373998887936UL, 13564074913537373952UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< AsyncFilterActor<T, F>, 0, T >;
friend struct ActorCallback< AsyncFilterActor<T, F>, 1, bool >;
friend struct ActorCallback< AsyncFilterActor<T, F>, 2, bool >;
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	AsyncFilterActor(FutureStream<T> const& input,F const& actorPred,PromiseStream<T> const& output) 
															#line 8253 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   AsyncFilterActorState<T, F, AsyncFilterActor<T, F>>(input, actorPred, output),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("asyncFilter", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(13878357602307046912UL, 4375813513290487552UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncFilterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("asyncFilter");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("asyncFilter", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< AsyncFilterActor<T, F>, 0, T >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AsyncFilterActor<T, F>, 2, bool >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class F>
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> asyncFilter( FutureStream<T> const& input, F const& actorPred, PromiseStream<T> const& output ) {
															#line 502 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new AsyncFilterActor<T, F>(input, actorPred, output));
															#line 8289 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 540 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

template <class T>
struct WorkerCache {
	// SOMEDAY: Would we do better to use "unreliable" (at most once) transport for the initialize requests and get rid
	// of this? It doesn't provide true at most once behavior because things are removed from the cache after they have
	// terminated.
	bool exists(UID id) { return id_interface.count(id) != 0; }
	void set(UID id, const Future<T>& onReady) {
		ASSERT(!exists(id));
		id_interface[id] = onReady;
	}
	Future<T> get(UID id) {
		ASSERT(exists(id));
		return id_interface[id];
	}

	Future<Void> removeOnReady(UID id, Future<Void> const& ready) { return removeOnReady(this, id, ready); }

private:
																#line 8312 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
// This generated class is to be used only via removeOnReady()
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class RemoveOnReadyActor>
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class RemoveOnReadyActorState {
															#line 8318 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	RemoveOnReadyActorState(WorkerCache* const& self,UID const& id,Future<Void> const& ready) 
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : self(self),
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   id(id),
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   ready(ready)
															#line 8329 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("removeOnReady", reinterpret_cast<unsigned long>(this));

	}
	~RemoveOnReadyActorState() 
	{
		fdb_probe_actor_destroy("removeOnReady", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 561 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<Void> __when_expr_0 = ready;
															#line 561 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<RemoveOnReadyActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 8347 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<RemoveOnReadyActor*>(this)->actor_wait_state = 1;
															#line 561 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< RemoveOnReadyActor, 0, Void >*>(static_cast<RemoveOnReadyActor*>(this)));
															#line 8352 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~RemoveOnReadyActorState();
		static_cast<RemoveOnReadyActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 565 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			self->id_interface.erase(id);
															#line 566 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(e, loopDepth);
															#line 8384 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 562 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		self->id_interface.erase(id);
															#line 563 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<RemoveOnReadyActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~RemoveOnReadyActorState(); static_cast<RemoveOnReadyActor*>(this)->destroy(); return 0; }
															#line 8400 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<RemoveOnReadyActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~RemoveOnReadyActorState();
		static_cast<RemoveOnReadyActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 562 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		self->id_interface.erase(id);
															#line 563 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<RemoveOnReadyActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~RemoveOnReadyActorState(); static_cast<RemoveOnReadyActor*>(this)->destroy(); return 0; }
															#line 8414 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<RemoveOnReadyActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~RemoveOnReadyActorState();
		static_cast<RemoveOnReadyActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<RemoveOnReadyActor*>(this)->actor_wait_state > 0) static_cast<RemoveOnReadyActor*>(this)->actor_wait_state = 0;
		static_cast<RemoveOnReadyActor*>(this)->ActorCallback< RemoveOnReadyActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< RemoveOnReadyActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("removeOnReady", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RemoveOnReadyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("removeOnReady", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< RemoveOnReadyActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("removeOnReady", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RemoveOnReadyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("removeOnReady", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< RemoveOnReadyActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("removeOnReady", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<RemoveOnReadyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("removeOnReady", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	WorkerCache* self;
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	UID id;
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> ready;
															#line 8503 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via removeOnReady()
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class RemoveOnReadyActor final : public Actor<Void>, public ActorCallback< RemoveOnReadyActor, 0, Void >, public FastAllocated<RemoveOnReadyActor>, public RemoveOnReadyActorState<RemoveOnReadyActor> {
															#line 8508 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<RemoveOnReadyActor>::operator new;
	using FastAllocated<RemoveOnReadyActor>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(14756505046518171136UL, 7127800628952681728UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< RemoveOnReadyActor, 0, Void >;
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	RemoveOnReadyActor(WorkerCache* const& self,UID const& id,Future<Void> const& ready) 
															#line 8525 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   RemoveOnReadyActorState<RemoveOnReadyActor>(self, id, ready),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("removeOnReady", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(4271278137371060736UL, 14669009522706832128UL);
		ActorExecutionContextHelper __helper(static_cast<RemoveOnReadyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("removeOnReady");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("removeOnReady", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< RemoveOnReadyActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] static Future<Void> removeOnReady( WorkerCache* const& self, UID const& id, Future<Void> const& ready ) {
															#line 559 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new RemoveOnReadyActor(self, id, ready));
															#line 8557 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 569 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

	std::map<UID, Future<T>> id_interface;
};

template <class K, class V>
class AsyncMap : NonCopyable {
public:
	// Represents a complete function from keys to values (K -> V)
	// All values not explicitly inserted map to V()
	// If this isn't appropriate, use V=Optional<X>

	AsyncMap() : defaultValue(), destructing(false) {}

	virtual ~AsyncMap() {
		destructing = true;
		items.clear();
	}

	void set(K const& k, V const& v) {
		auto& i = items[k];
		if (i.value != v)
			setUnconditional(k, v, i);
	}
	void setUnconditional(K const& k, V const& v) { setUnconditional(k, v, items[k]); }

	void sendError(K const& begin, K const& end, Error const& e) {
		if (begin >= end)
			return;
		std::vector<Promise<Void>> ps = swapRangePromises(items.lower_bound(begin), items.lower_bound(end));
		sendError(ps, e);
	}

	void triggerAll() {
		std::vector<Promise<Void>> ps = swapRangePromises(items.begin(), items.end());
		send(ps);
	}

	void triggerRange(K const& begin, K const& end) {
		if (begin >= end)
			return;
		std::vector<Promise<Void>> ps = swapRangePromises(items.lower_bound(begin), items.lower_bound(end));
		send(ps);
	}

	void trigger(K const& key) {
		if (items.count(key) != 0) {
			auto& i = items[key];
			Promise<Void> trigger;
			i.change.swap(trigger);
			Promise<Void> noDestroy = trigger; // See explanation of noDestroy in setUnconditional()

			if (i.value == defaultValue)
				items.erase(key);

			trigger.send(Void());
		}
	}
	void clear(K const& k) { set(k, V()); }
	V const& get(K const& k) const {
		auto it = items.find(k);
		if (it != items.end())
			return it->second.value;
		else
			return defaultValue;
	}
	int count(K const& k) const {
		auto it = items.find(k);
		if (it != items.end())
			return 1;
		return 0;
	}
	virtual Future<Void> onChange(K const& k) { // throws broken_promise if this is destroyed
		auto& item = items[k];
		if (item.value == defaultValue)
			return destroyOnCancel(this, k, item.change.getFuture());
		return item.change.getFuture();
	}
	std::vector<K> getKeys() const {
		std::vector<K> keys;
		keys.reserve(items.size());
		for (auto i = items.begin(); i != items.end(); ++i)
			keys.push_back(i->first);
		return keys;
	}
	void resetNoWaiting() {
		for (auto i = items.begin(); i != items.end(); ++i)
			ASSERT(i->second.change.getFuture().getFutureReferenceCount() == 1);
		items.clear();
	}

protected:
	// Invariant: Every item in the map either has value!=defaultValue xor a destroyOnCancel actor waiting on
	// change.getFuture()
	struct P {
		V value;
		Promise<Void> change;
		P() : value() {}
	};
	std::map<K, P> items;
	const V defaultValue;
	bool destructing;

	template <typename Iterator>
	std::vector<Promise<Void>> swapRangePromises(Iterator begin, Iterator end) {
		std::vector<Promise<Void>> ps;
		for (auto it = begin; it != end; ++it) {
			ps.resize(ps.size() + 1);
			ps.back().swap(it->second.change);
		}
		return ps;
	}

	// ps can't be a reference. See explanation of noDestroy in setUnconditional()
	void send(std::vector<Promise<Void>> ps) {
		for (auto& p : ps) {
			p.send(Void());
		}
	}

	// ps can't be a reference. See explanation of noDestroy in setUnconditional()
	void sendError(std::vector<Promise<Void>> ps, Error const& e) {
		for (auto& p : ps) {
			p.sendError(e);
		}
	}

	void setUnconditional(K const& k, V const& v, P& i) {
		Promise<Void> trigger;
		i.change.swap(trigger);
		Promise<Void> noDestroy =
		    trigger; // The send(Void()) or even V::operator= could cause destroyOnCancel,
		             // which could undo the change to i.value here.  Keeping the promise reference count >= 2
		             // prevents destroyOnCancel from erasing anything from the map.
		if (v == defaultValue) {
			items.erase(k);
		} else {
			i.value = v;
		}

		trigger.send(Void());
	}

																#line 8703 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
// This generated class is to be used only via destroyOnCancel()
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class DestroyOnCancelActor>
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DestroyOnCancelActorState {
															#line 8709 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DestroyOnCancelActorState(AsyncMap* const& self,K const& key,Future<Void> const& change) 
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : self(self),
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   key(key),
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   change(change)
															#line 8720 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("destroyOnCancel", reinterpret_cast<unsigned long>(this));

	}
	~DestroyOnCancelActorState() 
	{
		fdb_probe_actor_destroy("destroyOnCancel", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 713 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<Void> __when_expr_0 = change;
															#line 713 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<DestroyOnCancelActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 8738 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<DestroyOnCancelActor*>(this)->actor_wait_state = 1;
															#line 713 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< DestroyOnCancelActor, 0, Void >*>(static_cast<DestroyOnCancelActor*>(this)));
															#line 8743 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~DestroyOnCancelActorState();
		static_cast<DestroyOnCancelActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 716 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == error_code_actor_cancelled && !self->destructing && change.getFutureReferenceCount() == 1 && change.getPromiseReferenceCount() == 1)
															#line 8773 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 718 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (EXPENSIVE_VALIDATION)
															#line 8777 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				{
															#line 719 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
					auto& p = self->items[key];
															#line 720 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
					ASSERT(p.change.getFuture() == change);
															#line 8783 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				}
															#line 722 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				self->items.erase(key);
															#line 8787 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 724 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(e, loopDepth);
															#line 8791 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 714 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<DestroyOnCancelActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~DestroyOnCancelActorState(); static_cast<DestroyOnCancelActor*>(this)->destroy(); return 0; }
															#line 8805 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<DestroyOnCancelActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~DestroyOnCancelActorState();
		static_cast<DestroyOnCancelActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 714 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<DestroyOnCancelActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~DestroyOnCancelActorState(); static_cast<DestroyOnCancelActor*>(this)->destroy(); return 0; }
															#line 8817 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<DestroyOnCancelActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~DestroyOnCancelActorState();
		static_cast<DestroyOnCancelActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<DestroyOnCancelActor*>(this)->actor_wait_state > 0) static_cast<DestroyOnCancelActor*>(this)->actor_wait_state = 0;
		static_cast<DestroyOnCancelActor*>(this)->ActorCallback< DestroyOnCancelActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DestroyOnCancelActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("destroyOnCancel", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DestroyOnCancelActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("destroyOnCancel", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< DestroyOnCancelActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("destroyOnCancel", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DestroyOnCancelActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("destroyOnCancel", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< DestroyOnCancelActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("destroyOnCancel", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<DestroyOnCancelActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("destroyOnCancel", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	AsyncMap* self;
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	K key;
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> change;
															#line 8906 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via destroyOnCancel()
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DestroyOnCancelActor final : public Actor<Void>, public ActorCallback< DestroyOnCancelActor, 0, Void >, public FastAllocated<DestroyOnCancelActor>, public DestroyOnCancelActorState<DestroyOnCancelActor> {
															#line 8911 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<DestroyOnCancelActor>::operator new;
	using FastAllocated<DestroyOnCancelActor>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(5291613549865629952UL, 4955459677181346304UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< DestroyOnCancelActor, 0, Void >;
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DestroyOnCancelActor(AsyncMap* const& self,K const& key,Future<Void> const& change) 
															#line 8928 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   DestroyOnCancelActorState<DestroyOnCancelActor>(self, key, change),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("destroyOnCancel", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(3306109439013010944UL, 15621614171885355520UL);
		ActorExecutionContextHelper __helper(static_cast<DestroyOnCancelActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("destroyOnCancel");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("destroyOnCancel", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< DestroyOnCancelActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> destroyOnCancel( AsyncMap* const& self, K const& key, Future<Void> const& change ) {
															#line 711 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new DestroyOnCancelActor(self, key, change));
															#line 8960 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 727 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
};

template <class V>
class ReferencedObject : NonCopyable, public ReferenceCounted<ReferencedObject<V>> {
public:
	ReferencedObject() : value() {}
	ReferencedObject(V const& v) : value(v) {}
	ReferencedObject(V&& v) : value(std::move(v)) {}
	ReferencedObject(ReferencedObject&& r) : value(std::move(r.value)) {}

	void operator=(ReferencedObject&& r) { value = std::move(r.value); }

	V const& get() const { return value; }

	V& mutate() { return value; }

	void set(V const& v) { value = v; }

	void set(V&& v) { value = std::move(v); }

	static Reference<ReferencedObject<V>> from(V const& v) { return makeReference<ReferencedObject<V>>(v); }

	static Reference<ReferencedObject<V>> from(V&& v) { return makeReference<ReferencedObject<V>>(std::move(v)); }

private:
	V value;
};

// FIXME(swift): Remove once https://github.com/apple/swift/issues/61620 is fixed.
#define SWIFT_CXX_REF_ASYNCVAR                                                                                         \
	__attribute__((swift_attr("import_reference"))) __attribute__((swift_attr("retain:immortal")))                     \
	__attribute__((swift_attr("release:immortal")))
// // TODO(swift): https://github.com/apple/swift/issues/62456 can't support retain/release funcs that are templates
// themselfes
//    __attribute__((swift_attr("retain:addref_AsyncVar")))   \
//    __attribute__((swift_attr("release:delref_AsyncVar")))

template <class V>
class SWIFT_CXX_REF_ASYNCVAR AsyncVar : NonCopyable, public ReferenceCounted<AsyncVar<V>> {
public:
	AsyncVar() : value() {}
	AsyncVar(V const& v) : value(v) {}
	AsyncVar(AsyncVar&& av) : value(std::move(av.value)), nextChange(std::move(av.nextChange)) {}
	void operator=(AsyncVar&& av) {
		value = std::move(av.value);
		nextChange = std::move(av.nextChange);
	}

	V const& get() const { return value; }
	V getCopy() const __attribute__((swift_attr("import_unsafe"))) { return value; }
	Future<Void> onChange() const { return nextChange.getFuture(); }
	void set(V const& v) {
		if (v != value)
			setUnconditional(v);
	}
	void setUnconditional(V const& v) {
		Promise<Void> t;
		this->nextChange.swap(t);
		this->value = v;
		t.send(Void());
	}
	void trigger() {
		Promise<Void> t;
		this->nextChange.swap(t);
		t.send(Void());
	}

private:
	V value;
	Promise<Void> nextChange;
};

class AsyncTrigger : NonCopyable {
public:
	AsyncTrigger() {}
	AsyncTrigger(AsyncTrigger&& at) : v(std::move(at.v)) {}
	void operator=(AsyncTrigger&& at) { v = std::move(at.v); }
	Future<Void> onTrigger() const { return v.onChange(); }
	void trigger() { v.trigger(); }

private:
	AsyncVar<Void> v;
};

// Binds an AsyncTrigger object to an AsyncVar, so when the AsyncVar changes
// the AsyncTrigger is triggered.
															#line 9050 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via forward()
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class ForwardActor>
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ForwardActorState {
															#line 9057 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ForwardActorState(Reference<AsyncVar<T> const> const& from,AsyncTrigger* const& to) 
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : from(from),
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   to(to)
															#line 9066 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("forward", reinterpret_cast<unsigned long>(this));

	}
	~ForwardActorState() 
	{
		fdb_probe_actor_destroy("forward", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 815 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 9081 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ForwardActorState();
		static_cast<ForwardActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 816 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_0 = from->onChange();
															#line 816 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<ForwardActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 9113 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<ForwardActor*>(this)->actor_wait_state = 1;
															#line 816 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ForwardActor, 0, Void >*>(static_cast<ForwardActor*>(this)));
															#line 9118 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 817 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		to->trigger();
															#line 9127 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 817 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		to->trigger();
															#line 9136 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ForwardActor*>(this)->actor_wait_state > 0) static_cast<ForwardActor*>(this)->actor_wait_state = 0;
		static_cast<ForwardActor*>(this)->ActorCallback< ForwardActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ForwardActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("forward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forward", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ForwardActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("forward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forward", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ForwardActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("forward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forward", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Reference<AsyncVar<T> const> from;
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	AsyncTrigger* to;
															#line 9220 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via forward()
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ForwardActor final : public Actor<Void>, public ActorCallback< ForwardActor<T>, 0, Void >, public FastAllocated<ForwardActor<T>>, public ForwardActorState<T, ForwardActor<T>> {
															#line 9227 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<ForwardActor<T>>::operator new;
	using FastAllocated<ForwardActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(5886494081918704896UL, 3316517890409155328UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< ForwardActor<T>, 0, Void >;
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ForwardActor(Reference<AsyncVar<T> const> const& from,AsyncTrigger* const& to) 
															#line 9244 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   ForwardActorState<T, ForwardActor<T>>(from, to),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("forward", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(8245280572221998592UL, 11353959039738441216UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("forward");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("forward", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ForwardActor<T>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> forward( Reference<AsyncVar<T> const> const& from, AsyncTrigger* const& to ) {
															#line 813 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new ForwardActor<T>(from, to));
															#line 9279 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 820 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

class Debouncer : NonCopyable {
public:
	explicit Debouncer(double delay) { worker = debounceWorker(this, delay); }
	Debouncer(Debouncer&& at) = default;
	Debouncer& operator=(Debouncer&& at) = default;
	Future<Void> onTrigger() { return output.onChange(); }
	void trigger() { input.setUnconditional(Void()); }

private:
	AsyncVar<Void> input;
	AsyncVar<Void> output;
	Future<Void> worker;

																#line 9297 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
// This generated class is to be used only via debounceWorker()
															#line 834 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class DebounceWorkerActor>
															#line 834 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DebounceWorkerActorState {
															#line 9303 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 834 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DebounceWorkerActorState(Debouncer* const& self,double const& bounceTime) 
															#line 834 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 834 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : self(self),
															#line 834 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   bounceTime(bounceTime)
															#line 9312 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("debounceWorker", reinterpret_cast<unsigned long>(this));

	}
	~DebounceWorkerActorState() 
	{
		fdb_probe_actor_destroy("debounceWorker", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 835 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 9327 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~DebounceWorkerActorState();
		static_cast<DebounceWorkerActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 836 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_0 = self->input.onChange();
															#line 836 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<DebounceWorkerActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 9359 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<DebounceWorkerActor*>(this)->actor_wait_state = 1;
															#line 836 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< DebounceWorkerActor, 0, Void >*>(static_cast<DebounceWorkerActor*>(this)));
															#line 9364 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 837 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		;
															#line 9373 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 837 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		;
															#line 9382 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<DebounceWorkerActor*>(this)->actor_wait_state > 0) static_cast<DebounceWorkerActor*>(this)->actor_wait_state = 0;
		static_cast<DebounceWorkerActor*>(this)->ActorCallback< DebounceWorkerActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DebounceWorkerActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("debounceWorker", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DebounceWorkerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("debounceWorker", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< DebounceWorkerActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("debounceWorker", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DebounceWorkerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("debounceWorker", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< DebounceWorkerActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("debounceWorker", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<DebounceWorkerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("debounceWorker", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
															#line 845 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		self->output.setUnconditional(Void());
															#line 9466 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1(int loopDepth) 
	{
															#line 839 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_1 = self->input.onChange();
															#line 838 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<DebounceWorkerActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 2));
															#line 9484 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 2)); else return a_body1loopBody1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
															#line 840 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_2 = delay(bounceTime);
															#line 9488 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 2)); else return a_body1loopBody1cont1loopBody1when2(__when_expr_2.get(), loopDepth); };
		static_cast<DebounceWorkerActor*>(this)->actor_wait_state = 2;
															#line 839 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< DebounceWorkerActor, 1, Void >*>(static_cast<DebounceWorkerActor*>(this)));
															#line 840 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< DebounceWorkerActor, 2, Void >*>(static_cast<DebounceWorkerActor*>(this)));
															#line 9495 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopBody1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when2(Void const& _,int loopDepth) 
	{
		return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when2(Void && _,int loopDepth) 
	{
		return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<DebounceWorkerActor*>(this)->actor_wait_state > 0) static_cast<DebounceWorkerActor*>(this)->actor_wait_state = 0;
		static_cast<DebounceWorkerActor*>(this)->ActorCallback< DebounceWorkerActor, 1, Void >::remove();
		static_cast<DebounceWorkerActor*>(this)->ActorCallback< DebounceWorkerActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DebounceWorkerActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("debounceWorker", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DebounceWorkerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("debounceWorker", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< DebounceWorkerActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("debounceWorker", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DebounceWorkerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("debounceWorker", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< DebounceWorkerActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("debounceWorker", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<DebounceWorkerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("debounceWorker", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< DebounceWorkerActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("debounceWorker", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DebounceWorkerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("debounceWorker", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< DebounceWorkerActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("debounceWorker", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DebounceWorkerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("debounceWorker", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< DebounceWorkerActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("debounceWorker", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<DebounceWorkerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("debounceWorker", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 834 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Debouncer* self;
															#line 834 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double bounceTime;
															#line 9668 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via debounceWorker()
															#line 834 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DebounceWorkerActor final : public Actor<Void>, public ActorCallback< DebounceWorkerActor, 0, Void >, public ActorCallback< DebounceWorkerActor, 1, Void >, public ActorCallback< DebounceWorkerActor, 2, Void >, public FastAllocated<DebounceWorkerActor>, public DebounceWorkerActorState<DebounceWorkerActor> {
															#line 9673 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<DebounceWorkerActor>::operator new;
	using FastAllocated<DebounceWorkerActor>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(1196635105470254848UL, 9240130026000963072UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< DebounceWorkerActor, 0, Void >;
friend struct ActorCallback< DebounceWorkerActor, 1, Void >;
friend struct ActorCallback< DebounceWorkerActor, 2, Void >;
															#line 834 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DebounceWorkerActor(Debouncer* const& self,double const& bounceTime) 
															#line 9692 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   DebounceWorkerActorState<DebounceWorkerActor>(self, bounceTime),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("debounceWorker", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(3033202529816868352UL, 12951201835907995392UL);
		ActorExecutionContextHelper __helper(static_cast<DebounceWorkerActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("debounceWorker");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("debounceWorker", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< DebounceWorkerActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< DebounceWorkerActor, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 834 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> debounceWorker( Debouncer* const& self, double const& bounceTime ) {
															#line 834 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new DebounceWorkerActor(self, bounceTime));
															#line 9725 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 848 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
};

															#line 9731 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via asyncDeserialize()
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class AsyncDeserializeActor>
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class AsyncDeserializeActorState {
															#line 9738 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	AsyncDeserializeActorState(Reference<AsyncVar<Standalone<StringRef>>> const& input,Reference<AsyncVar<Optional<T>>> const& output) 
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : input(input),
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   output(output)
															#line 9747 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("asyncDeserialize", reinterpret_cast<unsigned long>(this));

	}
	~AsyncDeserializeActorState() 
	{
		fdb_probe_actor_destroy("asyncDeserialize", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 853 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 9762 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AsyncDeserializeActorState();
		static_cast<AsyncDeserializeActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 854 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (input->get().size())
															#line 9792 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 855 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			ObjectReader reader(input->get().begin(), IncludeVersion());
															#line 856 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			T res;
															#line 857 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			reader.deserialize(res);
															#line 858 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output->set(res);
															#line 9802 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		else
		{
															#line 860 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output->set(Optional<T>());
															#line 9808 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 861 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_0 = input->onChange();
															#line 861 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<AsyncDeserializeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 9814 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<AsyncDeserializeActor*>(this)->actor_wait_state = 1;
															#line 861 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AsyncDeserializeActor, 0, Void >*>(static_cast<AsyncDeserializeActor*>(this)));
															#line 9819 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AsyncDeserializeActor*>(this)->actor_wait_state > 0) static_cast<AsyncDeserializeActor*>(this)->actor_wait_state = 0;
		static_cast<AsyncDeserializeActor*>(this)->ActorCallback< AsyncDeserializeActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AsyncDeserializeActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("asyncDeserialize", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncDeserializeActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("asyncDeserialize", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AsyncDeserializeActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("asyncDeserialize", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncDeserializeActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("asyncDeserialize", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AsyncDeserializeActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("asyncDeserialize", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncDeserializeActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("asyncDeserialize", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Reference<AsyncVar<Standalone<StringRef>>> input;
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Reference<AsyncVar<Optional<T>>> output;
															#line 9915 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via asyncDeserialize()
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class AsyncDeserializeActor final : public Actor<Void>, public ActorCallback< AsyncDeserializeActor<T>, 0, Void >, public FastAllocated<AsyncDeserializeActor<T>>, public AsyncDeserializeActorState<T, AsyncDeserializeActor<T>> {
															#line 9922 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<AsyncDeserializeActor<T>>::operator new;
	using FastAllocated<AsyncDeserializeActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(10241309533956846848UL, 11285317513656494080UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< AsyncDeserializeActor<T>, 0, Void >;
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	AsyncDeserializeActor(Reference<AsyncVar<Standalone<StringRef>>> const& input,Reference<AsyncVar<Optional<T>>> const& output) 
															#line 9939 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   AsyncDeserializeActorState<T, AsyncDeserializeActor<T>>(input, output),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("asyncDeserialize", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(8880724784580520704UL, 13500823833316833536UL);
		ActorExecutionContextHelper __helper(static_cast<AsyncDeserializeActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("asyncDeserialize");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("asyncDeserialize", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AsyncDeserializeActor<T>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> asyncDeserialize( Reference<AsyncVar<Standalone<StringRef>>> const& input, Reference<AsyncVar<Optional<T>>> const& output ) {
															#line 850 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new AsyncDeserializeActor<T>(input, output));
															#line 9974 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 864 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 9979 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via forwardVector()
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class V, class T, class ForwardVectorActor>
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ForwardVectorActorState {
															#line 9986 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ForwardVectorActorState(Future<V> const& values,std::vector<Promise<T>> const& out) 
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : values(values),
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   out(out)
															#line 9995 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("forwardVector", reinterpret_cast<unsigned long>(this));

	}
	~ForwardVectorActorState() 
	{
		fdb_probe_actor_destroy("forwardVector", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 867 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<V> __when_expr_0 = values;
															#line 867 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 10012 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			static_cast<ForwardVectorActor*>(this)->actor_wait_state = 1;
															#line 867 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ForwardVectorActor, 0, V >*>(static_cast<ForwardVectorActor*>(this)));
															#line 10016 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		delete static_cast<ForwardVectorActor*>(this);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(V const& in,int loopDepth) 
	{
															#line 868 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		ASSERT(in.size() == out.size());
															#line 869 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		for(int i = 0;i < out.size();i++) {
															#line 870 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			out[i].send(in[i]);
															#line 10042 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(V && in,int loopDepth) 
	{
															#line 868 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		ASSERT(in.size() == out.size());
															#line 869 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		for(int i = 0;i < out.size();i++) {
															#line 870 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			out[i].send(in[i]);
															#line 10056 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1when1(V const& in,int loopDepth) 
	{
		loopDepth = a_body1cont1(in, loopDepth);

		return loopDepth;
	}
	int a_body1when1(V && in,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(in), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ForwardVectorActor*>(this)->actor_wait_state > 0) static_cast<ForwardVectorActor*>(this)->actor_wait_state = 0;
		static_cast<ForwardVectorActor*>(this)->ActorCallback< ForwardVectorActor, 0, V >::remove();

	}
	void a_callback_fire(ActorCallback< ForwardVectorActor, 0, V >*,V const& value) 
	{
		fdb_probe_actor_enter("forwardVector", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardVectorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forwardVector", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ForwardVectorActor, 0, V >*,V && value) 
	{
		fdb_probe_actor_enter("forwardVector", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardVectorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forwardVector", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ForwardVectorActor, 0, V >*,Error err) 
	{
		fdb_probe_actor_enter("forwardVector", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardVectorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forwardVector", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont4(int loopDepth) 
	{
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		delete static_cast<ForwardVectorActor*>(this);
															#line 10141 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		return 0;

		return loopDepth;
	}
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<V> values;
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	std::vector<Promise<T>> out;
															#line 10150 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via forwardVector()
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class V, class T>
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ForwardVectorActor final : public Actor<void>, public ActorCallback< ForwardVectorActor<V, T>, 0, V >, public FastAllocated<ForwardVectorActor<V, T>>, public ForwardVectorActorState<V, T, ForwardVectorActor<V, T>> {
															#line 10157 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<ForwardVectorActor<V, T>>::operator new;
	using FastAllocated<ForwardVectorActor<V, T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(106099394244971520UL, 9040856245987063040UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() {{
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<void>*>(this)->~Actor();
        operator delete(this);
    }}
#pragma clang diagnostic pop
friend struct ActorCallback< ForwardVectorActor<V, T>, 0, V >;
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ForwardVectorActor(Future<V> const& values,std::vector<Promise<T>> const& out) 
															#line 10174 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<void>(),
		   ForwardVectorActorState<V, T, ForwardVectorActor<V, T>>(values, out),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("forwardVector", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(442187572750428416UL, 9524158148023462400UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardVectorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("forwardVector");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("forwardVector", reinterpret_cast<unsigned long>(this), -1);

	}
};
} // namespace
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class V, class T>
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
void forwardVector( Future<V> const& values, std::vector<Promise<T>> const& out ) {
															#line 865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	new ForwardVectorActor<V, T>(values, out);
															#line 10200 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 872 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 10205 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via delayedAsyncVar()
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class DelayedAsyncVarActor>
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DelayedAsyncVarActorState {
															#line 10212 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DelayedAsyncVarActorState(Reference<AsyncVar<T>> const& in,Reference<AsyncVar<T>> const& out,double const& time) 
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : in(in),
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   out(out),
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   time(time)
															#line 10223 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("delayedAsyncVar", reinterpret_cast<unsigned long>(this));

	}
	~DelayedAsyncVarActorState() 
	{
		fdb_probe_actor_destroy("delayedAsyncVar", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 876 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				;
															#line 10239 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = a_body1loopHead1(loopDepth);
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~DelayedAsyncVarActorState();
		static_cast<DelayedAsyncVarActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 882 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			out->set(in->get());
															#line 883 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(e, loopDepth);
															#line 10271 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 877 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_0 = delay(time);
															#line 877 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<DelayedAsyncVarActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 10294 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<DelayedAsyncVarActor*>(this)->actor_wait_state = 1;
															#line 877 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< DelayedAsyncVarActor, 0, Void >*>(static_cast<DelayedAsyncVarActor*>(this)));
															#line 10299 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 878 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		out->set(in->get());
															#line 879 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_1 = in->onChange();
															#line 879 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<DelayedAsyncVarActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 10312 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<DelayedAsyncVarActor*>(this)->actor_wait_state = 2;
															#line 879 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< DelayedAsyncVarActor, 1, Void >*>(static_cast<DelayedAsyncVarActor*>(this)));
															#line 10317 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 878 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		out->set(in->get());
															#line 879 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_1 = in->onChange();
															#line 879 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<DelayedAsyncVarActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 10330 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<DelayedAsyncVarActor*>(this)->actor_wait_state = 2;
															#line 879 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< DelayedAsyncVarActor, 1, Void >*>(static_cast<DelayedAsyncVarActor*>(this)));
															#line 10335 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<DelayedAsyncVarActor*>(this)->actor_wait_state > 0) static_cast<DelayedAsyncVarActor*>(this)->actor_wait_state = 0;
		static_cast<DelayedAsyncVarActor*>(this)->ActorCallback< DelayedAsyncVarActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DelayedAsyncVarActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("delayedAsyncVar", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedAsyncVarActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayedAsyncVar", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< DelayedAsyncVarActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("delayedAsyncVar", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedAsyncVarActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayedAsyncVar", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< DelayedAsyncVarActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("delayedAsyncVar", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedAsyncVarActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayedAsyncVar", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(Void const& _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void && _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<DelayedAsyncVarActor*>(this)->actor_wait_state > 0) static_cast<DelayedAsyncVarActor*>(this)->actor_wait_state = 0;
		static_cast<DelayedAsyncVarActor*>(this)->ActorCallback< DelayedAsyncVarActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DelayedAsyncVarActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("delayedAsyncVar", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedAsyncVarActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayedAsyncVar", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< DelayedAsyncVarActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("delayedAsyncVar", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedAsyncVarActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayedAsyncVar", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< DelayedAsyncVarActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("delayedAsyncVar", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedAsyncVarActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayedAsyncVar", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Reference<AsyncVar<T>> in;
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Reference<AsyncVar<T>> out;
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double time;
															#line 10508 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via delayedAsyncVar()
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DelayedAsyncVarActor final : public Actor<Void>, public ActorCallback< DelayedAsyncVarActor<T>, 0, Void >, public ActorCallback< DelayedAsyncVarActor<T>, 1, Void >, public FastAllocated<DelayedAsyncVarActor<T>>, public DelayedAsyncVarActorState<T, DelayedAsyncVarActor<T>> {
															#line 10515 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<DelayedAsyncVarActor<T>>::operator new;
	using FastAllocated<DelayedAsyncVarActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(17362254266149106176UL, 12364910210929364224UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< DelayedAsyncVarActor<T>, 0, Void >;
friend struct ActorCallback< DelayedAsyncVarActor<T>, 1, Void >;
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DelayedAsyncVarActor(Reference<AsyncVar<T>> const& in,Reference<AsyncVar<T>> const& out,double const& time) 
															#line 10533 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   DelayedAsyncVarActorState<T, DelayedAsyncVarActor<T>>(in, out, time),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("delayedAsyncVar", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(186058093137053440UL, 6426008344032713216UL);
		ActorExecutionContextHelper __helper(static_cast<DelayedAsyncVarActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("delayedAsyncVar");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("delayedAsyncVar", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< DelayedAsyncVarActor<T>, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< DelayedAsyncVarActor<T>, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> delayedAsyncVar( Reference<AsyncVar<T>> const& in, Reference<AsyncVar<T>> const& out, double const& time ) {
															#line 873 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new DelayedAsyncVarActor<T>(in, out, time));
															#line 10569 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 886 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 10574 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via setAfter()
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class SetAfterActor>
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class SetAfterActorState {
															#line 10581 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	SetAfterActorState(Reference<AsyncVar<T>> const& var,double const& time,T const& val) 
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : var(var),
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   time(time),
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   val(val)
															#line 10592 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("setAfter", reinterpret_cast<unsigned long>(this));

	}
	~SetAfterActorState() 
	{
		fdb_probe_actor_destroy("setAfter", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 889 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = delay(time);
															#line 889 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<SetAfterActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 10609 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<SetAfterActor*>(this)->actor_wait_state = 1;
															#line 889 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SetAfterActor, 0, Void >*>(static_cast<SetAfterActor*>(this)));
															#line 10614 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SetAfterActorState();
		static_cast<SetAfterActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 890 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		var->set(val);
															#line 891 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<SetAfterActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SetAfterActorState(); static_cast<SetAfterActor*>(this)->destroy(); return 0; }
															#line 10639 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<SetAfterActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SetAfterActorState();
		static_cast<SetAfterActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 890 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		var->set(val);
															#line 891 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<SetAfterActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SetAfterActorState(); static_cast<SetAfterActor*>(this)->destroy(); return 0; }
															#line 10653 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<SetAfterActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SetAfterActorState();
		static_cast<SetAfterActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SetAfterActor*>(this)->actor_wait_state > 0) static_cast<SetAfterActor*>(this)->actor_wait_state = 0;
		static_cast<SetAfterActor*>(this)->ActorCallback< SetAfterActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SetAfterActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("setAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SetAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("setAfter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SetAfterActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("setAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SetAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("setAfter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SetAfterActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("setAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<SetAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("setAfter", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Reference<AsyncVar<T>> var;
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double time;
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	T val;
															#line 10742 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via setAfter()
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class SetAfterActor final : public Actor<Void>, public ActorCallback< SetAfterActor<T>, 0, Void >, public FastAllocated<SetAfterActor<T>>, public SetAfterActorState<T, SetAfterActor<T>> {
															#line 10749 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<SetAfterActor<T>>::operator new;
	using FastAllocated<SetAfterActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(9769793093115702528UL, 15176811495835748864UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< SetAfterActor<T>, 0, Void >;
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	SetAfterActor(Reference<AsyncVar<T>> const& var,double const& time,T const& val) 
															#line 10766 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   SetAfterActorState<T, SetAfterActor<T>>(var, time, val),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("setAfter", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(17789322467368306944UL, 3985877205555243520UL);
		ActorExecutionContextHelper __helper(static_cast<SetAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("setAfter");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("setAfter", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SetAfterActor<T>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> setAfter( Reference<AsyncVar<T>> const& var, double const& time, T const& val ) {
															#line 887 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new SetAfterActor<T>(var, time, val));
															#line 10801 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 893 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 10806 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via resetAfter()
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class ResetAfterActor>
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ResetAfterActorState {
															#line 10813 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ResetAfterActorState(Reference<AsyncVar<T>> const& var,double const& time,T const& val,int const& warningLimit = -1,double const& warningResetDelay = 0,const char* const& context = nullptr) 
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : var(var),
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   time(time),
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   val(val),
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   warningLimit(warningLimit),
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   warningResetDelay(warningResetDelay),
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   context(context),
															#line 901 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   isEqual(var->get() == val),
															#line 902 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   resetDelay(isEqual ? Never() : delay(time)),
															#line 903 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   resetCount(0),
															#line 904 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   lastReset(now())
															#line 10838 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("resetAfter", reinterpret_cast<unsigned long>(this));

	}
	~ResetAfterActorState() 
	{
		fdb_probe_actor_destroy("resetAfter", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 905 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 10853 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ResetAfterActorState();
		static_cast<ResetAfterActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 907 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_0 = resetDelay;
															#line 906 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<ResetAfterActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 10885 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
															#line 922 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_1 = var->onChange();
															#line 10889 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
		static_cast<ResetAfterActor*>(this)->actor_wait_state = 1;
															#line 907 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ResetAfterActor, 0, Void >*>(static_cast<ResetAfterActor*>(this)));
															#line 922 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< ResetAfterActor, 1, Void >*>(static_cast<ResetAfterActor*>(this)));
															#line 10896 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
															#line 924 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (isEqual && var->get() != val)
															#line 10905 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 925 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			isEqual = false;
															#line 926 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			resetDelay = delay(time);
															#line 10911 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 928 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!isEqual && var->get() == val)
															#line 10915 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 929 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			isEqual = true;
															#line 930 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			resetDelay = Never();
															#line 10921 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
															#line 908 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		var->set(val);
															#line 909 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (now() - lastReset > warningResetDelay)
															#line 10933 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 910 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			resetCount = 0;
															#line 10937 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 912 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		resetCount++;
															#line 913 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (context && warningLimit >= 0 && resetCount > warningLimit)
															#line 10943 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 914 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			TraceEvent(SevWarnAlways, context) .detail("ResetCount", resetCount) .detail("LastReset", now() - lastReset);
															#line 10947 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 918 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		lastReset = now();
															#line 919 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		isEqual = true;
															#line 920 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		resetDelay = Never();
															#line 10955 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
															#line 908 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		var->set(val);
															#line 909 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (now() - lastReset > warningResetDelay)
															#line 10966 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 910 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			resetCount = 0;
															#line 10970 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 912 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		resetCount++;
															#line 913 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (context && warningLimit >= 0 && resetCount > warningLimit)
															#line 10976 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 914 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			TraceEvent(SevWarnAlways, context) .detail("ResetCount", resetCount) .detail("LastReset", now() - lastReset);
															#line 10980 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 918 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		lastReset = now();
															#line 919 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		isEqual = true;
															#line 920 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		resetDelay = Never();
															#line 10988 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ResetAfterActor*>(this)->actor_wait_state > 0) static_cast<ResetAfterActor*>(this)->actor_wait_state = 0;
		static_cast<ResetAfterActor*>(this)->ActorCallback< ResetAfterActor, 0, Void >::remove();
		static_cast<ResetAfterActor*>(this)->ActorCallback< ResetAfterActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ResetAfterActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("resetAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ResetAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("resetAfter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ResetAfterActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("resetAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ResetAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("resetAfter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ResetAfterActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("resetAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ResetAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("resetAfter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ResetAfterActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("resetAfter", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ResetAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("resetAfter", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< ResetAfterActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("resetAfter", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ResetAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("resetAfter", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< ResetAfterActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("resetAfter", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ResetAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("resetAfter", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Reference<AsyncVar<T>> var;
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double time;
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	T val;
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	int warningLimit;
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double warningResetDelay;
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	const char* context;
															#line 901 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	bool isEqual;
															#line 902 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> resetDelay;
															#line 903 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	int resetCount;
															#line 904 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double lastReset;
															#line 11146 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via resetAfter()
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ResetAfterActor final : public Actor<Void>, public ActorCallback< ResetAfterActor<T>, 0, Void >, public ActorCallback< ResetAfterActor<T>, 1, Void >, public FastAllocated<ResetAfterActor<T>>, public ResetAfterActorState<T, ResetAfterActor<T>> {
															#line 11153 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<ResetAfterActor<T>>::operator new;
	using FastAllocated<ResetAfterActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(8139089363418776064UL, 1742370580028583936UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< ResetAfterActor<T>, 0, Void >;
friend struct ActorCallback< ResetAfterActor<T>, 1, Void >;
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ResetAfterActor(Reference<AsyncVar<T>> const& var,double const& time,T const& val,int const& warningLimit = -1,double const& warningResetDelay = 0,const char* const& context = nullptr) 
															#line 11171 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   ResetAfterActorState<T, ResetAfterActor<T>>(var, time, val, warningLimit, warningResetDelay, context),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("resetAfter", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(3617812349498570496UL, 3760078300196401408UL);
		ActorExecutionContextHelper __helper(static_cast<ResetAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("resetAfter");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("resetAfter", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ResetAfterActor<T>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> resetAfter( Reference<AsyncVar<T>> const& var, double const& time, T const& val, int const& warningLimit = -1, double const& warningResetDelay = 0, const char* const& context = nullptr ) {
															#line 894 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new ResetAfterActor<T>(var, time, val, warningLimit, warningResetDelay, context));
															#line 11206 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 934 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 11211 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via setWhenDoneOrError()
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class SetWhenDoneOrErrorActor>
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class SetWhenDoneOrErrorActorState {
															#line 11218 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	SetWhenDoneOrErrorActorState(Future<Void> const& condition,Reference<AsyncVar<T>> const& var,T const& val) 
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : condition(condition),
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   var(var),
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   val(val)
															#line 11229 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("setWhenDoneOrError", reinterpret_cast<unsigned long>(this));

	}
	~SetWhenDoneOrErrorActorState() 
	{
		fdb_probe_actor_destroy("setWhenDoneOrError", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 938 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<Void> __when_expr_0 = condition;
															#line 938 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<SetWhenDoneOrErrorActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 11247 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<SetWhenDoneOrErrorActor*>(this)->actor_wait_state = 1;
															#line 938 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SetWhenDoneOrErrorActor, 0, Void >*>(static_cast<SetWhenDoneOrErrorActor*>(this)));
															#line 11252 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SetWhenDoneOrErrorActorState();
		static_cast<SetWhenDoneOrErrorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 943 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		var->set(val);
															#line 944 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<SetWhenDoneOrErrorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SetWhenDoneOrErrorActorState(); static_cast<SetWhenDoneOrErrorActor*>(this)->destroy(); return 0; }
															#line 11283 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<SetWhenDoneOrErrorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SetWhenDoneOrErrorActorState();
		static_cast<SetWhenDoneOrErrorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 940 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == error_code_actor_cancelled)
															#line 11296 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 941 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				return a_body1Catch1(e, loopDepth);
															#line 11300 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SetWhenDoneOrErrorActor*>(this)->actor_wait_state > 0) static_cast<SetWhenDoneOrErrorActor*>(this)->actor_wait_state = 0;
		static_cast<SetWhenDoneOrErrorActor*>(this)->ActorCallback< SetWhenDoneOrErrorActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SetWhenDoneOrErrorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("setWhenDoneOrError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SetWhenDoneOrErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("setWhenDoneOrError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SetWhenDoneOrErrorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("setWhenDoneOrError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SetWhenDoneOrErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("setWhenDoneOrError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SetWhenDoneOrErrorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("setWhenDoneOrError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<SetWhenDoneOrErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("setWhenDoneOrError", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> condition;
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Reference<AsyncVar<T>> var;
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	T val;
															#line 11418 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via setWhenDoneOrError()
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class SetWhenDoneOrErrorActor final : public Actor<Void>, public ActorCallback< SetWhenDoneOrErrorActor<T>, 0, Void >, public FastAllocated<SetWhenDoneOrErrorActor<T>>, public SetWhenDoneOrErrorActorState<T, SetWhenDoneOrErrorActor<T>> {
															#line 11425 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<SetWhenDoneOrErrorActor<T>>::operator new;
	using FastAllocated<SetWhenDoneOrErrorActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(17525129779670910208UL, 9719532433521336064UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< SetWhenDoneOrErrorActor<T>, 0, Void >;
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	SetWhenDoneOrErrorActor(Future<Void> const& condition,Reference<AsyncVar<T>> const& var,T const& val) 
															#line 11442 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   SetWhenDoneOrErrorActorState<T, SetWhenDoneOrErrorActor<T>>(condition, var, val),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("setWhenDoneOrError", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(867440015705595392UL, 14281962565306802176UL);
		ActorExecutionContextHelper __helper(static_cast<SetWhenDoneOrErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("setWhenDoneOrError");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("setWhenDoneOrError", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SetWhenDoneOrErrorActor<T>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> setWhenDoneOrError( Future<Void> const& condition, Reference<AsyncVar<T>> const& var, T const& val ) {
															#line 935 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new SetWhenDoneOrErrorActor<T>(condition, var, val));
															#line 11477 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 946 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 11482 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
[[nodiscard]] Future<Void> lowPriorityDelay( double const& waitTime );

#line 948 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// Delay after condition is cleared (i.e. equal to false).
// If during delay, condition changes to true, wait till condition become false again, and repeat.
															#line 11489 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
[[nodiscard]] Future<Void> delayAfterCleared( Reference<AsyncVar<bool>> const& condition, double const& time, TaskPriority const& taskID = TaskPriority::DefaultDelay );

#line 954 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// Same as delayAfterCleared, but use lowPriorityDelay.
															#line 11495 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
[[nodiscard]] Future<Void> lowPriorityDelayAfterCleared( Reference<AsyncVar<bool>> const& condition, double const& time );

#line 957 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// Similar to timeoutError, but does not throw timed_out if condition is true.
// Once condition becomes false again, reset the timer (e.g. if time is 10s, wait for 10s again before throwing
// timed_out, if condition remains to be false).
															#line 11503 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via timeoutErrorIfCleared()
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class TimeoutErrorIfClearedActor>
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TimeoutErrorIfClearedActorState {
															#line 11510 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TimeoutErrorIfClearedActorState(Future<T> const& what,Reference<AsyncVar<bool>> const& condition,double const& time,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   condition(condition),
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   time(time),
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   taskID(taskID)
															#line 11523 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this));

	}
	~TimeoutErrorIfClearedActorState() 
	{
		fdb_probe_actor_destroy("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 967 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = what;
															#line 966 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<TimeoutErrorIfClearedActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11540 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_1 = delayAfterCleared(condition, time, taskID);
															#line 11544 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1when2(__when_expr_1.get(), loopDepth); };
			static_cast<TimeoutErrorIfClearedActor*>(this)->actor_wait_state = 1;
															#line 967 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TimeoutErrorIfClearedActor, 0, T >*>(static_cast<TimeoutErrorIfClearedActor*>(this)));
															#line 970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< TimeoutErrorIfClearedActor, 1, Void >*>(static_cast<TimeoutErrorIfClearedActor*>(this)));
															#line 11551 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TimeoutErrorIfClearedActorState();
		static_cast<TimeoutErrorIfClearedActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
															#line 968 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TimeoutErrorIfClearedActor*>(this)->SAV<T>::futures) { (void)(t); this->~TimeoutErrorIfClearedActorState(); static_cast<TimeoutErrorIfClearedActor*>(this)->destroy(); return 0; }
															#line 11574 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TimeoutErrorIfClearedActor*>(this)->SAV< T >::value()) T(t);
		this->~TimeoutErrorIfClearedActorState();
		static_cast<TimeoutErrorIfClearedActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
															#line 968 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TimeoutErrorIfClearedActor*>(this)->SAV<T>::futures) { (void)(t); this->~TimeoutErrorIfClearedActorState(); static_cast<TimeoutErrorIfClearedActor*>(this)->destroy(); return 0; }
															#line 11586 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TimeoutErrorIfClearedActor*>(this)->SAV< T >::value()) T(t);
		this->~TimeoutErrorIfClearedActorState();
		static_cast<TimeoutErrorIfClearedActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when2(Void const& _,int loopDepth) 
	{
															#line 971 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(timed_out(), loopDepth);
															#line 11598 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	int a_body1when2(Void && _,int loopDepth) 
	{
															#line 971 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(timed_out(), loopDepth);
															#line 11606 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TimeoutErrorIfClearedActor*>(this)->actor_wait_state > 0) static_cast<TimeoutErrorIfClearedActor*>(this)->actor_wait_state = 0;
		static_cast<TimeoutErrorIfClearedActor*>(this)->ActorCallback< TimeoutErrorIfClearedActor, 0, T >::remove();
		static_cast<TimeoutErrorIfClearedActor*>(this)->ActorCallback< TimeoutErrorIfClearedActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TimeoutErrorIfClearedActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorIfClearedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TimeoutErrorIfClearedActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorIfClearedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TimeoutErrorIfClearedActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorIfClearedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TimeoutErrorIfClearedActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorIfClearedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< TimeoutErrorIfClearedActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorIfClearedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< TimeoutErrorIfClearedActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorIfClearedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Reference<AsyncVar<bool>> condition;
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double time;
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TaskPriority taskID;
															#line 11739 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via timeoutErrorIfCleared()
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TimeoutErrorIfClearedActor final : public Actor<T>, public ActorCallback< TimeoutErrorIfClearedActor<T>, 0, T >, public ActorCallback< TimeoutErrorIfClearedActor<T>, 1, Void >, public FastAllocated<TimeoutErrorIfClearedActor<T>>, public TimeoutErrorIfClearedActorState<T, TimeoutErrorIfClearedActor<T>> {
															#line 11746 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TimeoutErrorIfClearedActor<T>>::operator new;
	using FastAllocated<TimeoutErrorIfClearedActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(9038061705071363840UL, 4123721824761678080UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TimeoutErrorIfClearedActor<T>, 0, T >;
friend struct ActorCallback< TimeoutErrorIfClearedActor<T>, 1, Void >;
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TimeoutErrorIfClearedActor(Future<T> const& what,Reference<AsyncVar<bool>> const& condition,double const& time,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 11764 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   TimeoutErrorIfClearedActorState<T, TimeoutErrorIfClearedActor<T>>(what, condition, time, taskID),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(13766359157345727744UL, 5577040220185098496UL);
		ActorExecutionContextHelper __helper(static_cast<TimeoutErrorIfClearedActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("timeoutErrorIfCleared");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("timeoutErrorIfCleared", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TimeoutErrorIfClearedActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> timeoutErrorIfCleared( Future<T> const& what, Reference<AsyncVar<bool>> const& condition, double const& time, TaskPriority const& taskID = TaskPriority::DefaultDelay ) {
															#line 961 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new TimeoutErrorIfClearedActor<T>(what, condition, time, taskID));
															#line 11799 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 975 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

Future<bool> allTrue(const std::vector<Future<bool>>& all);
Future<Void> anyTrue(std::vector<Reference<AsyncVar<bool>>> const& input, Reference<AsyncVar<bool>> const& output);
Future<Void> cancelOnly(std::vector<Future<Void>> const& futures);
Future<Void> timeoutWarningCollector(FutureStream<Void> const& input,
                                     double const& logDelay,
                                     const char* const& context,
                                     UID const& id);
															#line 11811 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
[[nodiscard]] Future<bool> quorumEqualsTrue( std::vector<Future<bool>> const& futures, int const& required );

#line 984 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 11816 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via streamHelper()
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class StreamHelperActor>
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class StreamHelperActorState {
															#line 11823 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	StreamHelperActorState(PromiseStream<T> const& output,PromiseStream<Error> const& errors,Future<T> const& input) 
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : output(output),
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   errors(errors),
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   input(input)
															#line 11834 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("streamHelper", reinterpret_cast<unsigned long>(this));

	}
	~StreamHelperActorState() 
	{
		fdb_probe_actor_destroy("streamHelper", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = input;
															#line 988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<StreamHelperActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 11852 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<StreamHelperActor*>(this)->actor_wait_state = 1;
															#line 988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< StreamHelperActor, 0, T >*>(static_cast<StreamHelperActor*>(this)));
															#line 11857 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~StreamHelperActorState();
		static_cast<StreamHelperActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 995 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<StreamHelperActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~StreamHelperActorState(); static_cast<StreamHelperActor*>(this)->destroy(); return 0; }
															#line 11886 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<StreamHelperActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~StreamHelperActorState();
		static_cast<StreamHelperActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 991 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == error_code_actor_cancelled)
															#line 11899 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 992 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				return a_body1Catch1(e, loopDepth);
															#line 11903 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 993 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			errors.send(e);
															#line 11907 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& value,int loopDepth) 
	{
															#line 989 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(value);
															#line 11922 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(T && value,int loopDepth) 
	{
															#line 989 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(value);
															#line 11931 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1when1(T const& value,int loopDepth) 
	{
		loopDepth = a_body1cont2(value, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && value,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(value), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<StreamHelperActor*>(this)->actor_wait_state > 0) static_cast<StreamHelperActor*>(this)->actor_wait_state = 0;
		static_cast<StreamHelperActor*>(this)->ActorCallback< StreamHelperActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< StreamHelperActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("streamHelper", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<StreamHelperActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("streamHelper", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< StreamHelperActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("streamHelper", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<StreamHelperActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("streamHelper", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< StreamHelperActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("streamHelper", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<StreamHelperActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("streamHelper", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont4(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<T> output;
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<Error> errors;
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> input;
															#line 12030 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via streamHelper()
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class StreamHelperActor final : public Actor<Void>, public ActorCallback< StreamHelperActor<T>, 0, T >, public FastAllocated<StreamHelperActor<T>>, public StreamHelperActorState<T, StreamHelperActor<T>> {
															#line 12037 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<StreamHelperActor<T>>::operator new;
	using FastAllocated<StreamHelperActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(6765714548306127616UL, 3824312461769617920UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< StreamHelperActor<T>, 0, T >;
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	StreamHelperActor(PromiseStream<T> const& output,PromiseStream<Error> const& errors,Future<T> const& input) 
															#line 12054 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   StreamHelperActorState<T, StreamHelperActor<T>>(output, errors, input),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("streamHelper", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(16076362173234148352UL, 13548850868885335808UL);
		ActorExecutionContextHelper __helper(static_cast<StreamHelperActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("streamHelper");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("streamHelper", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< StreamHelperActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> streamHelper( PromiseStream<T> const& output, PromiseStream<Error> const& errors, Future<T> const& input ) {
															#line 985 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new StreamHelperActor<T>(output, errors, input));
															#line 12089 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 997 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

template <class T>
Future<Void> makeStream(const std::vector<Future<T>>& futures, PromiseStream<T>& stream, PromiseStream<Error>& errors) {
	std::vector<Future<Void>> forwarders;
	forwarders.reserve(futures.size());
	for (int f = 0; f < futures.size(); f++)
		forwarders.push_back(streamHelper(stream, errors, futures[f]));
	return cancelOnly(forwarders);
}

template <class T>
class QuorumCallback;

template <class T>
struct Quorum final : SAV<Void> {
	int antiQuorum;
	int count;

	static inline int sizeFor(int count) { return sizeof(Quorum<T>) + sizeof(QuorumCallback<T>) * count; }

	void destroy() override {
		int size = sizeFor(this->count);
		this->~Quorum();
		freeFast(size, this);
	}
	void cancel() override {
		int cancelled_callbacks = 0;
		for (int i = 0; i < count; i++)
			if (callbacks()[i].next) {
				callbacks()[i].remove();
				callbacks()[i].next = 0;
				++cancelled_callbacks;
			}
		if (canBeSet())
			sendError(actor_cancelled());
		for (int i = 0; i < cancelled_callbacks; i++)
			delPromiseRef();
	}
	explicit Quorum(int quorum, int count) : SAV<Void>(1, count), antiQuorum(count - quorum + 1), count(count) {
		if (!quorum)
			this->send(Void());
	}
	void oneSuccess() {
		if (getPromiseReferenceCount() == antiQuorum && canBeSet())
			this->sendAndDelPromiseRef(Void());
		else
			delPromiseRef();
	}
	void oneError(Error err) {
		if (canBeSet())
			this->sendErrorAndDelPromiseRef(err);
		else
			delPromiseRef();
	}

	QuorumCallback<T>* callbacks() { return (QuorumCallback<T>*)(this + 1); }
};

template <class T>
class QuorumCallback : public Callback<T> {
public:
	void fire(const T& value) override {
		Callback<T>::remove();
		Callback<T>::next = 0;
		head->oneSuccess();
	}
	void error(Error error) override {
		Callback<T>::remove();
		Callback<T>::next = 0;
		head->oneError(error);
	}

private:
	template <class U>
	friend Future<Void> quorum(const Future<U>* pItems, int itemCount, int n);
	Quorum<T>* head;
	QuorumCallback() = default;
	QuorumCallback(Future<T> future, Quorum<T>* head) : head(head) { future.addCallbackAndClear(this); }
};

template <class T>
Future<Void> quorum(const Future<T>* pItems, int itemCount, int n) {
	ASSERT(n >= 0 && n <= itemCount);

	int size = Quorum<T>::sizeFor(itemCount);
	Quorum<T>* q = new (allocateFast(size)) Quorum<T>(n, itemCount);

	QuorumCallback<T>* nextCallback = q->callbacks();
	for (int i = 0; i < itemCount; ++i) {
		auto& r = pItems[i];
		if (r.isReady()) {
			new (nextCallback) QuorumCallback<T>();
			nextCallback->next = 0;
			if (r.isError())
				q->oneError(r.getError());
			else
				q->oneSuccess();
		} else
			new (nextCallback) QuorumCallback<T>(r, q);
		++nextCallback;
	}
	return Future<Void>(q);
}

template <class T>
Future<Void> quorum(std::vector<Future<T>> const& results, int n) {
	return quorum(&results.front(), results.size(), n);
}

															#line 12202 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via smartQuorum()
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class SmartQuorumActor>
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class SmartQuorumActorState {
															#line 12209 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	SmartQuorumActorState(std::vector<Future<T>> const& results,int const& required,double const& extraSeconds,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : results(results),
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   required(required),
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   extraSeconds(extraSeconds),
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   taskID(taskID)
															#line 12222 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("smartQuorum", reinterpret_cast<unsigned long>(this));

	}
	~SmartQuorumActorState() 
	{
		fdb_probe_actor_destroy("smartQuorum", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1111 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (results.empty() && required == 0)
															#line 12237 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 1112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (!static_cast<SmartQuorumActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SmartQuorumActorState(); static_cast<SmartQuorumActor*>(this)->destroy(); return 0; }
															#line 12241 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				new (&static_cast<SmartQuorumActor*>(this)->SAV< Void >::value()) Void(Void());
				this->~SmartQuorumActorState();
				static_cast<SmartQuorumActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 1113 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = quorum(results, required);
															#line 1113 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<SmartQuorumActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 12251 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<SmartQuorumActor*>(this)->actor_wait_state = 1;
															#line 1113 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SmartQuorumActor, 0, Void >*>(static_cast<SmartQuorumActor*>(this)));
															#line 12256 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SmartQuorumActorState();
		static_cast<SmartQuorumActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1115 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_1 = quorum(results, (int)results.size());
															#line 1114 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<SmartQuorumActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 12281 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
															#line 1118 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_2 = delay(extraSeconds, taskID);
															#line 12285 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1when2(__when_expr_2.get(), loopDepth); };
		static_cast<SmartQuorumActor*>(this)->actor_wait_state = 2;
															#line 1115 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< SmartQuorumActor, 1, Void >*>(static_cast<SmartQuorumActor*>(this)));
															#line 1118 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< SmartQuorumActor, 2, Void >*>(static_cast<SmartQuorumActor*>(this)));
															#line 12292 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1115 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_1 = quorum(results, (int)results.size());
															#line 1114 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<SmartQuorumActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 12303 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
															#line 1118 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_2 = delay(extraSeconds, taskID);
															#line 12307 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1when2(__when_expr_2.get(), loopDepth); };
		static_cast<SmartQuorumActor*>(this)->actor_wait_state = 2;
															#line 1115 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< SmartQuorumActor, 1, Void >*>(static_cast<SmartQuorumActor*>(this)));
															#line 1118 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< SmartQuorumActor, 2, Void >*>(static_cast<SmartQuorumActor*>(this)));
															#line 12314 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SmartQuorumActor*>(this)->actor_wait_state > 0) static_cast<SmartQuorumActor*>(this)->actor_wait_state = 0;
		static_cast<SmartQuorumActor*>(this)->ActorCallback< SmartQuorumActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SmartQuorumActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("smartQuorum", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SmartQuorumActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("smartQuorum", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SmartQuorumActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("smartQuorum", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SmartQuorumActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("smartQuorum", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SmartQuorumActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("smartQuorum", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<SmartQuorumActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("smartQuorum", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
															#line 1116 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<SmartQuorumActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SmartQuorumActorState(); static_cast<SmartQuorumActor*>(this)->destroy(); return 0; }
															#line 12398 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<SmartQuorumActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SmartQuorumActorState();
		static_cast<SmartQuorumActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
															#line 1116 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<SmartQuorumActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SmartQuorumActorState(); static_cast<SmartQuorumActor*>(this)->destroy(); return 0; }
															#line 12410 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<SmartQuorumActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SmartQuorumActorState();
		static_cast<SmartQuorumActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when2(Void const& _,int loopDepth) 
	{
															#line 1119 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<SmartQuorumActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SmartQuorumActorState(); static_cast<SmartQuorumActor*>(this)->destroy(); return 0; }
															#line 12422 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<SmartQuorumActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SmartQuorumActorState();
		static_cast<SmartQuorumActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when2(Void && _,int loopDepth) 
	{
															#line 1119 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<SmartQuorumActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SmartQuorumActorState(); static_cast<SmartQuorumActor*>(this)->destroy(); return 0; }
															#line 12434 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<SmartQuorumActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SmartQuorumActorState();
		static_cast<SmartQuorumActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<SmartQuorumActor*>(this)->actor_wait_state > 0) static_cast<SmartQuorumActor*>(this)->actor_wait_state = 0;
		static_cast<SmartQuorumActor*>(this)->ActorCallback< SmartQuorumActor, 1, Void >::remove();
		static_cast<SmartQuorumActor*>(this)->ActorCallback< SmartQuorumActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SmartQuorumActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("smartQuorum", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SmartQuorumActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("smartQuorum", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< SmartQuorumActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("smartQuorum", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SmartQuorumActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("smartQuorum", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< SmartQuorumActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("smartQuorum", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<SmartQuorumActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("smartQuorum", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< SmartQuorumActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("smartQuorum", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SmartQuorumActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("smartQuorum", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< SmartQuorumActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("smartQuorum", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SmartQuorumActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("smartQuorum", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< SmartQuorumActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("smartQuorum", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<SmartQuorumActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("smartQuorum", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	std::vector<Future<T>> results;
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	int required;
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double extraSeconds;
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TaskPriority taskID;
															#line 12571 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via smartQuorum()
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class SmartQuorumActor final : public Actor<Void>, public ActorCallback< SmartQuorumActor<T>, 0, Void >, public ActorCallback< SmartQuorumActor<T>, 1, Void >, public ActorCallback< SmartQuorumActor<T>, 2, Void >, public FastAllocated<SmartQuorumActor<T>>, public SmartQuorumActorState<T, SmartQuorumActor<T>> {
															#line 12578 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<SmartQuorumActor<T>>::operator new;
	using FastAllocated<SmartQuorumActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(10567103787466795776UL, 8557201178373713920UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< SmartQuorumActor<T>, 0, Void >;
friend struct ActorCallback< SmartQuorumActor<T>, 1, Void >;
friend struct ActorCallback< SmartQuorumActor<T>, 2, Void >;
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	SmartQuorumActor(std::vector<Future<T>> const& results,int const& required,double const& extraSeconds,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 12597 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   SmartQuorumActorState<T, SmartQuorumActor<T>>(results, required, extraSeconds, taskID),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("smartQuorum", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(13724542587795787264UL, 12905642504240907264UL);
		ActorExecutionContextHelper __helper(static_cast<SmartQuorumActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("smartQuorum");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("smartQuorum", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SmartQuorumActor<T>, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< SmartQuorumActor<T>, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> smartQuorum( std::vector<Future<T>> const& results, int const& required, double const& extraSeconds, TaskPriority const& taskID = TaskPriority::DefaultDelay ) {
															#line 1106 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new SmartQuorumActor<T>(results, required, extraSeconds, taskID));
															#line 12633 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1123 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

template <class T>
Future<Void> waitForAll(std::vector<Future<T>> const& results) {
	if (results.empty())
		return Void();
	return quorum(results, (int)results.size());
}

// Wait for all futures in results to be ready and then throw the first (in execution order) error
// if any of them resulted in an error.
template <class T>
Future<Void> waitForAllReadyThenThrow(std::vector<Future<T>> const& results) {
	Future<Void> f = waitForAll(results);
	Future<Void> fReady = waitForAllReady(results);
	return fReady + f;
}

template <class T>
Future<Void> waitForAny(std::vector<Future<T>> const& results) {
	if (results.empty())
		return Void();
	return quorum(results, 1);
}

															#line 12661 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
[[nodiscard]] Future<Void> waitForMost( std::vector<Future<ErrorOr<Void>>> const& futures, int const& faultTolerance, Error const& e, double const& waitMultiplierForSlowFutures = 1.0 );

#line 1151 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 12666 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
[[nodiscard]] Future<bool> shortCircuitAny( std::vector<Future<bool>> const& f );

#line 1153 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 12671 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via getAll()
															#line 1154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class GetAllActor>
															#line 1154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class GetAllActorState {
															#line 12678 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	GetAllActorState(std::vector<Future<T>> const& input) 
															#line 1154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : input(input)
															#line 12685 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("getAll", reinterpret_cast<unsigned long>(this));

	}
	~GetAllActorState() 
	{
		fdb_probe_actor_destroy("getAll", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1156 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (input.empty())
															#line 12700 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 1157 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (!static_cast<GetAllActor*>(this)->SAV<std::vector<T>>::futures) { (void)(std::vector<T>()); this->~GetAllActorState(); static_cast<GetAllActor*>(this)->destroy(); return 0; }
															#line 12704 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				new (&static_cast<GetAllActor*>(this)->SAV< std::vector<T> >::value()) std::vector<T>(std::vector<T>());
				this->~GetAllActorState();
				static_cast<GetAllActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 1158 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = quorum(input, input.size());
															#line 1158 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<GetAllActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 12714 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetAllActor*>(this)->actor_wait_state = 1;
															#line 1158 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetAllActor, 0, Void >*>(static_cast<GetAllActor*>(this)));
															#line 12719 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetAllActorState();
		static_cast<GetAllActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		std::vector<T> output;
															#line 1161 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.reserve(input.size());
															#line 1162 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		for(int i = 0;i < input.size();i++) {
															#line 1163 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output.push_back(input[i].get());
															#line 12748 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 1164 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<GetAllActor*>(this)->SAV<std::vector<T>>::futures) { (void)(output); this->~GetAllActorState(); static_cast<GetAllActor*>(this)->destroy(); return 0; }
															#line 12752 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<GetAllActor*>(this)->SAV< std::vector<T> >::value()) std::vector<T>(output);
		this->~GetAllActorState();
		static_cast<GetAllActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		std::vector<T> output;
															#line 1161 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.reserve(input.size());
															#line 1162 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		for(int i = 0;i < input.size();i++) {
															#line 1163 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output.push_back(input[i].get());
															#line 12770 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 1164 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<GetAllActor*>(this)->SAV<std::vector<T>>::futures) { (void)(output); this->~GetAllActorState(); static_cast<GetAllActor*>(this)->destroy(); return 0; }
															#line 12774 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<GetAllActor*>(this)->SAV< std::vector<T> >::value()) std::vector<T>(output);
		this->~GetAllActorState();
		static_cast<GetAllActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetAllActor*>(this)->actor_wait_state > 0) static_cast<GetAllActor*>(this)->actor_wait_state = 0;
		static_cast<GetAllActor*>(this)->ActorCallback< GetAllActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetAllActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getAll", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<GetAllActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAll", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetAllActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getAll", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<GetAllActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAll", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetAllActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getAll", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<GetAllActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAll", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	std::vector<Future<T>> input;
															#line 12859 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via getAll()
															#line 1154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class GetAllActor final : public Actor<std::vector<T>>, public ActorCallback< GetAllActor<T>, 0, Void >, public FastAllocated<GetAllActor<T>>, public GetAllActorState<T, GetAllActor<T>> {
															#line 12866 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<GetAllActor<T>>::operator new;
	using FastAllocated<GetAllActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(17900410442741106688UL, 16567497584790014464UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<std::vector<T>>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< GetAllActor<T>, 0, Void >;
															#line 1154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	GetAllActor(std::vector<Future<T>> const& input) 
															#line 12883 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<std::vector<T>>(),
		   GetAllActorState<T, GetAllActor<T>>(input),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("getAll", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(16361995107014370816UL, 2714745357278614528UL);
		ActorExecutionContextHelper __helper(static_cast<GetAllActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getAll");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getAll", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetAllActor<T>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<std::vector<T>> getAll( std::vector<Future<T>> const& input ) {
															#line 1154 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<std::vector<T>>(new GetAllActor<T>(input));
															#line 12918 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1166 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 12923 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via appendAll()
															#line 1167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class AppendAllActor>
															#line 1167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class AppendAllActorState {
															#line 12930 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	AppendAllActorState(std::vector<Future<std::vector<T>>> const& input) 
															#line 1167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : input(input)
															#line 12937 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("appendAll", reinterpret_cast<unsigned long>(this));

	}
	~AppendAllActorState() 
	{
		fdb_probe_actor_destroy("appendAll", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1169 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = quorum(input, input.size());
															#line 1169 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<AppendAllActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 12954 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AppendAllActor*>(this)->actor_wait_state = 1;
															#line 1169 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AppendAllActor, 0, Void >*>(static_cast<AppendAllActor*>(this)));
															#line 12959 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AppendAllActorState();
		static_cast<AppendAllActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1171 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		std::vector<T> output;
															#line 1172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		size_t sz = 0;
															#line 1173 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		for( const auto& f : input ) {
															#line 1174 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			sz += f.get().size();
															#line 12988 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 1176 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.reserve(sz);
															#line 1178 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		for(int i = 0;i < input.size();i++) {
															#line 1179 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			auto const& r = input[i].get();
															#line 1180 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output.insert(output.end(), r.begin(), r.end());
															#line 12998 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 1182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<AppendAllActor*>(this)->SAV<std::vector<T>>::futures) { (void)(output); this->~AppendAllActorState(); static_cast<AppendAllActor*>(this)->destroy(); return 0; }
															#line 13002 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<AppendAllActor*>(this)->SAV< std::vector<T> >::value()) std::vector<T>(output);
		this->~AppendAllActorState();
		static_cast<AppendAllActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1171 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		std::vector<T> output;
															#line 1172 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		size_t sz = 0;
															#line 1173 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		for( const auto& f : input ) {
															#line 1174 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			sz += f.get().size();
															#line 13020 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 1176 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.reserve(sz);
															#line 1178 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		for(int i = 0;i < input.size();i++) {
															#line 1179 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			auto const& r = input[i].get();
															#line 1180 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output.insert(output.end(), r.begin(), r.end());
															#line 13030 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 1182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<AppendAllActor*>(this)->SAV<std::vector<T>>::futures) { (void)(output); this->~AppendAllActorState(); static_cast<AppendAllActor*>(this)->destroy(); return 0; }
															#line 13034 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<AppendAllActor*>(this)->SAV< std::vector<T> >::value()) std::vector<T>(output);
		this->~AppendAllActorState();
		static_cast<AppendAllActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AppendAllActor*>(this)->actor_wait_state > 0) static_cast<AppendAllActor*>(this)->actor_wait_state = 0;
		static_cast<AppendAllActor*>(this)->ActorCallback< AppendAllActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AppendAllActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("appendAll", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<AppendAllActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("appendAll", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AppendAllActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("appendAll", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<AppendAllActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("appendAll", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AppendAllActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("appendAll", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<AppendAllActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("appendAll", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	std::vector<Future<std::vector<T>>> input;
															#line 13119 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via appendAll()
															#line 1167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class AppendAllActor final : public Actor<std::vector<T>>, public ActorCallback< AppendAllActor<T>, 0, Void >, public FastAllocated<AppendAllActor<T>>, public AppendAllActorState<T, AppendAllActor<T>> {
															#line 13126 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<AppendAllActor<T>>::operator new;
	using FastAllocated<AppendAllActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(244919361871593984UL, 16468825918584646400UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<std::vector<T>>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< AppendAllActor<T>, 0, Void >;
															#line 1167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	AppendAllActor(std::vector<Future<std::vector<T>>> const& input) 
															#line 13143 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<std::vector<T>>(),
		   AppendAllActorState<T, AppendAllActor<T>>(input),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("appendAll", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(12820898808668760320UL, 11580523994196116992UL);
		ActorExecutionContextHelper __helper(static_cast<AppendAllActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("appendAll");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("appendAll", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AppendAllActor<T>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<std::vector<T>> appendAll( std::vector<Future<std::vector<T>>> const& input ) {
															#line 1167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<std::vector<T>>(new AppendAllActor<T>(input));
															#line 13178 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1184 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 13183 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via onEqual()
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class OnEqualActor>
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class OnEqualActorState {
															#line 13190 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	OnEqualActorState(Future<T> const& in,T const& equalTo) 
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : in(in),
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   equalTo(equalTo)
															#line 13199 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("onEqual", reinterpret_cast<unsigned long>(this));

	}
	~OnEqualActorState() 
	{
		fdb_probe_actor_destroy("onEqual", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1187 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = in;
															#line 1187 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<OnEqualActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 13216 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<OnEqualActor*>(this)->actor_wait_state = 1;
															#line 1187 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< OnEqualActor, 0, T >*>(static_cast<OnEqualActor*>(this)));
															#line 13221 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~OnEqualActorState();
		static_cast<OnEqualActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T const& t,int loopDepth) 
	{
															#line 1188 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (t == equalTo)
															#line 13244 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 1189 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (!static_cast<OnEqualActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~OnEqualActorState(); static_cast<OnEqualActor*>(this)->destroy(); return 0; }
															#line 13248 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			new (&static_cast<OnEqualActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~OnEqualActorState();
			static_cast<OnEqualActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1190 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_1 = Never();
															#line 1190 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<OnEqualActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 13258 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<OnEqualActor*>(this)->actor_wait_state = 2;
															#line 1190 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< OnEqualActor, 1, Void >*>(static_cast<OnEqualActor*>(this)));
															#line 13263 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T && t,int loopDepth) 
	{
															#line 1188 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (t == equalTo)
															#line 13272 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 1189 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (!static_cast<OnEqualActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~OnEqualActorState(); static_cast<OnEqualActor*>(this)->destroy(); return 0; }
															#line 13276 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			new (&static_cast<OnEqualActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~OnEqualActorState();
			static_cast<OnEqualActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1190 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_1 = Never();
															#line 1190 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<OnEqualActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 13286 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<OnEqualActor*>(this)->actor_wait_state = 2;
															#line 1190 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< OnEqualActor, 1, Void >*>(static_cast<OnEqualActor*>(this)));
															#line 13291 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
		loopDepth = a_body1cont1(t, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(t), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<OnEqualActor*>(this)->actor_wait_state > 0) static_cast<OnEqualActor*>(this)->actor_wait_state = 0;
		static_cast<OnEqualActor*>(this)->ActorCallback< OnEqualActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< OnEqualActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("onEqual", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<OnEqualActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("onEqual", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< OnEqualActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("onEqual", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<OnEqualActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("onEqual", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< OnEqualActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("onEqual", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<OnEqualActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("onEqual", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 1191 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(internal_error(), loopDepth);
															#line 13375 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 1191 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(internal_error(), loopDepth);
															#line 13383 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<OnEqualActor*>(this)->actor_wait_state > 0) static_cast<OnEqualActor*>(this)->actor_wait_state = 0;
		static_cast<OnEqualActor*>(this)->ActorCallback< OnEqualActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< OnEqualActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("onEqual", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<OnEqualActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("onEqual", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< OnEqualActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("onEqual", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<OnEqualActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("onEqual", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< OnEqualActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("onEqual", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<OnEqualActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("onEqual", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> in;
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	T equalTo;
															#line 13466 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via onEqual()
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class OnEqualActor final : public Actor<Void>, public ActorCallback< OnEqualActor<T>, 0, T >, public ActorCallback< OnEqualActor<T>, 1, Void >, public FastAllocated<OnEqualActor<T>>, public OnEqualActorState<T, OnEqualActor<T>> {
															#line 13473 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<OnEqualActor<T>>::operator new;
	using FastAllocated<OnEqualActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(8796814662668813568UL, 2007914377992944640UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< OnEqualActor<T>, 0, T >;
friend struct ActorCallback< OnEqualActor<T>, 1, Void >;
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	OnEqualActor(Future<T> const& in,T const& equalTo) 
															#line 13491 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   OnEqualActorState<T, OnEqualActor<T>>(in, equalTo),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("onEqual", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(16353451186205296128UL, 1171592687792352512UL);
		ActorExecutionContextHelper __helper(static_cast<OnEqualActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("onEqual");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("onEqual", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< OnEqualActor<T>, 0, T >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< OnEqualActor<T>, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> onEqual( Future<T> const& in, T const& equalTo ) {
															#line 1185 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new OnEqualActor<T>(in, equalTo));
															#line 13527 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1193 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 13532 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via success()
															#line 1194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class SuccessActor>
															#line 1194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class SuccessActorState {
															#line 13539 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	SuccessActorState(Future<T> const& of) 
															#line 1194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : of(of)
															#line 13546 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("success", reinterpret_cast<unsigned long>(this));

	}
	~SuccessActorState() 
	{
		fdb_probe_actor_destroy("success", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1196 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = of;
															#line 1196 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<SuccessActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 13563 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<SuccessActor*>(this)->actor_wait_state = 1;
															#line 1196 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SuccessActor, 0, T >*>(static_cast<SuccessActor*>(this)));
															#line 13568 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SuccessActorState();
		static_cast<SuccessActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T const& t,int loopDepth) 
	{
															#line 1197 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		(void)t;
															#line 1198 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<SuccessActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SuccessActorState(); static_cast<SuccessActor*>(this)->destroy(); return 0; }
															#line 13593 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<SuccessActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SuccessActorState();
		static_cast<SuccessActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(T && t,int loopDepth) 
	{
															#line 1197 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		(void)t;
															#line 1198 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<SuccessActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SuccessActorState(); static_cast<SuccessActor*>(this)->destroy(); return 0; }
															#line 13607 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<SuccessActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SuccessActorState();
		static_cast<SuccessActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
		loopDepth = a_body1cont1(t, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(t), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SuccessActor*>(this)->actor_wait_state > 0) static_cast<SuccessActor*>(this)->actor_wait_state = 0;
		static_cast<SuccessActor*>(this)->ActorCallback< SuccessActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< SuccessActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("success", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SuccessActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("success", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SuccessActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("success", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SuccessActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("success", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SuccessActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("success", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<SuccessActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("success", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> of;
															#line 13692 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via success()
															#line 1194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class SuccessActor final : public Actor<Void>, public ActorCallback< SuccessActor<T>, 0, T >, public FastAllocated<SuccessActor<T>>, public SuccessActorState<T, SuccessActor<T>> {
															#line 13699 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<SuccessActor<T>>::operator new;
	using FastAllocated<SuccessActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(12916803308625186048UL, 16997012616017709824UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< SuccessActor<T>, 0, T >;
															#line 1194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	SuccessActor(Future<T> const& of) 
															#line 13716 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   SuccessActorState<T, SuccessActor<T>>(of),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("success", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(16758655978909564416UL, 7854398836592254464UL);
		ActorExecutionContextHelper __helper(static_cast<SuccessActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("success");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("success", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SuccessActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> success( Future<T> const& of ) {
															#line 1194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new SuccessActor<T>(of));
															#line 13751 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1200 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 13756 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via ready()
															#line 1201 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class ReadyActor>
															#line 1201 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ReadyActorState {
															#line 13763 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1201 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ReadyActorState(Future<T> const& f) 
															#line 1201 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1201 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : f(f)
															#line 13770 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("ready", reinterpret_cast<unsigned long>(this));

	}
	~ReadyActorState() 
	{
		fdb_probe_actor_destroy("ready", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 1204 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = f;
															#line 1204 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<ReadyActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 13788 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<ReadyActor*>(this)->actor_wait_state = 1;
															#line 1204 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ReadyActor, 0, T >*>(static_cast<ReadyActor*>(this)));
															#line 13793 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ReadyActorState();
		static_cast<ReadyActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 1208 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ReadyActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~ReadyActorState(); static_cast<ReadyActor*>(this)->destroy(); return 0; }
															#line 13822 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ReadyActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~ReadyActorState();
		static_cast<ReadyActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& __current_error,int loopDepth=0) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& t,int loopDepth) 
	{
															#line 1205 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		(void)t;
															#line 13847 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(T && t,int loopDepth) 
	{
															#line 1205 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		(void)t;
															#line 13856 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
		loopDepth = a_body1cont2(t, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(t), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ReadyActor*>(this)->actor_wait_state > 0) static_cast<ReadyActor*>(this)->actor_wait_state = 0;
		static_cast<ReadyActor*>(this)->ActorCallback< ReadyActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< ReadyActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("ready", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ReadyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("ready", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ReadyActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("ready", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ReadyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("ready", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ReadyActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("ready", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ReadyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("ready", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont4(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
															#line 1201 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> f;
															#line 13951 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via ready()
															#line 1201 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1201 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ReadyActor final : public Actor<Void>, public ActorCallback< ReadyActor<T>, 0, T >, public FastAllocated<ReadyActor<T>>, public ReadyActorState<T, ReadyActor<T>> {
															#line 13958 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<ReadyActor<T>>::operator new;
	using FastAllocated<ReadyActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(11526727741891128320UL, 16537090152861412864UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< ReadyActor<T>, 0, T >;
															#line 1201 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ReadyActor(Future<T> const& f) 
															#line 13975 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   ReadyActorState<T, ReadyActor<T>>(f),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("ready", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(6752898665744590080UL, 7355650981969264640UL);
		ActorExecutionContextHelper __helper(static_cast<ReadyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("ready");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("ready", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ReadyActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1201 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1201 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> ready( Future<T> const& f ) {
															#line 1201 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new ReadyActor<T>(f));
															#line 14010 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1210 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 14015 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via waitAndForward()
															#line 1211 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class WaitAndForwardActor>
															#line 1211 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class WaitAndForwardActorState {
															#line 14022 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1211 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	WaitAndForwardActorState(FutureStream<T> const& input) 
															#line 1211 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1211 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : input(input)
															#line 14029 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("waitAndForward", reinterpret_cast<unsigned long>(this));

	}
	~WaitAndForwardActorState() 
	{
		fdb_probe_actor_destroy("waitAndForward", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			FutureStream<T> __when_expr_0 = input;
															#line 1213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<WaitAndForwardActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 14046 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.pop(), loopDepth); };
			static_cast<WaitAndForwardActor*>(this)->actor_wait_state = 1;
															#line 1213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< WaitAndForwardActor, 0, T >*>(static_cast<WaitAndForwardActor*>(this)));
															#line 14051 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WaitAndForwardActorState();
		static_cast<WaitAndForwardActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T const& output,int loopDepth) 
	{
															#line 1214 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<WaitAndForwardActor*>(this)->SAV<T>::futures) { (void)(output); this->~WaitAndForwardActorState(); static_cast<WaitAndForwardActor*>(this)->destroy(); return 0; }
															#line 14074 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<WaitAndForwardActor*>(this)->SAV< T >::value()) T(output);
		this->~WaitAndForwardActorState();
		static_cast<WaitAndForwardActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(T && output,int loopDepth) 
	{
															#line 1214 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<WaitAndForwardActor*>(this)->SAV<T>::futures) { (void)(output); this->~WaitAndForwardActorState(); static_cast<WaitAndForwardActor*>(this)->destroy(); return 0; }
															#line 14086 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<WaitAndForwardActor*>(this)->SAV< T >::value()) T(output);
		this->~WaitAndForwardActorState();
		static_cast<WaitAndForwardActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& output,int loopDepth) 
	{
		loopDepth = a_body1cont1(output, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && output,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(output), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WaitAndForwardActor*>(this)->actor_wait_state > 0) static_cast<WaitAndForwardActor*>(this)->actor_wait_state = 0;
		static_cast<WaitAndForwardActor*>(this)->ActorSingleCallback< WaitAndForwardActor, 0, T >::remove();

	}
	void a_callback_fire(ActorSingleCallback< WaitAndForwardActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("waitAndForward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<WaitAndForwardActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitAndForward", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< WaitAndForwardActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("waitAndForward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<WaitAndForwardActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitAndForward", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< WaitAndForwardActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("waitAndForward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<WaitAndForwardActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitAndForward", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1211 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FutureStream<T> input;
															#line 14171 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via waitAndForward()
															#line 1211 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1211 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class WaitAndForwardActor final : public Actor<T>, public ActorSingleCallback< WaitAndForwardActor<T>, 0, T >, public FastAllocated<WaitAndForwardActor<T>>, public WaitAndForwardActorState<T, WaitAndForwardActor<T>> {
															#line 14178 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<WaitAndForwardActor<T>>::operator new;
	using FastAllocated<WaitAndForwardActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(2222108237229604864UL, 7329753934858054656UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< WaitAndForwardActor<T>, 0, T >;
															#line 1211 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	WaitAndForwardActor(FutureStream<T> const& input) 
															#line 14195 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   WaitAndForwardActorState<T, WaitAndForwardActor<T>>(input),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("waitAndForward", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(15555080135405258752UL, 15302585867342871040UL);
		ActorExecutionContextHelper __helper(static_cast<WaitAndForwardActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("waitAndForward");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("waitAndForward", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< WaitAndForwardActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1211 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1211 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> waitAndForward( FutureStream<T> const& input ) {
															#line 1211 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new WaitAndForwardActor<T>(input));
															#line 14230 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1216 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 14235 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via reportErrorsExcept()
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class ReportErrorsExceptActor>
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ReportErrorsExceptActorState {
															#line 14242 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ReportErrorsExceptActorState(Future<T> const& in,const char* const& context,UID const& id,std::set<int> const* const& pExceptErrors) 
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : in(in),
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   context(context),
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   id(id),
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   pExceptErrors(pExceptErrors)
															#line 14255 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("reportErrorsExcept", reinterpret_cast<unsigned long>(this));

	}
	~ReportErrorsExceptActorState() 
	{
		fdb_probe_actor_destroy("reportErrorsExcept", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 1220 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = in;
															#line 1220 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<ReportErrorsExceptActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 14273 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<ReportErrorsExceptActor*>(this)->actor_wait_state = 1;
															#line 1220 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ReportErrorsExceptActor, 0, T >*>(static_cast<ReportErrorsExceptActor*>(this)));
															#line 14278 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ReportErrorsExceptActorState();
		static_cast<ReportErrorsExceptActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1223 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() != error_code_actor_cancelled && (!pExceptErrors || !pExceptErrors->count(e.code())))
															#line 14308 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 1224 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				TraceEvent(SevError, context, id).error(e);
															#line 14312 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 1225 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(e, loopDepth);
															#line 14316 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& t,int loopDepth) 
	{
															#line 1221 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ReportErrorsExceptActor*>(this)->SAV<T>::futures) { (void)(t); this->~ReportErrorsExceptActorState(); static_cast<ReportErrorsExceptActor*>(this)->destroy(); return 0; }
															#line 14330 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ReportErrorsExceptActor*>(this)->SAV< T >::value()) T(t);
		this->~ReportErrorsExceptActorState();
		static_cast<ReportErrorsExceptActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(T && t,int loopDepth) 
	{
															#line 1221 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ReportErrorsExceptActor*>(this)->SAV<T>::futures) { (void)(t); this->~ReportErrorsExceptActorState(); static_cast<ReportErrorsExceptActor*>(this)->destroy(); return 0; }
															#line 14342 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ReportErrorsExceptActor*>(this)->SAV< T >::value()) T(t);
		this->~ReportErrorsExceptActorState();
		static_cast<ReportErrorsExceptActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
		loopDepth = a_body1cont2(t, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(t), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ReportErrorsExceptActor*>(this)->actor_wait_state > 0) static_cast<ReportErrorsExceptActor*>(this)->actor_wait_state = 0;
		static_cast<ReportErrorsExceptActor*>(this)->ActorCallback< ReportErrorsExceptActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< ReportErrorsExceptActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("reportErrorsExcept", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ReportErrorsExceptActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("reportErrorsExcept", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ReportErrorsExceptActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("reportErrorsExcept", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ReportErrorsExceptActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("reportErrorsExcept", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ReportErrorsExceptActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("reportErrorsExcept", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ReportErrorsExceptActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("reportErrorsExcept", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> in;
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	const char* context;
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	UID id;
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	std::set<int> const* pExceptErrors;
															#line 14433 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via reportErrorsExcept()
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ReportErrorsExceptActor final : public Actor<T>, public ActorCallback< ReportErrorsExceptActor<T>, 0, T >, public FastAllocated<ReportErrorsExceptActor<T>>, public ReportErrorsExceptActorState<T, ReportErrorsExceptActor<T>> {
															#line 14440 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<ReportErrorsExceptActor<T>>::operator new;
	using FastAllocated<ReportErrorsExceptActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(10607721151234961664UL, 12787256326594699264UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< ReportErrorsExceptActor<T>, 0, T >;
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ReportErrorsExceptActor(Future<T> const& in,const char* const& context,UID const& id,std::set<int> const* const& pExceptErrors) 
															#line 14457 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   ReportErrorsExceptActorState<T, ReportErrorsExceptActor<T>>(in, context, id, pExceptErrors),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("reportErrorsExcept", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(12609635902940358912UL, 5678186634594409472UL);
		ActorExecutionContextHelper __helper(static_cast<ReportErrorsExceptActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("reportErrorsExcept");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("reportErrorsExcept", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ReportErrorsExceptActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> reportErrorsExcept( Future<T> const& in, const char* const& context, UID const& id, std::set<int> const* const& pExceptErrors ) {
															#line 1217 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new ReportErrorsExceptActor<T>(in, context, id, pExceptErrors));
															#line 14492 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1228 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

template <class T>
Future<T> reportErrors(Future<T> const& in, const char* context, UID id = UID()) {
	return reportErrorsExcept(in, context, id, nullptr);
}

															#line 14502 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via require()
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class RequireActor>
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class RequireActorState {
															#line 14509 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	RequireActorState(Future<Optional<T>> const& in,int const& errorCode) 
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : in(in),
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   errorCode(errorCode)
															#line 14518 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("require", reinterpret_cast<unsigned long>(this));

	}
	~RequireActorState() 
	{
		fdb_probe_actor_destroy("require", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1236 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Optional<T>> __when_expr_0 = in;
															#line 1236 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<RequireActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 14535 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<RequireActor*>(this)->actor_wait_state = 1;
															#line 1236 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< RequireActor, 0, Optional<T> >*>(static_cast<RequireActor*>(this)));
															#line 14540 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~RequireActorState();
		static_cast<RequireActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Optional<T> const& o,int loopDepth) 
	{
															#line 1237 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (o.present())
															#line 14563 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 1238 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (!static_cast<RequireActor*>(this)->SAV<T>::futures) { (void)(o.get()); this->~RequireActorState(); static_cast<RequireActor*>(this)->destroy(); return 0; }
															#line 14567 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			new (&static_cast<RequireActor*>(this)->SAV< T >::value()) T(o.get());
			this->~RequireActorState();
			static_cast<RequireActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		else
		{
															#line 1240 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(Error(errorCode), loopDepth);
															#line 14577 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}

		return loopDepth;
	}
	int a_body1cont1(Optional<T> && o,int loopDepth) 
	{
															#line 1237 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (o.present())
															#line 14586 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 1238 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (!static_cast<RequireActor*>(this)->SAV<T>::futures) { (void)(o.get()); this->~RequireActorState(); static_cast<RequireActor*>(this)->destroy(); return 0; }
															#line 14590 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			new (&static_cast<RequireActor*>(this)->SAV< T >::value()) T(o.get());
			this->~RequireActorState();
			static_cast<RequireActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		else
		{
															#line 1240 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(Error(errorCode), loopDepth);
															#line 14600 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}

		return loopDepth;
	}
	int a_body1when1(Optional<T> const& o,int loopDepth) 
	{
		loopDepth = a_body1cont1(o, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Optional<T> && o,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(o), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<RequireActor*>(this)->actor_wait_state > 0) static_cast<RequireActor*>(this)->actor_wait_state = 0;
		static_cast<RequireActor*>(this)->ActorCallback< RequireActor, 0, Optional<T> >::remove();

	}
	void a_callback_fire(ActorCallback< RequireActor, 0, Optional<T> >*,Optional<T> const& value) 
	{
		fdb_probe_actor_enter("require", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RequireActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("require", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< RequireActor, 0, Optional<T> >*,Optional<T> && value) 
	{
		fdb_probe_actor_enter("require", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RequireActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("require", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< RequireActor, 0, Optional<T> >*,Error err) 
	{
		fdb_probe_actor_enter("require", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<RequireActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("require", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Optional<T>> in;
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	int errorCode;
															#line 14684 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via require()
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class RequireActor final : public Actor<T>, public ActorCallback< RequireActor<T>, 0, Optional<T> >, public FastAllocated<RequireActor<T>>, public RequireActorState<T, RequireActor<T>> {
															#line 14691 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<RequireActor<T>>::operator new;
	using FastAllocated<RequireActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(5889146486348132352UL, 13808044148572077056UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< RequireActor<T>, 0, Optional<T> >;
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	RequireActor(Future<Optional<T>> const& in,int const& errorCode) 
															#line 14708 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   RequireActorState<T, RequireActor<T>>(in, errorCode),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("require", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(3343251532829389312UL, 5021012167124320256UL);
		ActorExecutionContextHelper __helper(static_cast<RequireActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("require");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("require", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< RequireActor<T>, 0, Optional<T> >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> require( Future<Optional<T>> const& in, int const& errorCode ) {
															#line 1234 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new RequireActor<T>(in, errorCode));
															#line 14743 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1243 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 14748 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via waitForFirst()
															#line 1244 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class WaitForFirstActor>
															#line 1244 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class WaitForFirstActorState {
															#line 14755 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1244 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	WaitForFirstActorState(std::vector<Future<T>> const& items) 
															#line 1244 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1244 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : items(items),
															#line 1246 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   resultStream(),
															#line 1247 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   errorStream(),
															#line 1249 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   forCancellation(makeStream(items, resultStream, errorStream)),
															#line 1251 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   resultFutureStream(resultStream.getFuture()),
															#line 1252 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   errorFutureStream(errorStream.getFuture())
															#line 14772 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("waitForFirst", reinterpret_cast<unsigned long>(this));

	}
	~WaitForFirstActorState() 
	{
		fdb_probe_actor_destroy("waitForFirst", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1255 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			FutureStream<T> __when_expr_0 = resultFutureStream;
															#line 1254 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<WaitForFirstActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 14789 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.pop(), loopDepth); };
															#line 1259 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			FutureStream<Error> __when_expr_1 = errorFutureStream;
															#line 14793 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1when2(__when_expr_1.pop(), loopDepth); };
			static_cast<WaitForFirstActor*>(this)->actor_wait_state = 1;
															#line 1255 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< WaitForFirstActor, 0, T >*>(static_cast<WaitForFirstActor*>(this)));
															#line 1259 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_1.addCallbackAndClear(static_cast<ActorSingleCallback< WaitForFirstActor, 1, Error >*>(static_cast<WaitForFirstActor*>(this)));
															#line 14800 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WaitForFirstActorState();
		static_cast<WaitForFirstActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(T const& val,int loopDepth) 
	{
															#line 1256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		forCancellation = Future<Void>();
															#line 1257 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<WaitForFirstActor*>(this)->SAV<T>::futures) { (void)(val); this->~WaitForFirstActorState(); static_cast<WaitForFirstActor*>(this)->destroy(); return 0; }
															#line 14825 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<WaitForFirstActor*>(this)->SAV< T >::value()) T(val);
		this->~WaitForFirstActorState();
		static_cast<WaitForFirstActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T && val,int loopDepth) 
	{
															#line 1256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		forCancellation = Future<Void>();
															#line 1257 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<WaitForFirstActor*>(this)->SAV<T>::futures) { (void)(val); this->~WaitForFirstActorState(); static_cast<WaitForFirstActor*>(this)->destroy(); return 0; }
															#line 14839 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<WaitForFirstActor*>(this)->SAV< T >::value()) T(val);
		this->~WaitForFirstActorState();
		static_cast<WaitForFirstActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when2(Error const& e,int loopDepth) 
	{
															#line 1260 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		forCancellation = Future<Void>();
															#line 1261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(e, loopDepth);
															#line 14853 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	int a_body1when2(Error && e,int loopDepth) 
	{
															#line 1260 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		forCancellation = Future<Void>();
															#line 1261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(e, loopDepth);
															#line 14863 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WaitForFirstActor*>(this)->actor_wait_state > 0) static_cast<WaitForFirstActor*>(this)->actor_wait_state = 0;
		static_cast<WaitForFirstActor*>(this)->ActorSingleCallback< WaitForFirstActor, 0, T >::remove();
		static_cast<WaitForFirstActor*>(this)->ActorSingleCallback< WaitForFirstActor, 1, Error >::remove();

	}
	void a_callback_fire(ActorSingleCallback< WaitForFirstActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("waitForFirst", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<WaitForFirstActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForFirst", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< WaitForFirstActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("waitForFirst", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<WaitForFirstActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForFirst", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< WaitForFirstActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("waitForFirst", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<WaitForFirstActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForFirst", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< WaitForFirstActor, 1, Error >*,Error const& value) 
	{
		fdb_probe_actor_enter("waitForFirst", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<WaitForFirstActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForFirst", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorSingleCallback< WaitForFirstActor, 1, Error >*,Error && value) 
	{
		fdb_probe_actor_enter("waitForFirst", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<WaitForFirstActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForFirst", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorSingleCallback< WaitForFirstActor, 1, Error >*,Error err) 
	{
		fdb_probe_actor_enter("waitForFirst", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<WaitForFirstActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForFirst", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1244 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	std::vector<Future<T>> items;
															#line 1246 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<T> resultStream;
															#line 1247 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<Error> errorStream;
															#line 1249 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> forCancellation;
															#line 1251 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FutureStream<T> resultFutureStream;
															#line 1252 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FutureStream<Error> errorFutureStream;
															#line 15000 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via waitForFirst()
															#line 1244 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1244 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class WaitForFirstActor final : public Actor<T>, public ActorSingleCallback< WaitForFirstActor<T>, 0, T >, public ActorSingleCallback< WaitForFirstActor<T>, 1, Error >, public FastAllocated<WaitForFirstActor<T>>, public WaitForFirstActorState<T, WaitForFirstActor<T>> {
															#line 15007 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<WaitForFirstActor<T>>::operator new;
	using FastAllocated<WaitForFirstActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(18099232947796915200UL, 2450082993075770624UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< WaitForFirstActor<T>, 0, T >;
friend struct ActorSingleCallback< WaitForFirstActor<T>, 1, Error >;
															#line 1244 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	WaitForFirstActor(std::vector<Future<T>> const& items) 
															#line 15025 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   WaitForFirstActorState<T, WaitForFirstActor<T>>(items),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("waitForFirst", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(14058904249989961216UL, 7523893242501514752UL);
		ActorExecutionContextHelper __helper(static_cast<WaitForFirstActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("waitForFirst");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("waitForFirst", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< WaitForFirstActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1244 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1244 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> waitForFirst( std::vector<Future<T>> const& items ) {
															#line 1244 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new WaitForFirstActor<T>(items));
															#line 15060 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1265 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 15065 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via tag()
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class TagActor>
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagActorState {
															#line 15072 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagActorState(Future<Void> const& future,T const& what) 
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : future(future),
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   what(what)
															#line 15081 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("tag", reinterpret_cast<unsigned long>(this));

	}
	~TagActorState() 
	{
		fdb_probe_actor_destroy("tag", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1268 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = future;
															#line 1268 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<TagActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 15098 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<TagActor*>(this)->actor_wait_state = 1;
															#line 1268 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TagActor, 0, Void >*>(static_cast<TagActor*>(this)));
															#line 15103 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TagActorState();
		static_cast<TagActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1269 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TagActor*>(this)->SAV<T>::futures) { (void)(what); this->~TagActorState(); static_cast<TagActor*>(this)->destroy(); return 0; }
															#line 15126 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TagActor*>(this)->SAV< T >::value()) T(std::move(what)); // state_var_RVO
		this->~TagActorState();
		static_cast<TagActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1269 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TagActor*>(this)->SAV<T>::futures) { (void)(what); this->~TagActorState(); static_cast<TagActor*>(this)->destroy(); return 0; }
															#line 15138 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TagActor*>(this)->SAV< T >::value()) T(std::move(what)); // state_var_RVO
		this->~TagActorState();
		static_cast<TagActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TagActor*>(this)->actor_wait_state > 0) static_cast<TagActor*>(this)->actor_wait_state = 0;
		static_cast<TagActor*>(this)->ActorCallback< TagActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TagActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("tag", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tag", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TagActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("tag", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tag", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TagActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("tag", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TagActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tag", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> future;
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	T what;
															#line 15225 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via tag()
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagActor final : public Actor<T>, public ActorCallback< TagActor<T>, 0, Void >, public FastAllocated<TagActor<T>>, public TagActorState<T, TagActor<T>> {
															#line 15232 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TagActor<T>>::operator new;
	using FastAllocated<TagActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(15223562352532897536UL, 18292347299292341248UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TagActor<T>, 0, Void >;
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagActor(Future<Void> const& future,T const& what) 
															#line 15249 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   TagActorState<T, TagActor<T>>(future, what),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("tag", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(6074264639100469760UL, 11102663212846449920UL);
		ActorExecutionContextHelper __helper(static_cast<TagActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("tag");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("tag", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TagActor<T>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> tag( Future<Void> const& future, T const& what ) {
															#line 1266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new TagActor<T>(future, what));
															#line 15284 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1271 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 15289 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via tag()
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class TagActor1>
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagActor1State {
															#line 15296 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagActor1State(Future<Void> const& future,T const& what,PromiseStream<T> const& stream) 
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : future(future),
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   what(what),
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   stream(stream)
															#line 15307 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("tag", reinterpret_cast<unsigned long>(this));

	}
	~TagActor1State() 
	{
		fdb_probe_actor_destroy("tag", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = future;
															#line 1274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<TagActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 15324 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<TagActor1*>(this)->actor_wait_state = 1;
															#line 1274 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TagActor1, 0, Void >*>(static_cast<TagActor1*>(this)));
															#line 15329 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TagActor1State();
		static_cast<TagActor1*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1275 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		stream.send(what);
															#line 1276 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TagActor1*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TagActor1State(); static_cast<TagActor1*>(this)->destroy(); return 0; }
															#line 15354 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TagActor1*>(this)->SAV< Void >::value()) Void(Void());
		this->~TagActor1State();
		static_cast<TagActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1275 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		stream.send(what);
															#line 1276 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TagActor1*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TagActor1State(); static_cast<TagActor1*>(this)->destroy(); return 0; }
															#line 15368 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TagActor1*>(this)->SAV< Void >::value()) Void(Void());
		this->~TagActor1State();
		static_cast<TagActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TagActor1*>(this)->actor_wait_state > 0) static_cast<TagActor1*>(this)->actor_wait_state = 0;
		static_cast<TagActor1*>(this)->ActorCallback< TagActor1, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TagActor1, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("tag", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tag", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TagActor1, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("tag", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tag", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TagActor1, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("tag", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TagActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tag", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> future;
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	T what;
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<T> stream;
															#line 15457 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via tag()
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagActor1 final : public Actor<Void>, public ActorCallback< TagActor1<T>, 0, Void >, public FastAllocated<TagActor1<T>>, public TagActor1State<T, TagActor1<T>> {
															#line 15464 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TagActor1<T>>::operator new;
	using FastAllocated<TagActor1<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(15223562352532897536UL, 18292347299292341248UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TagActor1<T>, 0, Void >;
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagActor1(Future<Void> const& future,T const& what,PromiseStream<T> const& stream) 
															#line 15481 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   TagActor1State<T, TagActor1<T>>(future, what, stream),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("tag", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(2683904013079911936UL, 8793601520481839616UL);
		ActorExecutionContextHelper __helper(static_cast<TagActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("tag");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("tag", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TagActor1<T>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> tag( Future<Void> const& future, T const& what, PromiseStream<T> const& stream ) {
															#line 1272 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new TagActor1<T>(future, what, stream));
															#line 15516 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1278 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 15521 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via tagError()
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class TagErrorActor>
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagErrorActorState {
															#line 15528 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagErrorActorState(Future<Void> const& future,Error const& e) 
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : future(future),
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   e(e)
															#line 15537 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("tagError", reinterpret_cast<unsigned long>(this));

	}
	~TagErrorActorState() 
	{
		fdb_probe_actor_destroy("tagError", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = future;
															#line 1281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<TagErrorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 15554 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<TagErrorActor*>(this)->actor_wait_state = 1;
															#line 1281 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TagErrorActor, 0, Void >*>(static_cast<TagErrorActor*>(this)));
															#line 15559 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TagErrorActorState();
		static_cast<TagErrorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1282 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(e, loopDepth);
															#line 15582 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1282 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(e, loopDepth);
															#line 15590 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TagErrorActor*>(this)->actor_wait_state > 0) static_cast<TagErrorActor*>(this)->actor_wait_state = 0;
		static_cast<TagErrorActor*>(this)->ActorCallback< TagErrorActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TagErrorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("tagError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TagErrorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("tagError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TagErrorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("tagError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TagErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagError", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> future;
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Error e;
															#line 15673 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via tagError()
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagErrorActor final : public Actor<T>, public ActorCallback< TagErrorActor<T>, 0, Void >, public FastAllocated<TagErrorActor<T>>, public TagErrorActorState<T, TagErrorActor<T>> {
															#line 15680 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TagErrorActor<T>>::operator new;
	using FastAllocated<TagErrorActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(3848199847735567360UL, 7785495618263318272UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TagErrorActor<T>, 0, Void >;
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagErrorActor(Future<Void> const& future,Error const& e) 
															#line 15697 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   TagErrorActorState<T, TagErrorActor<T>>(future, e),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("tagError", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(11378414421076206080UL, 1160010013487977472UL);
		ActorExecutionContextHelper __helper(static_cast<TagErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("tagError");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("tagError", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TagErrorActor<T>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> tagError( Future<Void> const& future, Error const& e ) {
															#line 1279 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new TagErrorActor<T>(future, e));
															#line 15732 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1284 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 15737 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via detach()
															#line 1285 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class DetachActor>
															#line 1285 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DetachActorState {
															#line 15744 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1285 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DetachActorState(Future<T> const& f) 
															#line 1285 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1285 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : f(f)
															#line 15751 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("detach", reinterpret_cast<unsigned long>(this));

	}
	~DetachActorState() 
	{
		fdb_probe_actor_destroy("detach", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1287 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = f;
															#line 1287 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<DetachActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 15768 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<DetachActor*>(this)->actor_wait_state = 1;
															#line 1287 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< DetachActor, 0, T >*>(static_cast<DetachActor*>(this)));
															#line 15773 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~DetachActorState();
		static_cast<DetachActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T const& x,int loopDepth) 
	{
															#line 1288 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<DetachActor*>(this)->SAV<T>::futures) { (void)(x); this->~DetachActorState(); static_cast<DetachActor*>(this)->destroy(); return 0; }
															#line 15796 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<DetachActor*>(this)->SAV< T >::value()) T(x);
		this->~DetachActorState();
		static_cast<DetachActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(T && x,int loopDepth) 
	{
															#line 1288 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<DetachActor*>(this)->SAV<T>::futures) { (void)(x); this->~DetachActorState(); static_cast<DetachActor*>(this)->destroy(); return 0; }
															#line 15808 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<DetachActor*>(this)->SAV< T >::value()) T(x);
		this->~DetachActorState();
		static_cast<DetachActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& x,int loopDepth) 
	{
		loopDepth = a_body1cont1(x, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && x,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(x), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<DetachActor*>(this)->actor_wait_state > 0) static_cast<DetachActor*>(this)->actor_wait_state = 0;
		static_cast<DetachActor*>(this)->ActorCallback< DetachActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< DetachActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("detach", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DetachActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("detach", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< DetachActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("detach", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DetachActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("detach", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< DetachActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("detach", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<DetachActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("detach", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1285 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> f;
															#line 15893 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via detach()
															#line 1285 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1285 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DetachActor final : public Actor<T>, public ActorCallback< DetachActor<T>, 0, T >, public FastAllocated<DetachActor<T>>, public DetachActorState<T, DetachActor<T>> {
															#line 15900 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<DetachActor<T>>::operator new;
	using FastAllocated<DetachActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(4496252234715023104UL, 11292762962533678336UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< DetachActor<T>, 0, T >;
															#line 1285 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DetachActor(Future<T> const& f) 
															#line 15917 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   DetachActorState<T, DetachActor<T>>(f),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("detach", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(7649208278263481856UL, 1919194672671098624UL);
		ActorExecutionContextHelper __helper(static_cast<DetachActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("detach");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("detach", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< DetachActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1285 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1285 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> detach( Future<T> const& f ) {
															#line 1285 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new DetachActor<T>(f));
															#line 15952 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1290 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// If the future is ready, yields and returns. Otherwise, returns when future is set.
template <class T>
Future<T> orYield(Future<T> f) {
	if (f.isReady()) {
		if (f.isError())
			return tagError<T>(yield(), f.getError());
		else
			return tag(yield(), f.get());
	} else
		return f;
}

Future<Void> orYield(Future<Void> f);

															#line 15971 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via chooseActor()
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class ChooseActorActor>
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ChooseActorActorState {
															#line 15978 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ChooseActorActorState(Future<T> const& lhs,Future<T> const& rhs) 
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : lhs(lhs),
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   rhs(rhs)
															#line 15987 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("chooseActor", reinterpret_cast<unsigned long>(this));

	}
	~ChooseActorActorState() 
	{
		fdb_probe_actor_destroy("chooseActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1308 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = lhs;
															#line 1307 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<ChooseActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 16004 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 1311 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_1 = rhs;
															#line 16008 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1when2(__when_expr_1.get(), loopDepth); };
			static_cast<ChooseActorActor*>(this)->actor_wait_state = 1;
															#line 1308 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ChooseActorActor, 0, T >*>(static_cast<ChooseActorActor*>(this)));
															#line 1311 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< ChooseActorActor, 1, T >*>(static_cast<ChooseActorActor*>(this)));
															#line 16015 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ChooseActorActorState();
		static_cast<ChooseActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
															#line 1309 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ChooseActorActor*>(this)->SAV<T>::futures) { (void)(t); this->~ChooseActorActorState(); static_cast<ChooseActorActor*>(this)->destroy(); return 0; }
															#line 16038 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ChooseActorActor*>(this)->SAV< T >::value()) T(t);
		this->~ChooseActorActorState();
		static_cast<ChooseActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
															#line 1309 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ChooseActorActor*>(this)->SAV<T>::futures) { (void)(t); this->~ChooseActorActorState(); static_cast<ChooseActorActor*>(this)->destroy(); return 0; }
															#line 16050 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ChooseActorActor*>(this)->SAV< T >::value()) T(t);
		this->~ChooseActorActorState();
		static_cast<ChooseActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when2(T const& t,int loopDepth) 
	{
															#line 1312 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ChooseActorActor*>(this)->SAV<T>::futures) { (void)(t); this->~ChooseActorActorState(); static_cast<ChooseActorActor*>(this)->destroy(); return 0; }
															#line 16062 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ChooseActorActor*>(this)->SAV< T >::value()) T(t);
		this->~ChooseActorActorState();
		static_cast<ChooseActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when2(T && t,int loopDepth) 
	{
															#line 1312 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ChooseActorActor*>(this)->SAV<T>::futures) { (void)(t); this->~ChooseActorActorState(); static_cast<ChooseActorActor*>(this)->destroy(); return 0; }
															#line 16074 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ChooseActorActor*>(this)->SAV< T >::value()) T(t);
		this->~ChooseActorActorState();
		static_cast<ChooseActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ChooseActorActor*>(this)->actor_wait_state > 0) static_cast<ChooseActorActor*>(this)->actor_wait_state = 0;
		static_cast<ChooseActorActor*>(this)->ActorCallback< ChooseActorActor, 0, T >::remove();
		static_cast<ChooseActorActor*>(this)->ActorCallback< ChooseActorActor, 1, T >::remove();

	}
	void a_callback_fire(ActorCallback< ChooseActorActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("chooseActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ChooseActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("chooseActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ChooseActorActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("chooseActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ChooseActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("chooseActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ChooseActorActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("chooseActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ChooseActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("chooseActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ChooseActorActor, 1, T >*,T const& value) 
	{
		fdb_probe_actor_enter("chooseActor", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ChooseActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("chooseActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< ChooseActorActor, 1, T >*,T && value) 
	{
		fdb_probe_actor_enter("chooseActor", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ChooseActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("chooseActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< ChooseActorActor, 1, T >*,Error err) 
	{
		fdb_probe_actor_enter("chooseActor", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ChooseActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("chooseActor", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> lhs;
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> rhs;
															#line 16207 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via chooseActor()
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ChooseActorActor final : public Actor<T>, public ActorCallback< ChooseActorActor<T>, 0, T >, public ActorCallback< ChooseActorActor<T>, 1, T >, public FastAllocated<ChooseActorActor<T>>, public ChooseActorActorState<T, ChooseActorActor<T>> {
															#line 16214 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<ChooseActorActor<T>>::operator new;
	using FastAllocated<ChooseActorActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(4493421111469851648UL, 3262974030193534976UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< ChooseActorActor<T>, 0, T >;
friend struct ActorCallback< ChooseActorActor<T>, 1, T >;
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ChooseActorActor(Future<T> const& lhs,Future<T> const& rhs) 
															#line 16232 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   ChooseActorActorState<T, ChooseActorActor<T>>(lhs, rhs),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("chooseActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(3951223725334214400UL, 8219181030228943104UL);
		ActorExecutionContextHelper __helper(static_cast<ChooseActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("chooseActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("chooseActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ChooseActorActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> chooseActor( Future<T> const& lhs, Future<T> const& rhs ) {
															#line 1305 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new ChooseActorActor<T>(lhs, rhs));
															#line 16267 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1316 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// set && set -> set
// error && x -> error
// all others -> unset
inline Future<Void> operator&&(Future<Void> const& lhs, Future<Void> const& rhs) {
	if (lhs.isReady()) {
		if (lhs.isError())
			return lhs;
		else
			return rhs;
	}
	if (rhs.isReady()) {
		if (rhs.isError())
			return rhs;
		else
			return lhs;
	}

	Future<Void> x[] = { lhs, rhs };
	return quorum(x, 2, 2);
}

// error || unset -> error
// unset || unset -> unset
// all others -> set
inline Future<Void> operator||(Future<Void> const& lhs, Future<Void> const& rhs) {
	if (lhs.isReady()) {
		if (lhs.isError())
			return lhs;
		if (rhs.isReady())
			return rhs;
		return lhs;
	}

	return chooseActor(lhs, rhs);
}

															#line 16308 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via joinWith()
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class JoinWithActor>
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class JoinWithActorState {
															#line 16315 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	JoinWithActorState(Future<T> const& f,Future<Void> const& other) 
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : f(f),
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   other(other)
															#line 16324 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("joinWith", reinterpret_cast<unsigned long>(this));

	}
	~JoinWithActorState() 
	{
		fdb_probe_actor_destroy("joinWith", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1355 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = other;
															#line 1355 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<JoinWithActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 16341 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<JoinWithActor*>(this)->actor_wait_state = 1;
															#line 1355 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< JoinWithActor, 0, Void >*>(static_cast<JoinWithActor*>(this)));
															#line 16346 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~JoinWithActorState();
		static_cast<JoinWithActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1356 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<T> __when_expr_1 = f;
															#line 1356 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<JoinWithActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 16371 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<JoinWithActor*>(this)->actor_wait_state = 2;
															#line 1356 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< JoinWithActor, 1, T >*>(static_cast<JoinWithActor*>(this)));
															#line 16376 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1356 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<T> __when_expr_1 = f;
															#line 1356 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<JoinWithActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 16387 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<JoinWithActor*>(this)->actor_wait_state = 2;
															#line 1356 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< JoinWithActor, 1, T >*>(static_cast<JoinWithActor*>(this)));
															#line 16392 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<JoinWithActor*>(this)->actor_wait_state > 0) static_cast<JoinWithActor*>(this)->actor_wait_state = 0;
		static_cast<JoinWithActor*>(this)->ActorCallback< JoinWithActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< JoinWithActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("joinWith", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<JoinWithActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("joinWith", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< JoinWithActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("joinWith", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<JoinWithActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("joinWith", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< JoinWithActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("joinWith", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<JoinWithActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("joinWith", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(T const& t,int loopDepth) 
	{
															#line 1357 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<JoinWithActor*>(this)->SAV<T>::futures) { (void)(t); this->~JoinWithActorState(); static_cast<JoinWithActor*>(this)->destroy(); return 0; }
															#line 16476 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<JoinWithActor*>(this)->SAV< T >::value()) T(t);
		this->~JoinWithActorState();
		static_cast<JoinWithActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(T && t,int loopDepth) 
	{
															#line 1357 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<JoinWithActor*>(this)->SAV<T>::futures) { (void)(t); this->~JoinWithActorState(); static_cast<JoinWithActor*>(this)->destroy(); return 0; }
															#line 16488 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<JoinWithActor*>(this)->SAV< T >::value()) T(t);
		this->~JoinWithActorState();
		static_cast<JoinWithActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(T const& t,int loopDepth) 
	{
		loopDepth = a_body1cont2(t, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(T && t,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(t), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<JoinWithActor*>(this)->actor_wait_state > 0) static_cast<JoinWithActor*>(this)->actor_wait_state = 0;
		static_cast<JoinWithActor*>(this)->ActorCallback< JoinWithActor, 1, T >::remove();

	}
	void a_callback_fire(ActorCallback< JoinWithActor, 1, T >*,T const& value) 
	{
		fdb_probe_actor_enter("joinWith", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<JoinWithActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("joinWith", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< JoinWithActor, 1, T >*,T && value) 
	{
		fdb_probe_actor_enter("joinWith", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<JoinWithActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("joinWith", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< JoinWithActor, 1, T >*,Error err) 
	{
		fdb_probe_actor_enter("joinWith", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<JoinWithActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("joinWith", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> f;
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> other;
															#line 16575 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via joinWith()
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class JoinWithActor final : public Actor<T>, public ActorCallback< JoinWithActor<T>, 0, Void >, public ActorCallback< JoinWithActor<T>, 1, T >, public FastAllocated<JoinWithActor<T>>, public JoinWithActorState<T, JoinWithActor<T>> {
															#line 16582 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<JoinWithActor<T>>::operator new;
	using FastAllocated<JoinWithActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(11906828431042297088UL, 6909810504176240384UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< JoinWithActor<T>, 0, Void >;
friend struct ActorCallback< JoinWithActor<T>, 1, T >;
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	JoinWithActor(Future<T> const& f,Future<Void> const& other) 
															#line 16600 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   JoinWithActorState<T, JoinWithActor<T>>(f, other),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("joinWith", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(12766439481480399360UL, 5505299843723195904UL);
		ActorExecutionContextHelper __helper(static_cast<JoinWithActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("joinWith");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("joinWith", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< JoinWithActor<T>, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< JoinWithActor<T>, 1, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> joinWith( Future<T> const& f, Future<Void> const& other ) {
															#line 1353 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new JoinWithActor<T>(f, other));
															#line 16636 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1359 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// wait <interval> then call what() in a loop forever
															#line 16642 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via recurring()
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Func, class RecurringActor>
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class RecurringActorState {
															#line 16649 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	RecurringActorState(Func const& what,double const& interval,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   interval(interval),
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   taskID(taskID)
															#line 16660 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("recurring", reinterpret_cast<unsigned long>(this));

	}
	~RecurringActorState() 
	{
		fdb_probe_actor_destroy("recurring", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1363 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 16675 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~RecurringActorState();
		static_cast<RecurringActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 1364 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_0 = delay(interval, taskID);
															#line 1363 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<RecurringActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 16707 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<RecurringActor*>(this)->actor_wait_state = 1;
															#line 1364 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< RecurringActor, 0, Void >*>(static_cast<RecurringActor*>(this)));
															#line 16712 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
															#line 1365 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		what();
															#line 16727 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
															#line 1365 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		what();
															#line 16736 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<RecurringActor*>(this)->actor_wait_state > 0) static_cast<RecurringActor*>(this)->actor_wait_state = 0;
		static_cast<RecurringActor*>(this)->ActorCallback< RecurringActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< RecurringActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("recurring", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurring", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< RecurringActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("recurring", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurring", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< RecurringActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("recurring", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurring", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Func what;
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double interval;
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TaskPriority taskID;
															#line 16810 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via recurring()
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Func>
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class RecurringActor final : public Actor<Void>, public ActorCallback< RecurringActor<Func>, 0, Void >, public FastAllocated<RecurringActor<Func>>, public RecurringActorState<Func, RecurringActor<Func>> {
															#line 16817 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<RecurringActor<Func>>::operator new;
	using FastAllocated<RecurringActor<Func>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(18066611276121619712UL, 11188810723576059136UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< RecurringActor<Func>, 0, Void >;
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	RecurringActor(Func const& what,double const& interval,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 16834 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   RecurringActorState<Func, RecurringActor<Func>>(what, interval, taskID),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("recurring", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(17537664105049190144UL, 15623275426293941504UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("recurring");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("recurring", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< RecurringActor<Func>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Func>
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> recurring( Func const& what, double const& interval, TaskPriority const& taskID = TaskPriority::DefaultDelay ) {
															#line 1361 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new RecurringActor<Func>(what, interval, taskID));
															#line 16869 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1369 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 16874 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via checkUntil()
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Func, class CheckUntilActor>
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class CheckUntilActorState {
															#line 16881 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	CheckUntilActorState(double const& checkInterval,Func const& f,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : checkInterval(checkInterval),
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   f(f),
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   taskID(taskID)
															#line 16892 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("checkUntil", reinterpret_cast<unsigned long>(this));

	}
	~CheckUntilActorState() 
	{
		fdb_probe_actor_destroy("checkUntil", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1372 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 16907 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~CheckUntilActorState();
		static_cast<CheckUntilActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 1373 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_0 = delay(checkInterval, taskID);
															#line 1373 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<CheckUntilActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 16939 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<CheckUntilActor*>(this)->actor_wait_state = 1;
															#line 1373 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< CheckUntilActor, 0, Void >*>(static_cast<CheckUntilActor*>(this)));
															#line 16944 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 1374 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (f())
															#line 16953 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 1375 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (!static_cast<CheckUntilActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~CheckUntilActorState(); static_cast<CheckUntilActor*>(this)->destroy(); return 0; }
															#line 16957 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			new (&static_cast<CheckUntilActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~CheckUntilActorState();
			static_cast<CheckUntilActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 1374 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (f())
															#line 16971 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 1375 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (!static_cast<CheckUntilActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~CheckUntilActorState(); static_cast<CheckUntilActor*>(this)->destroy(); return 0; }
															#line 16975 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			new (&static_cast<CheckUntilActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~CheckUntilActorState();
			static_cast<CheckUntilActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<CheckUntilActor*>(this)->actor_wait_state > 0) static_cast<CheckUntilActor*>(this)->actor_wait_state = 0;
		static_cast<CheckUntilActor*>(this)->ActorCallback< CheckUntilActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< CheckUntilActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("checkUntil", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<CheckUntilActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkUntil", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< CheckUntilActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("checkUntil", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<CheckUntilActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkUntil", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< CheckUntilActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("checkUntil", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<CheckUntilActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkUntil", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double checkInterval;
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Func f;
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TaskPriority taskID;
															#line 17066 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via checkUntil()
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Func>
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class CheckUntilActor final : public Actor<Void>, public ActorCallback< CheckUntilActor<Func>, 0, Void >, public FastAllocated<CheckUntilActor<Func>>, public CheckUntilActorState<Func, CheckUntilActor<Func>> {
															#line 17073 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<CheckUntilActor<Func>>::operator new;
	using FastAllocated<CheckUntilActor<Func>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(6716109158503574272UL, 4431462448515030016UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< CheckUntilActor<Func>, 0, Void >;
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	CheckUntilActor(double const& checkInterval,Func const& f,TaskPriority const& taskID = TaskPriority::DefaultDelay) 
															#line 17090 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   CheckUntilActorState<Func, CheckUntilActor<Func>>(checkInterval, f, taskID),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("checkUntil", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(3726734547380598272UL, 1424042254037488128UL);
		ActorExecutionContextHelper __helper(static_cast<CheckUntilActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("checkUntil");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("checkUntil", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< CheckUntilActor<Func>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Func>
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> checkUntil( double const& checkInterval, Func const& f, TaskPriority const& taskID = TaskPriority::DefaultDelay ) {
															#line 1370 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new CheckUntilActor<Func>(checkInterval, f, taskID));
															#line 17125 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1378 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// Invoke actorFunc() forever in a loop
// At least wait<interval> between two actor functor invocations
															#line 17132 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via recurringAsync()
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class F, class RecurringAsyncActor>
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class RecurringAsyncActorState {
															#line 17139 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	RecurringAsyncActorState(F const& actorFunc,double const& interval,bool const& absoluteIntervalDelay,double const& initialDelay,TaskPriority const& taskID = TaskPriority::DefaultDelay,bool const& jittered = false) 
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : actorFunc(actorFunc),
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   interval(interval),
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   absoluteIntervalDelay(absoluteIntervalDelay),
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   initialDelay(initialDelay),
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   taskID(taskID),
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   jittered(jittered)
															#line 17156 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("recurringAsync", reinterpret_cast<unsigned long>(this));

	}
	~RecurringAsyncActorState() 
	{
		fdb_probe_actor_destroy("recurringAsync", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1394 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = delay(initialDelay);
															#line 1394 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 17173 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 1;
															#line 1394 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< RecurringAsyncActor, 0, Void >*>(static_cast<RecurringAsyncActor*>(this)));
															#line 17178 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~RecurringAsyncActorState();
		static_cast<RecurringAsyncActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1396 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		val = Future<Void>();
															#line 1398 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		;
															#line 17203 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1396 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		val = Future<Void>();
															#line 1398 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		;
															#line 17214 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state > 0) static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 0;
		static_cast<RecurringAsyncActor*>(this)->ActorCallback< RecurringAsyncActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< RecurringAsyncActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< RecurringAsyncActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< RecurringAsyncActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 1399 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		val = actorFunc();
															#line 1401 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (absoluteIntervalDelay)
															#line 17307 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 1402 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_1 = val;
															#line 1402 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 17313 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
			static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 2;
															#line 1402 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< RecurringAsyncActor, 1, Void >*>(static_cast<RecurringAsyncActor*>(this)));
															#line 17318 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		else
		{
															#line 1413 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (jittered)
															#line 17325 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 1414 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<Void> __when_expr_4 = val && delayJittered(interval);
															#line 1414 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 17331 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1when2(__when_expr_4.get(), loopDepth); };
				static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 5;
															#line 1414 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< RecurringAsyncActor, 4, Void >*>(static_cast<RecurringAsyncActor*>(this)));
															#line 17336 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			else
			{
															#line 1416 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<Void> __when_expr_5 = val && delay(interval);
															#line 1416 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 17345 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1when3(__when_expr_5.get(), loopDepth); };
				static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 6;
															#line 1416 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< RecurringAsyncActor, 5, Void >*>(static_cast<RecurringAsyncActor*>(this)));
															#line 17350 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 1404 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (jittered)
															#line 17367 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 1405 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_2 = delayJittered(interval);
															#line 1405 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 17373 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
			static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 3;
															#line 1405 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< RecurringAsyncActor, 2, Void >*>(static_cast<RecurringAsyncActor*>(this)));
															#line 17378 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		else
		{
															#line 1407 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_3 = delay(interval);
															#line 1407 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 17387 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1cont2when2(__when_expr_3.get(), loopDepth); };
			static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 4;
															#line 1407 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< RecurringAsyncActor, 3, Void >*>(static_cast<RecurringAsyncActor*>(this)));
															#line 17392 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 1404 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (jittered)
															#line 17402 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 1405 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_2 = delayJittered(interval);
															#line 1405 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 17408 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
			static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 3;
															#line 1405 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< RecurringAsyncActor, 2, Void >*>(static_cast<RecurringAsyncActor*>(this)));
															#line 17413 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		else
		{
															#line 1407 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_3 = delay(interval);
															#line 1407 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 17422 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1cont2when2(__when_expr_3.get(), loopDepth); };
			static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 4;
															#line 1407 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< RecurringAsyncActor, 3, Void >*>(static_cast<RecurringAsyncActor*>(this)));
															#line 17427 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state > 0) static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 0;
		static_cast<RecurringAsyncActor*>(this)->ActorCallback< RecurringAsyncActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< RecurringAsyncActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< RecurringAsyncActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< RecurringAsyncActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont1loopBody1cont3(int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont4(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont4(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state > 0) static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 0;
		static_cast<RecurringAsyncActor*>(this)->ActorCallback< RecurringAsyncActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< RecurringAsyncActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< RecurringAsyncActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< RecurringAsyncActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont1loopBody1cont5(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont5(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state > 0) static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 0;
		static_cast<RecurringAsyncActor*>(this)->ActorCallback< RecurringAsyncActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< RecurringAsyncActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 3);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont2when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< RecurringAsyncActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 3);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont2when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< RecurringAsyncActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 3);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont1loopBody1cont6(int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont7(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont7(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont7(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont7(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state > 0) static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 0;
		static_cast<RecurringAsyncActor*>(this)->ActorCallback< RecurringAsyncActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< RecurringAsyncActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 4);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose5();
		try {
			a_body1cont1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< RecurringAsyncActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 4);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose5();
		try {
			a_body1cont1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< RecurringAsyncActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 4);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont1loopBody1cont8(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont8(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont8(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont8(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<RecurringAsyncActor*>(this)->actor_wait_state > 0) static_cast<RecurringAsyncActor*>(this)->actor_wait_state = 0;
		static_cast<RecurringAsyncActor*>(this)->ActorCallback< RecurringAsyncActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< RecurringAsyncActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 5);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose6();
		try {
			a_body1cont1loopBody1when3(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< RecurringAsyncActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 5);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose6();
		try {
			a_body1cont1loopBody1when3(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< RecurringAsyncActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), 5);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose6();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), 5);

	}
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	F actorFunc;
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double interval;
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	bool absoluteIntervalDelay;
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double initialDelay;
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TaskPriority taskID;
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	bool jittered;
															#line 1396 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> val;
															#line 17882 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via recurringAsync()
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class F>
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class RecurringAsyncActor final : public Actor<Void>, public ActorCallback< RecurringAsyncActor<F>, 0, Void >, public ActorCallback< RecurringAsyncActor<F>, 1, Void >, public ActorCallback< RecurringAsyncActor<F>, 2, Void >, public ActorCallback< RecurringAsyncActor<F>, 3, Void >, public ActorCallback< RecurringAsyncActor<F>, 4, Void >, public ActorCallback< RecurringAsyncActor<F>, 5, Void >, public FastAllocated<RecurringAsyncActor<F>>, public RecurringAsyncActorState<F, RecurringAsyncActor<F>> {
															#line 17889 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<RecurringAsyncActor<F>>::operator new;
	using FastAllocated<RecurringAsyncActor<F>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(12726117921306569984UL, 14656441109943186688UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< RecurringAsyncActor<F>, 0, Void >;
friend struct ActorCallback< RecurringAsyncActor<F>, 1, Void >;
friend struct ActorCallback< RecurringAsyncActor<F>, 2, Void >;
friend struct ActorCallback< RecurringAsyncActor<F>, 3, Void >;
friend struct ActorCallback< RecurringAsyncActor<F>, 4, Void >;
friend struct ActorCallback< RecurringAsyncActor<F>, 5, Void >;
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	RecurringAsyncActor(F const& actorFunc,double const& interval,bool const& absoluteIntervalDelay,double const& initialDelay,TaskPriority const& taskID = TaskPriority::DefaultDelay,bool const& jittered = false) 
															#line 17911 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   RecurringAsyncActorState<F, RecurringAsyncActor<F>>(actorFunc, interval, absoluteIntervalDelay, initialDelay, taskID, jittered),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("recurringAsync", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(3697511342910172928UL, 10359590383790180096UL);
		ActorExecutionContextHelper __helper(static_cast<RecurringAsyncActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("recurringAsync");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("recurringAsync", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< RecurringAsyncActor<F>, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< RecurringAsyncActor<F>, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< RecurringAsyncActor<F>, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< RecurringAsyncActor<F>, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< RecurringAsyncActor<F>, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< RecurringAsyncActor<F>, 5, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class F>
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> recurringAsync( F const& actorFunc, double const& interval, bool const& absoluteIntervalDelay, double const& initialDelay, TaskPriority const& taskID = TaskPriority::DefaultDelay, bool const& jittered = false ) {
															#line 1381 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new RecurringAsyncActor<F>(actorFunc, interval, absoluteIntervalDelay, initialDelay, taskID, jittered));
															#line 17951 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1421 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 17956 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via brokenPromiseToNever()
															#line 1422 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class BrokenPromiseToNeverActor>
															#line 1422 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class BrokenPromiseToNeverActorState {
															#line 17963 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1422 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	BrokenPromiseToNeverActorState(Future<T> const& in) 
															#line 1422 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1422 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : in(in)
															#line 17970 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("brokenPromiseToNever", reinterpret_cast<unsigned long>(this));

	}
	~BrokenPromiseToNeverActorState() 
	{
		fdb_probe_actor_destroy("brokenPromiseToNever", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 1425 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = in;
															#line 1425 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<BrokenPromiseToNeverActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 17988 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<BrokenPromiseToNeverActor*>(this)->actor_wait_state = 1;
															#line 1425 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< BrokenPromiseToNeverActor, 0, T >*>(static_cast<BrokenPromiseToNeverActor*>(this)));
															#line 17993 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~BrokenPromiseToNeverActorState();
		static_cast<BrokenPromiseToNeverActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1428 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() != error_code_broken_promise)
															#line 18023 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 1429 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				return a_body1Catch1(e, loopDepth);
															#line 18027 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 1430 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_1 = Never();
															#line 1430 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<BrokenPromiseToNeverActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18033 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1Catch2when1(__when_expr_1.get(), loopDepth); };
			static_cast<BrokenPromiseToNeverActor*>(this)->actor_wait_state = 2;
															#line 1430 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< BrokenPromiseToNeverActor, 1, Void >*>(static_cast<BrokenPromiseToNeverActor*>(this)));
															#line 18038 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& t,int loopDepth) 
	{
															#line 1426 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<BrokenPromiseToNeverActor*>(this)->SAV<T>::futures) { (void)(t); this->~BrokenPromiseToNeverActorState(); static_cast<BrokenPromiseToNeverActor*>(this)->destroy(); return 0; }
															#line 18053 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<BrokenPromiseToNeverActor*>(this)->SAV< T >::value()) T(t);
		this->~BrokenPromiseToNeverActorState();
		static_cast<BrokenPromiseToNeverActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(T && t,int loopDepth) 
	{
															#line 1426 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<BrokenPromiseToNeverActor*>(this)->SAV<T>::futures) { (void)(t); this->~BrokenPromiseToNeverActorState(); static_cast<BrokenPromiseToNeverActor*>(this)->destroy(); return 0; }
															#line 18065 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<BrokenPromiseToNeverActor*>(this)->SAV< T >::value()) T(t);
		this->~BrokenPromiseToNeverActorState();
		static_cast<BrokenPromiseToNeverActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
		loopDepth = a_body1cont2(t, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(t), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<BrokenPromiseToNeverActor*>(this)->actor_wait_state > 0) static_cast<BrokenPromiseToNeverActor*>(this)->actor_wait_state = 0;
		static_cast<BrokenPromiseToNeverActor*>(this)->ActorCallback< BrokenPromiseToNeverActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< BrokenPromiseToNeverActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BrokenPromiseToNeverActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< BrokenPromiseToNeverActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BrokenPromiseToNeverActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< BrokenPromiseToNeverActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<BrokenPromiseToNeverActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1Catch2cont1(Void const& _,int loopDepth) 
	{
															#line 1431 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(internal_error(), loopDepth);
															#line 18152 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	int a_body1Catch2cont1(Void && _,int loopDepth) 
	{
															#line 1431 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(internal_error(), loopDepth);
															#line 18160 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	int a_body1Catch2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1Catch2cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1Catch2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1Catch2cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<BrokenPromiseToNeverActor*>(this)->actor_wait_state > 0) static_cast<BrokenPromiseToNeverActor*>(this)->actor_wait_state = 0;
		static_cast<BrokenPromiseToNeverActor*>(this)->ActorCallback< BrokenPromiseToNeverActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< BrokenPromiseToNeverActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BrokenPromiseToNeverActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< BrokenPromiseToNeverActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BrokenPromiseToNeverActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< BrokenPromiseToNeverActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<BrokenPromiseToNeverActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1422 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> in;
															#line 18241 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via brokenPromiseToNever()
															#line 1422 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1422 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class BrokenPromiseToNeverActor final : public Actor<T>, public ActorCallback< BrokenPromiseToNeverActor<T>, 0, T >, public ActorCallback< BrokenPromiseToNeverActor<T>, 1, Void >, public FastAllocated<BrokenPromiseToNeverActor<T>>, public BrokenPromiseToNeverActorState<T, BrokenPromiseToNeverActor<T>> {
															#line 18248 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<BrokenPromiseToNeverActor<T>>::operator new;
	using FastAllocated<BrokenPromiseToNeverActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(13343647220337166592UL, 16486435889630118400UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< BrokenPromiseToNeverActor<T>, 0, T >;
friend struct ActorCallback< BrokenPromiseToNeverActor<T>, 1, Void >;
															#line 1422 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	BrokenPromiseToNeverActor(Future<T> const& in) 
															#line 18266 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   BrokenPromiseToNeverActorState<T, BrokenPromiseToNeverActor<T>>(in),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(6020187088966151168UL, 5859802100040342784UL);
		ActorExecutionContextHelper __helper(static_cast<BrokenPromiseToNeverActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("brokenPromiseToNever");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("brokenPromiseToNever", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< BrokenPromiseToNeverActor<T>, 0, T >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< BrokenPromiseToNeverActor<T>, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1422 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1422 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> brokenPromiseToNever( Future<T> const& in ) {
															#line 1422 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new BrokenPromiseToNeverActor<T>(in));
															#line 18302 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1434 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 18307 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via brokenPromiseToMaybeDelivered()
															#line 1435 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class BrokenPromiseToMaybeDeliveredActor>
															#line 1435 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class BrokenPromiseToMaybeDeliveredActorState {
															#line 18314 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1435 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	BrokenPromiseToMaybeDeliveredActorState(Future<T> const& in) 
															#line 1435 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1435 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : in(in)
															#line 18321 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("brokenPromiseToMaybeDelivered", reinterpret_cast<unsigned long>(this));

	}
	~BrokenPromiseToMaybeDeliveredActorState() 
	{
		fdb_probe_actor_destroy("brokenPromiseToMaybeDelivered", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 1438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = in;
															#line 1438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 18339 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->actor_wait_state = 1;
															#line 1438 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< BrokenPromiseToMaybeDeliveredActor, 0, T >*>(static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)));
															#line 18344 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~BrokenPromiseToMaybeDeliveredActorState();
		static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1441 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == error_code_broken_promise)
															#line 18374 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 1442 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				return a_body1Catch1(request_maybe_delivered(), loopDepth);
															#line 18378 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 1444 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(e, loopDepth);
															#line 18382 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& t,int loopDepth) 
	{
															#line 1439 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->SAV<T>::futures) { (void)(t); this->~BrokenPromiseToMaybeDeliveredActorState(); static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->destroy(); return 0; }
															#line 18396 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->SAV< T >::value()) T(t);
		this->~BrokenPromiseToMaybeDeliveredActorState();
		static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(T && t,int loopDepth) 
	{
															#line 1439 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->SAV<T>::futures) { (void)(t); this->~BrokenPromiseToMaybeDeliveredActorState(); static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->destroy(); return 0; }
															#line 18408 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->SAV< T >::value()) T(t);
		this->~BrokenPromiseToMaybeDeliveredActorState();
		static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& t,int loopDepth) 
	{
		loopDepth = a_body1cont2(t, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && t,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(t), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->actor_wait_state > 0) static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->actor_wait_state = 0;
		static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->ActorCallback< BrokenPromiseToMaybeDeliveredActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< BrokenPromiseToMaybeDeliveredActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("brokenPromiseToMaybeDelivered", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("brokenPromiseToMaybeDelivered", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< BrokenPromiseToMaybeDeliveredActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("brokenPromiseToMaybeDelivered", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("brokenPromiseToMaybeDelivered", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< BrokenPromiseToMaybeDeliveredActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("brokenPromiseToMaybeDelivered", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("brokenPromiseToMaybeDelivered", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1435 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> in;
															#line 18493 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via brokenPromiseToMaybeDelivered()
															#line 1435 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1435 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class BrokenPromiseToMaybeDeliveredActor final : public Actor<T>, public ActorCallback< BrokenPromiseToMaybeDeliveredActor<T>, 0, T >, public FastAllocated<BrokenPromiseToMaybeDeliveredActor<T>>, public BrokenPromiseToMaybeDeliveredActorState<T, BrokenPromiseToMaybeDeliveredActor<T>> {
															#line 18500 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<BrokenPromiseToMaybeDeliveredActor<T>>::operator new;
	using FastAllocated<BrokenPromiseToMaybeDeliveredActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(10364715164100551936UL, 5519984627262541824UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< BrokenPromiseToMaybeDeliveredActor<T>, 0, T >;
															#line 1435 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	BrokenPromiseToMaybeDeliveredActor(Future<T> const& in) 
															#line 18517 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   BrokenPromiseToMaybeDeliveredActorState<T, BrokenPromiseToMaybeDeliveredActor<T>>(in),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("brokenPromiseToMaybeDelivered", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(13077679040336365824UL, 12545640751545721088UL);
		ActorExecutionContextHelper __helper(static_cast<BrokenPromiseToMaybeDeliveredActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("brokenPromiseToMaybeDelivered");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("brokenPromiseToMaybeDelivered", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< BrokenPromiseToMaybeDeliveredActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1435 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1435 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> brokenPromiseToMaybeDelivered( Future<T> const& in ) {
															#line 1435 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new BrokenPromiseToMaybeDeliveredActor<T>(in));
															#line 18552 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1447 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 18557 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via tagAndForward()
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class U, class TagAndForwardActor>
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagAndForwardActorState {
															#line 18564 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagAndForwardActorState(Promise<T>* const& pOutputPromise,U const& value,Future<Void> const& signal) 
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : pOutputPromise(pOutputPromise),
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   value(value),
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   signal(signal),
															#line 1450 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   out(std::move(*pOutputPromise))
															#line 18577 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("tagAndForward", reinterpret_cast<unsigned long>(this));

	}
	~TagAndForwardActorState() 
	{
		fdb_probe_actor_destroy("tagAndForward", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1451 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = signal;
															#line 1451 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 18594 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			static_cast<TagAndForwardActor*>(this)->actor_wait_state = 1;
															#line 1451 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TagAndForwardActor, 0, Void >*>(static_cast<TagAndForwardActor*>(this)));
															#line 18598 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		delete static_cast<TagAndForwardActor*>(this);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1452 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		out.send(std::move(value));
															#line 18620 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1452 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		out.send(std::move(value));
															#line 18629 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TagAndForwardActor*>(this)->actor_wait_state > 0) static_cast<TagAndForwardActor*>(this)->actor_wait_state = 0;
		static_cast<TagAndForwardActor*>(this)->ActorCallback< TagAndForwardActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TagAndForwardActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("tagAndForward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagAndForward", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TagAndForwardActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("tagAndForward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagAndForward", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TagAndForwardActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("tagAndForward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagAndForward", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		delete static_cast<TagAndForwardActor*>(this);
															#line 18713 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		return 0;

		return loopDepth;
	}
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Promise<T>* pOutputPromise;
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	U value;
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> signal;
															#line 1450 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Promise<T> out;
															#line 18726 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via tagAndForward()
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class U>
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagAndForwardActor final : public Actor<void>, public ActorCallback< TagAndForwardActor<T, U>, 0, Void >, public FastAllocated<TagAndForwardActor<T, U>>, public TagAndForwardActorState<T, U, TagAndForwardActor<T, U>> {
															#line 18733 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TagAndForwardActor<T, U>>::operator new;
	using FastAllocated<TagAndForwardActor<T, U>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(12051730031383433216UL, 4912401754353579776UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() {{
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<void>*>(this)->~Actor();
        operator delete(this);
    }}
#pragma clang diagnostic pop
friend struct ActorCallback< TagAndForwardActor<T, U>, 0, Void >;
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagAndForwardActor(Promise<T>* const& pOutputPromise,U const& value,Future<Void> const& signal) 
															#line 18750 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<void>(),
		   TagAndForwardActorState<T, U, TagAndForwardActor<T, U>>(pOutputPromise, value, signal),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("tagAndForward", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(14651556149279548928UL, 10927429797465589760UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("tagAndForward");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("tagAndForward", reinterpret_cast<unsigned long>(this), -1);

	}
};
} // namespace
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class U>
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
void tagAndForward( Promise<T>* const& pOutputPromise, U const& value, Future<Void> const& signal ) {
															#line 1448 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	new TagAndForwardActor<T, U>(pOutputPromise, value, signal);
															#line 18776 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1454 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 18781 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via tagAndForward()
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class TagAndForwardActor1>
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagAndForwardActor1State {
															#line 18788 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagAndForwardActor1State(PromiseStream<T>* const& pOutput,T const& value,Future<Void> const& signal) 
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : pOutput(pOutput),
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   value(value),
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   signal(signal)
															#line 18799 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("tagAndForward", reinterpret_cast<unsigned long>(this));

	}
	~TagAndForwardActor1State() 
	{
		fdb_probe_actor_destroy("tagAndForward", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1457 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = signal;
															#line 1457 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 18816 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			static_cast<TagAndForwardActor1*>(this)->actor_wait_state = 1;
															#line 1457 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TagAndForwardActor1, 0, Void >*>(static_cast<TagAndForwardActor1*>(this)));
															#line 18820 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		delete static_cast<TagAndForwardActor1*>(this);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		pOutput->send(std::move(value));
															#line 18842 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1458 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		pOutput->send(std::move(value));
															#line 18851 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TagAndForwardActor1*>(this)->actor_wait_state > 0) static_cast<TagAndForwardActor1*>(this)->actor_wait_state = 0;
		static_cast<TagAndForwardActor1*>(this)->ActorCallback< TagAndForwardActor1, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TagAndForwardActor1, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("tagAndForward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagAndForward", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TagAndForwardActor1, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("tagAndForward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagAndForward", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TagAndForwardActor1, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("tagAndForward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagAndForward", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		delete static_cast<TagAndForwardActor1*>(this);
															#line 18935 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		return 0;

		return loopDepth;
	}
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<T>* pOutput;
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	T value;
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> signal;
															#line 18946 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via tagAndForward()
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagAndForwardActor1 final : public Actor<void>, public ActorCallback< TagAndForwardActor1<T>, 0, Void >, public FastAllocated<TagAndForwardActor1<T>>, public TagAndForwardActor1State<T, TagAndForwardActor1<T>> {
															#line 18953 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TagAndForwardActor1<T>>::operator new;
	using FastAllocated<TagAndForwardActor1<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(12051730031383433216UL, 4912401754353579776UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() {{
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<void>*>(this)->~Actor();
        operator delete(this);
    }}
#pragma clang diagnostic pop
friend struct ActorCallback< TagAndForwardActor1<T>, 0, Void >;
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagAndForwardActor1(PromiseStream<T>* const& pOutput,T const& value,Future<Void> const& signal) 
															#line 18970 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<void>(),
		   TagAndForwardActor1State<T, TagAndForwardActor1<T>>(pOutput, value, signal),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("tagAndForward", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(8459484032539578624UL, 15900337457436081664UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("tagAndForward");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("tagAndForward", reinterpret_cast<unsigned long>(this), -1);

	}
};
} // namespace
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
void tagAndForward( PromiseStream<T>* const& pOutput, T const& value, Future<Void> const& signal ) {
															#line 1455 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	new TagAndForwardActor1<T>(pOutput, value, signal);
															#line 18996 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1460 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 19001 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via tagAndForwardError()
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class TagAndForwardErrorActor>
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagAndForwardErrorActorState {
															#line 19008 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagAndForwardErrorActorState(Promise<T>* const& pOutputPromise,Error const& value,Future<Void> const& signal) 
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : pOutputPromise(pOutputPromise),
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   value(value),
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   signal(signal),
															#line 1463 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   out(std::move(*pOutputPromise))
															#line 19021 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("tagAndForwardError", reinterpret_cast<unsigned long>(this));

	}
	~TagAndForwardErrorActorState() 
	{
		fdb_probe_actor_destroy("tagAndForwardError", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1464 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = signal;
															#line 1464 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 19038 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			static_cast<TagAndForwardErrorActor*>(this)->actor_wait_state = 1;
															#line 1464 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TagAndForwardErrorActor, 0, Void >*>(static_cast<TagAndForwardErrorActor*>(this)));
															#line 19042 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		delete static_cast<TagAndForwardErrorActor*>(this);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1465 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		out.sendError(value);
															#line 19064 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1465 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		out.sendError(value);
															#line 19073 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TagAndForwardErrorActor*>(this)->actor_wait_state > 0) static_cast<TagAndForwardErrorActor*>(this)->actor_wait_state = 0;
		static_cast<TagAndForwardErrorActor*>(this)->ActorCallback< TagAndForwardErrorActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TagAndForwardErrorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("tagAndForwardError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagAndForwardError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TagAndForwardErrorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("tagAndForwardError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagAndForwardError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TagAndForwardErrorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("tagAndForwardError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagAndForwardError", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		delete static_cast<TagAndForwardErrorActor*>(this);
															#line 19157 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		return 0;

		return loopDepth;
	}
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Promise<T>* pOutputPromise;
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Error value;
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> signal;
															#line 1463 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Promise<T> out;
															#line 19170 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via tagAndForwardError()
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagAndForwardErrorActor final : public Actor<void>, public ActorCallback< TagAndForwardErrorActor<T>, 0, Void >, public FastAllocated<TagAndForwardErrorActor<T>>, public TagAndForwardErrorActorState<T, TagAndForwardErrorActor<T>> {
															#line 19177 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TagAndForwardErrorActor<T>>::operator new;
	using FastAllocated<TagAndForwardErrorActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(16170573389767517440UL, 12677076695429227008UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() {{
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<void>*>(this)->~Actor();
        operator delete(this);
    }}
#pragma clang diagnostic pop
friend struct ActorCallback< TagAndForwardErrorActor<T>, 0, Void >;
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagAndForwardErrorActor(Promise<T>* const& pOutputPromise,Error const& value,Future<Void> const& signal) 
															#line 19194 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<void>(),
		   TagAndForwardErrorActorState<T, TagAndForwardErrorActor<T>>(pOutputPromise, value, signal),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("tagAndForwardError", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(3151343297505891328UL, 15752123845492404480UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("tagAndForwardError");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("tagAndForwardError", reinterpret_cast<unsigned long>(this), -1);

	}
};
} // namespace
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
void tagAndForwardError( Promise<T>* const& pOutputPromise, Error const& value, Future<Void> const& signal ) {
															#line 1461 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	new TagAndForwardErrorActor<T>(pOutputPromise, value, signal);
															#line 19220 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1467 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 19225 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via tagAndForwardError()
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class TagAndForwardErrorActor1>
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagAndForwardErrorActor1State {
															#line 19232 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagAndForwardErrorActor1State(PromiseStream<T>* const& pOutput,Error const& value,Future<Void> const& signal) 
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : pOutput(pOutput),
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   value(value),
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   signal(signal)
															#line 19243 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("tagAndForwardError", reinterpret_cast<unsigned long>(this));

	}
	~TagAndForwardErrorActor1State() 
	{
		fdb_probe_actor_destroy("tagAndForwardError", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1470 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = signal;
															#line 1470 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 19260 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			static_cast<TagAndForwardErrorActor1*>(this)->actor_wait_state = 1;
															#line 1470 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TagAndForwardErrorActor1, 0, Void >*>(static_cast<TagAndForwardErrorActor1*>(this)));
															#line 19264 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		delete static_cast<TagAndForwardErrorActor1*>(this);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1471 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		pOutput->sendError(value);
															#line 19286 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1471 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		pOutput->sendError(value);
															#line 19295 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TagAndForwardErrorActor1*>(this)->actor_wait_state > 0) static_cast<TagAndForwardErrorActor1*>(this)->actor_wait_state = 0;
		static_cast<TagAndForwardErrorActor1*>(this)->ActorCallback< TagAndForwardErrorActor1, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TagAndForwardErrorActor1, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("tagAndForwardError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardErrorActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagAndForwardError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TagAndForwardErrorActor1, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("tagAndForwardError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardErrorActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagAndForwardError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TagAndForwardErrorActor1, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("tagAndForwardError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardErrorActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tagAndForwardError", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		delete static_cast<TagAndForwardErrorActor1*>(this);
															#line 19379 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		return 0;

		return loopDepth;
	}
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<T>* pOutput;
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Error value;
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> signal;
															#line 19390 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via tagAndForwardError()
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TagAndForwardErrorActor1 final : public Actor<void>, public ActorCallback< TagAndForwardErrorActor1<T>, 0, Void >, public FastAllocated<TagAndForwardErrorActor1<T>>, public TagAndForwardErrorActor1State<T, TagAndForwardErrorActor1<T>> {
															#line 19397 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TagAndForwardErrorActor1<T>>::operator new;
	using FastAllocated<TagAndForwardErrorActor1<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(16170573389767517440UL, 12677076695429227008UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() {{
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<void>*>(this)->~Actor();
        operator delete(this);
    }}
#pragma clang diagnostic pop
friend struct ActorCallback< TagAndForwardErrorActor1<T>, 0, Void >;
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TagAndForwardErrorActor1(PromiseStream<T>* const& pOutput,Error const& value,Future<Void> const& signal) 
															#line 19414 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<void>(),
		   TagAndForwardErrorActor1State<T, TagAndForwardErrorActor1<T>>(pOutput, value, signal),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("tagAndForwardError", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(15803124157335763968UL, 10169567429264438272UL);
		ActorExecutionContextHelper __helper(static_cast<TagAndForwardErrorActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("tagAndForwardError");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("tagAndForwardError", reinterpret_cast<unsigned long>(this), -1);

	}
};
} // namespace
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
void tagAndForwardError( PromiseStream<T>* const& pOutput, Error const& value, Future<Void> const& signal ) {
															#line 1468 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	new TagAndForwardErrorActor1<T>(pOutput, value, signal);
															#line 19440 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1473 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 19445 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via waitOrError()
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class WaitOrErrorActor>
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class WaitOrErrorActorState {
															#line 19452 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	WaitOrErrorActorState(Future<T> const& f,Future<Void> const& errorSignal) 
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : f(f),
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   errorSignal(errorSignal)
															#line 19461 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("waitOrError", reinterpret_cast<unsigned long>(this));

	}
	~WaitOrErrorActorState() 
	{
		fdb_probe_actor_destroy("waitOrError", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1477 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = f;
															#line 1476 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<WaitOrErrorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 19478 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 1480 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_1 = errorSignal;
															#line 19482 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1when2(__when_expr_1.get(), loopDepth); };
			static_cast<WaitOrErrorActor*>(this)->actor_wait_state = 1;
															#line 1477 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WaitOrErrorActor, 0, T >*>(static_cast<WaitOrErrorActor*>(this)));
															#line 1480 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WaitOrErrorActor, 1, Void >*>(static_cast<WaitOrErrorActor*>(this)));
															#line 19489 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WaitOrErrorActorState();
		static_cast<WaitOrErrorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(T const& val,int loopDepth) 
	{
															#line 1478 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<WaitOrErrorActor*>(this)->SAV<T>::futures) { (void)(val); this->~WaitOrErrorActorState(); static_cast<WaitOrErrorActor*>(this)->destroy(); return 0; }
															#line 19512 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<WaitOrErrorActor*>(this)->SAV< T >::value()) T(val);
		this->~WaitOrErrorActorState();
		static_cast<WaitOrErrorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T && val,int loopDepth) 
	{
															#line 1478 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<WaitOrErrorActor*>(this)->SAV<T>::futures) { (void)(val); this->~WaitOrErrorActorState(); static_cast<WaitOrErrorActor*>(this)->destroy(); return 0; }
															#line 19524 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<WaitOrErrorActor*>(this)->SAV< T >::value()) T(val);
		this->~WaitOrErrorActorState();
		static_cast<WaitOrErrorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when2(Void const& _,int loopDepth) 
	{
															#line 1481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		ASSERT(false);
															#line 1482 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(internal_error(), loopDepth);
															#line 19538 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	int a_body1when2(Void && _,int loopDepth) 
	{
															#line 1481 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		ASSERT(false);
															#line 1482 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(internal_error(), loopDepth);
															#line 19548 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WaitOrErrorActor*>(this)->actor_wait_state > 0) static_cast<WaitOrErrorActor*>(this)->actor_wait_state = 0;
		static_cast<WaitOrErrorActor*>(this)->ActorCallback< WaitOrErrorActor, 0, T >::remove();
		static_cast<WaitOrErrorActor*>(this)->ActorCallback< WaitOrErrorActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitOrErrorActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("waitOrError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<WaitOrErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitOrError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WaitOrErrorActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("waitOrError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<WaitOrErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitOrError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WaitOrErrorActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("waitOrError", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<WaitOrErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitOrError", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WaitOrErrorActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitOrError", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<WaitOrErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitOrError", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< WaitOrErrorActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitOrError", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<WaitOrErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitOrError", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< WaitOrErrorActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitOrError", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<WaitOrErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitOrError", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> f;
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> errorSignal;
															#line 19677 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via waitOrError()
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class WaitOrErrorActor final : public Actor<T>, public ActorCallback< WaitOrErrorActor<T>, 0, T >, public ActorCallback< WaitOrErrorActor<T>, 1, Void >, public FastAllocated<WaitOrErrorActor<T>>, public WaitOrErrorActorState<T, WaitOrErrorActor<T>> {
															#line 19684 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<WaitOrErrorActor<T>>::operator new;
	using FastAllocated<WaitOrErrorActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(3601604594722269696UL, 14026684627329209344UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< WaitOrErrorActor<T>, 0, T >;
friend struct ActorCallback< WaitOrErrorActor<T>, 1, Void >;
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	WaitOrErrorActor(Future<T> const& f,Future<Void> const& errorSignal) 
															#line 19702 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   WaitOrErrorActorState<T, WaitOrErrorActor<T>>(f, errorSignal),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("waitOrError", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(79762681131002880UL, 13836279391833512448UL);
		ActorExecutionContextHelper __helper(static_cast<WaitOrErrorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("waitOrError");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("waitOrError", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WaitOrErrorActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> waitOrError( Future<T> const& f, Future<Void> const& errorSignal ) {
															#line 1474 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new WaitOrErrorActor<T>(f, errorSignal));
															#line 19737 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1486 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// A simple counter designed to track an ongoing count of something, such as how many actors are in a critical section,
// how many bytes are currently being processed, etc... Can be explicitly released idempotently, or will automatically
// release when destructed to handle actor ending or errors.
// Can be used for any type T so long as it has += and -= operators.

// Usage Example: tracking number of actors in code section
// ActiveCounter<int> counter;
//
//   state ActiveCounter::Releaser tracker = counter.take(1);
//   wait(perform my operation);
//   tracker.release();

template <class T>
struct ActiveCounter {
	struct Releaser : NonCopyable {
		ActiveCounter<T>* parent;
		T delta;
		std::function<void()> releaseCallback;

		Releaser() : parent(nullptr) {}
		Releaser(ActiveCounter<T>* parent, T delta, std::function<void()> releaseCallback)
		  : parent(parent), delta(delta), releaseCallback(releaseCallback) {
			parent->counter += delta;
		}
		Releaser(Releaser&& r) noexcept : parent(r.parent), delta(r.delta), releaseCallback(r.releaseCallback) {
			r.parent = nullptr;
		}
		void operator=(Releaser&& r) {
			release();
			parent = r.parent;
			delta = r.delta;
			releaseCallback = r.releaseCallback;
			r.parent = nullptr;
		}

		void release() {
			if (parent) {
				parent->counter -= delta;
				parent = nullptr;
				if (releaseCallback) {
					releaseCallback();
				}
			}
		}

		~Releaser() { release(); }
	};

	T counter;

	ActiveCounter(T initialValue) : counter(initialValue) {}

	T getValue() { return counter; }

	Releaser take(T delta, std::function<void()> releaseCallback = {}) {
		return Releaser(this, delta, releaseCallback);
	}
};

// A low-overhead FIFO mutex made with no internal queue structure (no list, deque, vector, etc)
// The lock is implemented as a Promise<Void>, which is returned to callers in a convenient wrapper
// called Lock.
//
// The default behavior is that if a Lock is droppped without error or release, existing and future
// waiters will see a broken_promise exception.
//
// If hangOnDroppedMutex is true, then if a Lock is dropped without error or release, existing and
// future waiters will never be signaled or see an error, equivalent to waiting on Never().
//
// Usage:
//   Lock lock = wait(mutex.take());
//   lock.release();  // Next waiter will get the lock, OR
//   lock.error(e);   // Next waiter will get e, future waiters will see broken_promise
//   lock = Lock();   // Or let Lock and any copies go out of scope.  All waiters will see broken_promise.
struct FlowMutex {
	FlowMutex(bool hangOnDroppedMutex = false) : hangOnDroppedMutex(hangOnDroppedMutex) { lastPromise.send(Void()); }

	bool available() const { return lastPromise.isSet(); }

	struct Lock {
		void release() { promise.send(Void()); }

		void error(Error e = broken_promise()) { promise.sendError(e); }

		// This is exposed in case the caller wants to use/copy it directly
		Promise<Void> promise;
	};

	Future<Lock> take() {
		Lock newLock;
		Future<Lock> f = lastPromise.isSet() ? newLock : tag(lastPromise.getFuture(), newLock);
		lastPromise = newLock.promise;
		if (hangOnDroppedMutex) {
			return brokenPromiseToNever(f);
		}
		return f;
	}

private:
	bool hangOnDroppedMutex;
	Promise<Void> lastPromise;
};

															#line 19845 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via forwardErrors()
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class V, class ForwardErrorsActor>
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ForwardErrorsActorState {
															#line 19852 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ForwardErrorsActorState(Future<T> const& f,PromiseStream<V> const& output) 
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : f(f),
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   output(output)
															#line 19861 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("forwardErrors", reinterpret_cast<unsigned long>(this));

	}
	~ForwardErrorsActorState() 
	{
		fdb_probe_actor_destroy("forwardErrors", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 1593 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = f;
															#line 1593 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<ForwardErrorsActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 19879 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<ForwardErrorsActor*>(this)->actor_wait_state = 1;
															#line 1593 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ForwardErrorsActor, 0, T >*>(static_cast<ForwardErrorsActor*>(this)));
															#line 19884 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ForwardErrorsActorState();
		static_cast<ForwardErrorsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1596 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output.sendError(e);
															#line 1597 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(e, loopDepth);
															#line 19916 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& val,int loopDepth) 
	{
															#line 1594 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ForwardErrorsActor*>(this)->SAV<T>::futures) { (void)(val); this->~ForwardErrorsActorState(); static_cast<ForwardErrorsActor*>(this)->destroy(); return 0; }
															#line 19930 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ForwardErrorsActor*>(this)->SAV< T >::value()) T(val);
		this->~ForwardErrorsActorState();
		static_cast<ForwardErrorsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(T && val,int loopDepth) 
	{
															#line 1594 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ForwardErrorsActor*>(this)->SAV<T>::futures) { (void)(val); this->~ForwardErrorsActorState(); static_cast<ForwardErrorsActor*>(this)->destroy(); return 0; }
															#line 19942 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ForwardErrorsActor*>(this)->SAV< T >::value()) T(val);
		this->~ForwardErrorsActorState();
		static_cast<ForwardErrorsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& val,int loopDepth) 
	{
		loopDepth = a_body1cont2(val, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && val,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(val), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ForwardErrorsActor*>(this)->actor_wait_state > 0) static_cast<ForwardErrorsActor*>(this)->actor_wait_state = 0;
		static_cast<ForwardErrorsActor*>(this)->ActorCallback< ForwardErrorsActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< ForwardErrorsActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("forwardErrors", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardErrorsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forwardErrors", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ForwardErrorsActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("forwardErrors", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardErrorsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forwardErrors", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ForwardErrorsActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("forwardErrors", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardErrorsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forwardErrors", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> f;
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<V> output;
															#line 20029 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via forwardErrors()
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class V>
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ForwardErrorsActor final : public Actor<T>, public ActorCallback< ForwardErrorsActor<T, V>, 0, T >, public FastAllocated<ForwardErrorsActor<T, V>>, public ForwardErrorsActorState<T, V, ForwardErrorsActor<T, V>> {
															#line 20036 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<ForwardErrorsActor<T, V>>::operator new;
	using FastAllocated<ForwardErrorsActor<T, V>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(4316573021333848832UL, 2217191894508558848UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< ForwardErrorsActor<T, V>, 0, T >;
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ForwardErrorsActor(Future<T> const& f,PromiseStream<V> const& output) 
															#line 20053 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   ForwardErrorsActorState<T, V, ForwardErrorsActor<T, V>>(f, output),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("forwardErrors", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(4115760443657310976UL, 9191871435056424192UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardErrorsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("forwardErrors");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("forwardErrors", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ForwardErrorsActor<T, V>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class V>
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> forwardErrors( Future<T> const& f, PromiseStream<V> const& output ) {
															#line 1590 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new ForwardErrorsActor<T, V>(f, output));
															#line 20088 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1600 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

struct FlowLock : NonCopyable, public ReferenceCounted<FlowLock> {
	// FlowLock implements a nonblocking critical section: there can be only a limited number of clients executing code
	// between wait(take()) and release(). Not thread safe. take() returns only when the number of holders of the lock
	// is fewer than the number of permits, and release() makes the caller no longer a holder of the lock. release()
	// only runs waiting take()rs after the caller wait()s

	struct Releaser : NonCopyable {
		FlowLock* lock;
		int remaining;
		Releaser() : lock(0), remaining(0) {}
		Releaser(FlowLock& lock, int64_t amount = 1) : lock(&lock), remaining(amount) {}
		Releaser(Releaser&& r) noexcept : lock(r.lock), remaining(r.remaining) { r.remaining = 0; }
		void operator=(Releaser&& r) {
			if (remaining)
				lock->release(remaining);
			lock = r.lock;
			remaining = r.remaining;
			r.remaining = 0;
		}

		void release(int64_t amount = -1) {
			if (amount == -1 || amount > remaining)
				amount = remaining;

			if (remaining)
				lock->release(amount);
			remaining -= amount;
		}

		~Releaser() {
			if (remaining)
				lock->release(remaining);
		}
	};

	FlowLock() : permits(1), active(0) {}
	explicit FlowLock(int64_t permits) : permits(permits), active(0) {}

	Future<Void> take(TaskPriority taskID = TaskPriority::DefaultYield, int64_t amount = 1) {
		if (active + amount <= permits || active == 0) {
			active += amount;
			return safeYieldActor(this, taskID, amount);
		}
		return takeActor(this, taskID, amount);
	}
	void release(int64_t amount = 1) {
		ASSERT((active > 0 || amount == 0) && active - amount >= 0);
		active -= amount;

		while (!takers.empty()) {
			if (active + takers.begin()->second <= permits || active == 0) {
				std::pair<Promise<Void>, int64_t> next = std::move(*takers.begin());
				active += next.second;
				takers.pop_front();
				next.first.send(Void());
			} else {
				break;
			}
		}
	}

	Future<Void> releaseWhen(Future<Void> const& signal, int amount = 1) {
		return releaseWhenActor(this, signal, amount);
	}

	// returns when any permits are available, having taken as many as possible up to the given amount, and modifies
	// amount to the number of permits taken
	Future<Void> takeUpTo(int64_t& amount) { return takeMoreActor(this, &amount); }

	int64_t available() const { return permits - active; }
	int64_t activePermits() const { return active; }
	int waiters() const { return takers.size(); }

	// Try to send error to all current and future waiters
	// Only works if broken_on_destruct.canBeSet()
	void kill(Error e = broken_promise()) {
		if (broken_on_destruct.canBeSet()) {
			auto local = broken_on_destruct;
			// It could be the case that calling broken_on_destruct destroys this FlowLock
			local.sendError(e);
		}
	}

private:
	std::list<std::pair<Promise<Void>, int64_t>> takers;
	const int64_t permits;
	int64_t active;
	Promise<Void> broken_on_destruct;

																#line 20182 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
// This generated class is to be used only via takeActor()
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class TakeActorActor>
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TakeActorActorState {
															#line 20188 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TakeActorActorState(FlowLock* const& lock,TaskPriority const& taskID,int64_t const& amount) 
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : lock(lock),
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   taskID(taskID),
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   amount(amount),
															#line 1691 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   it(lock->takers.emplace(lock->takers.end(), Promise<Void>(), amount))
															#line 20201 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("takeActor", reinterpret_cast<unsigned long>(this));

	}
	~TakeActorActorState() 
	{
		fdb_probe_actor_destroy("takeActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 1695 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<Void> __when_expr_0 = it->first.getFuture();
															#line 1695 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<TakeActorActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 20219 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<TakeActorActor*>(this)->actor_wait_state = 1;
															#line 1695 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TakeActorActor, 0, Void >*>(static_cast<TakeActorActor*>(this)));
															#line 20224 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TakeActorActorState();
		static_cast<TakeActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
		try {
															#line 1704 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			double duration = BUGGIFY_WITH_PROB(.001) ? deterministicRandom()->random01() * FLOW_KNOBS->BUGGIFY_FLOW_LOCK_RELEASE_DELAY : 0.0;
															#line 1708 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_1 = delay(duration, taskID);
															#line 1707 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<TakeActorActor*>(this)->actor_wait_state < 0) return a_body1cont1Catch1(actor_cancelled(), loopDepth);
															#line 20258 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1cont1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
															#line 1710 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_2 = lock->broken_on_destruct.getFuture();
															#line 20262 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1when2(__when_expr_2.get(), loopDepth); };
			static_cast<TakeActorActor*>(this)->actor_wait_state = 2;
															#line 1708 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< TakeActorActor, 1, Void >*>(static_cast<TakeActorActor*>(this)));
															#line 1710 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< TakeActorActor, 2, Void >*>(static_cast<TakeActorActor*>(this)));
															#line 20269 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1697 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == error_code_actor_cancelled)
															#line 20285 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 1698 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				lock->takers.erase(it);
															#line 1699 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				lock->release(0);
															#line 20291 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 1701 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(e, loopDepth);
															#line 20295 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TakeActorActor*>(this)->actor_wait_state > 0) static_cast<TakeActorActor*>(this)->actor_wait_state = 0;
		static_cast<TakeActorActor*>(this)->ActorCallback< TakeActorActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TakeActorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TakeActorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TakeActorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1Catch1(const Error& __current_error,int loopDepth=0) 
	{
		try {
															#line 1714 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			CODE_PROBE(true, "If we get cancelled here, we are holding the lock but the caller doesn't know, so release it");
															#line 1716 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			lock->release(amount);
															#line 1717 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(__current_error, loopDepth);
															#line 20414 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont5(int loopDepth) 
	{
															#line 1712 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TakeActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TakeActorActorState(); static_cast<TakeActorActor*>(this)->destroy(); return 0; }
															#line 20428 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TakeActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~TakeActorActorState();
		static_cast<TakeActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<TakeActorActor*>(this)->actor_wait_state > 0) static_cast<TakeActorActor*>(this)->actor_wait_state = 0;
		static_cast<TakeActorActor*>(this)->ActorCallback< TakeActorActor, 1, Void >::remove();
		static_cast<TakeActorActor*>(this)->ActorCallback< TakeActorActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TakeActorActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< TakeActorActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< TakeActorActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< TakeActorActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when2(value, 0);
		}
		catch (Error& error) {
			a_body1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< TakeActorActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< TakeActorActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FlowLock* lock;
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TaskPriority taskID;
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	int64_t amount;
															#line 1691 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	std::list<std::pair<Promise<Void>, int64_t>>::iterator it;
															#line 20589 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via takeActor()
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TakeActorActor final : public Actor<Void>, public ActorCallback< TakeActorActor, 0, Void >, public ActorCallback< TakeActorActor, 1, Void >, public ActorCallback< TakeActorActor, 2, Void >, public FastAllocated<TakeActorActor>, public TakeActorActorState<TakeActorActor> {
															#line 20594 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TakeActorActor>::operator new;
	using FastAllocated<TakeActorActor>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(7148833908383611136UL, 3724253158014701824UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TakeActorActor, 0, Void >;
friend struct ActorCallback< TakeActorActor, 1, Void >;
friend struct ActorCallback< TakeActorActor, 2, Void >;
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TakeActorActor(FlowLock* const& lock,TaskPriority const& taskID,int64_t const& amount) 
															#line 20613 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   TakeActorActorState<TakeActorActor>(lock, taskID, amount),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(6347082023303909632UL, 4484442138313995008UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("takeActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TakeActorActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< TakeActorActor, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] static Future<Void> takeActor( FlowLock* const& lock, TaskPriority const& taskID, int64_t const& amount ) {
															#line 1690 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new TakeActorActor(lock, taskID, amount));
															#line 20646 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1720 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

																#line 20651 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
// This generated class is to be used only via takeMoreActor()
															#line 1721 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class TakeMoreActorActor>
															#line 1721 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TakeMoreActorActorState {
															#line 20657 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1721 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TakeMoreActorActorState(FlowLock* const& lock,int64_t* const& amount) 
															#line 1721 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1721 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : lock(lock),
															#line 1721 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   amount(amount)
															#line 20666 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("takeMoreActor", reinterpret_cast<unsigned long>(this));

	}
	~TakeMoreActorActorState() 
	{
		fdb_probe_actor_destroy("takeMoreActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1722 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = lock->take();
															#line 1722 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<TakeMoreActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 20683 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<TakeMoreActorActor*>(this)->actor_wait_state = 1;
															#line 1722 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TakeMoreActorActor, 0, Void >*>(static_cast<TakeMoreActorActor*>(this)));
															#line 20688 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TakeMoreActorActorState();
		static_cast<TakeMoreActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1723 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		int64_t extra = std::min(lock->available(), *amount - 1);
															#line 1724 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		lock->active += extra;
															#line 1725 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		*amount = 1 + extra;
															#line 1726 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TakeMoreActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TakeMoreActorActorState(); static_cast<TakeMoreActorActor*>(this)->destroy(); return 0; }
															#line 20717 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TakeMoreActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~TakeMoreActorActorState();
		static_cast<TakeMoreActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1723 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		int64_t extra = std::min(lock->available(), *amount - 1);
															#line 1724 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		lock->active += extra;
															#line 1725 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		*amount = 1 + extra;
															#line 1726 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TakeMoreActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TakeMoreActorActorState(); static_cast<TakeMoreActorActor*>(this)->destroy(); return 0; }
															#line 20735 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TakeMoreActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~TakeMoreActorActorState();
		static_cast<TakeMoreActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TakeMoreActorActor*>(this)->actor_wait_state > 0) static_cast<TakeMoreActorActor*>(this)->actor_wait_state = 0;
		static_cast<TakeMoreActorActor*>(this)->ActorCallback< TakeMoreActorActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TakeMoreActorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("takeMoreActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TakeMoreActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeMoreActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TakeMoreActorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("takeMoreActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TakeMoreActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeMoreActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TakeMoreActorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("takeMoreActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TakeMoreActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeMoreActor", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1721 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FlowLock* lock;
															#line 1721 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	int64_t* amount;
															#line 20822 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via takeMoreActor()
															#line 1721 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TakeMoreActorActor final : public Actor<Void>, public ActorCallback< TakeMoreActorActor, 0, Void >, public FastAllocated<TakeMoreActorActor>, public TakeMoreActorActorState<TakeMoreActorActor> {
															#line 20827 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TakeMoreActorActor>::operator new;
	using FastAllocated<TakeMoreActorActor>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(60493824955204096UL, 14500429299133195264UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TakeMoreActorActor, 0, Void >;
															#line 1721 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TakeMoreActorActor(FlowLock* const& lock,int64_t* const& amount) 
															#line 20844 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   TakeMoreActorActorState<TakeMoreActorActor>(lock, amount),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("takeMoreActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(14436708785559185664UL, 18066552745289739776UL);
		ActorExecutionContextHelper __helper(static_cast<TakeMoreActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("takeMoreActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("takeMoreActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TakeMoreActorActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1721 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] static Future<Void> takeMoreActor( FlowLock* const& lock, int64_t* const& amount ) {
															#line 1721 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new TakeMoreActorActor(lock, amount));
															#line 20876 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1728 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

																#line 20881 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
// This generated class is to be used only via safeYieldActor()
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class SafeYieldActorActor>
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class SafeYieldActorActorState {
															#line 20887 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	SafeYieldActorActorState(FlowLock* const& lock,TaskPriority const& taskID,int64_t const& amount) 
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : lock(lock),
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   taskID(taskID),
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   amount(amount)
															#line 20898 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("safeYieldActor", reinterpret_cast<unsigned long>(this));

	}
	~SafeYieldActorActorState() 
	{
		fdb_probe_actor_destroy("safeYieldActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 1732 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<Void> __when_expr_0 = yield(taskID);
															#line 1731 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<SafeYieldActorActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 20916 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 1733 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<Void> __when_expr_1 = lock->broken_on_destruct.getFuture();
															#line 20920 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), loopDepth); else return a_body1when2(__when_expr_1.get(), loopDepth); };
				static_cast<SafeYieldActorActor*>(this)->actor_wait_state = 1;
															#line 1732 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SafeYieldActorActor, 0, Void >*>(static_cast<SafeYieldActorActor*>(this)));
															#line 1733 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< SafeYieldActorActor, 1, Void >*>(static_cast<SafeYieldActorActor*>(this)));
															#line 20927 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SafeYieldActorActorState();
		static_cast<SafeYieldActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1737 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			lock->release(amount);
															#line 1738 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(e, loopDepth);
															#line 20959 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(int loopDepth) 
	{
															#line 1735 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<SafeYieldActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SafeYieldActorActorState(); static_cast<SafeYieldActorActor*>(this)->destroy(); return 0; }
															#line 20973 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<SafeYieldActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SafeYieldActorActorState();
		static_cast<SafeYieldActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SafeYieldActorActor*>(this)->actor_wait_state > 0) static_cast<SafeYieldActorActor*>(this)->actor_wait_state = 0;
		static_cast<SafeYieldActorActor*>(this)->ActorCallback< SafeYieldActorActor, 0, Void >::remove();
		static_cast<SafeYieldActorActor*>(this)->ActorCallback< SafeYieldActorActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SafeYieldActorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("safeYieldActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SafeYieldActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("safeYieldActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SafeYieldActorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("safeYieldActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SafeYieldActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("safeYieldActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SafeYieldActorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("safeYieldActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<SafeYieldActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("safeYieldActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SafeYieldActorActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("safeYieldActor", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SafeYieldActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("safeYieldActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< SafeYieldActorActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("safeYieldActor", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<SafeYieldActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("safeYieldActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< SafeYieldActorActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("safeYieldActor", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<SafeYieldActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("safeYieldActor", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FlowLock* lock;
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TaskPriority taskID;
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	int64_t amount;
															#line 21132 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via safeYieldActor()
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class SafeYieldActorActor final : public Actor<Void>, public ActorCallback< SafeYieldActorActor, 0, Void >, public ActorCallback< SafeYieldActorActor, 1, Void >, public FastAllocated<SafeYieldActorActor>, public SafeYieldActorActorState<SafeYieldActorActor> {
															#line 21137 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<SafeYieldActorActor>::operator new;
	using FastAllocated<SafeYieldActorActor>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(1025260330583155712UL, 16741171551976815360UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< SafeYieldActorActor, 0, Void >;
friend struct ActorCallback< SafeYieldActorActor, 1, Void >;
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	SafeYieldActorActor(FlowLock* const& lock,TaskPriority const& taskID,int64_t const& amount) 
															#line 21155 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   SafeYieldActorActorState<SafeYieldActorActor>(lock, taskID, amount),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("safeYieldActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(10563017388901251584UL, 5628032856404427008UL);
		ActorExecutionContextHelper __helper(static_cast<SafeYieldActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("safeYieldActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("safeYieldActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SafeYieldActorActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] static Future<Void> safeYieldActor( FlowLock* const& lock, TaskPriority const& taskID, int64_t const& amount ) {
															#line 1729 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new SafeYieldActorActor(lock, taskID, amount));
															#line 21187 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1741 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

																#line 21192 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
// This generated class is to be used only via releaseWhenActor()
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class ReleaseWhenActorActor>
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ReleaseWhenActorActorState {
															#line 21198 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ReleaseWhenActorActorState(FlowLock* const& self,Future<Void> const& signal,int64_t const& amount) 
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : self(self),
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   signal(signal),
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   amount(amount)
															#line 21209 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("releaseWhenActor", reinterpret_cast<unsigned long>(this));

	}
	~ReleaseWhenActorActorState() 
	{
		fdb_probe_actor_destroy("releaseWhenActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1743 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = signal;
															#line 1743 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<ReleaseWhenActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 21226 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<ReleaseWhenActorActor*>(this)->actor_wait_state = 1;
															#line 1743 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ReleaseWhenActorActor, 0, Void >*>(static_cast<ReleaseWhenActorActor*>(this)));
															#line 21231 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ReleaseWhenActorActorState();
		static_cast<ReleaseWhenActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1744 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		self->release(amount);
															#line 1745 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ReleaseWhenActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~ReleaseWhenActorActorState(); static_cast<ReleaseWhenActorActor*>(this)->destroy(); return 0; }
															#line 21256 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ReleaseWhenActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~ReleaseWhenActorActorState();
		static_cast<ReleaseWhenActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1744 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		self->release(amount);
															#line 1745 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ReleaseWhenActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~ReleaseWhenActorActorState(); static_cast<ReleaseWhenActorActor*>(this)->destroy(); return 0; }
															#line 21270 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ReleaseWhenActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~ReleaseWhenActorActorState();
		static_cast<ReleaseWhenActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ReleaseWhenActorActor*>(this)->actor_wait_state > 0) static_cast<ReleaseWhenActorActor*>(this)->actor_wait_state = 0;
		static_cast<ReleaseWhenActorActor*>(this)->ActorCallback< ReleaseWhenActorActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ReleaseWhenActorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("releaseWhenActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ReleaseWhenActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("releaseWhenActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ReleaseWhenActorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("releaseWhenActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ReleaseWhenActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("releaseWhenActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ReleaseWhenActorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("releaseWhenActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ReleaseWhenActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("releaseWhenActor", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FlowLock* self;
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> signal;
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	int64_t amount;
															#line 21359 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via releaseWhenActor()
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ReleaseWhenActorActor final : public Actor<Void>, public ActorCallback< ReleaseWhenActorActor, 0, Void >, public FastAllocated<ReleaseWhenActorActor>, public ReleaseWhenActorActorState<ReleaseWhenActorActor> {
															#line 21364 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<ReleaseWhenActorActor>::operator new;
	using FastAllocated<ReleaseWhenActorActor>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(13822806039593506816UL, 18145170070334025216UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< ReleaseWhenActorActor, 0, Void >;
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ReleaseWhenActorActor(FlowLock* const& self,Future<Void> const& signal,int64_t const& amount) 
															#line 21381 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   ReleaseWhenActorActorState<ReleaseWhenActorActor>(self, signal, amount),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("releaseWhenActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(3864255450375503360UL, 8175305417571884544UL);
		ActorExecutionContextHelper __helper(static_cast<ReleaseWhenActorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("releaseWhenActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("releaseWhenActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ReleaseWhenActorActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] static Future<Void> releaseWhenActor( FlowLock* const& self, Future<Void> const& signal, int64_t const& amount ) {
															#line 1742 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new ReleaseWhenActorActor(self, signal, amount));
															#line 21413 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1747 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
};

struct NotifiedInt {
	NotifiedInt(int64_t val = 0) : val(val) {}

	Future<Void> whenAtLeast(int64_t limit) {
		if (val >= limit)
			return Void();
		Promise<Void> p;
		waiting.emplace(limit, p);
		return p.getFuture();
	}

	int64_t get() const { return val; }

	void set(int64_t v) {
		ASSERT(v >= val);
		if (v != val) {
			val = v;

			std::vector<Promise<Void>> toSend;
			while (waiting.size() && v >= waiting.top().first) {
				Promise<Void> p = std::move(waiting.top().second);
				waiting.pop();
				toSend.push_back(p);
			}
			for (auto& p : toSend) {
				p.send(Void());
			}
		}
	}

	void operator=(int64_t v) { set(v); }

	NotifiedInt(NotifiedInt&& r) noexcept : waiting(std::move(r.waiting)), val(r.val) {}
	void operator=(NotifiedInt&& r) noexcept {
		waiting = std::move(r.waiting);
		val = r.val;
	}

private:
	typedef std::pair<int64_t, Promise<Void>> Item;
	struct ItemCompare {
		bool operator()(const Item& a, const Item& b) { return a.first > b.first; }
	};
	std::priority_queue<Item, std::vector<Item>, ItemCompare> waiting;
	int64_t val;
};

struct BoundedFlowLock : NonCopyable, public ReferenceCounted<BoundedFlowLock> {
	// BoundedFlowLock is different from a FlowLock in that it has a bound on how many locks can be taken from the
	// oldest outstanding lock. For instance, with a FlowLock that has two permits, if one permit is taken but never
	// released, the other permit can be reused an unlimited amount of times, but with a BoundedFlowLock, it can only be
	// reused a fixed number of times.

	struct Releaser : NonCopyable {
		BoundedFlowLock* lock;
		int64_t permitNumber;
		Releaser() : lock(nullptr), permitNumber(0) {}
		Releaser(BoundedFlowLock* lock, int64_t permitNumber) : lock(lock), permitNumber(permitNumber) {}
		Releaser(Releaser&& r) noexcept : lock(r.lock), permitNumber(r.permitNumber) { r.permitNumber = 0; }
		void operator=(Releaser&& r) {
			if (permitNumber)
				lock->release(permitNumber);
			lock = r.lock;
			permitNumber = r.permitNumber;
			r.permitNumber = 0;
		}

		void release() {
			if (permitNumber) {
				lock->release(permitNumber);
			}
			permitNumber = 0;
		}

		~Releaser() {
			if (permitNumber)
				lock->release(permitNumber);
		}
	};

	BoundedFlowLock() : minOutstanding(0), nextPermitNumber(0), unrestrictedPermits(1), boundedPermits(0) {}
	explicit BoundedFlowLock(int64_t unrestrictedPermits, int64_t boundedPermits)
	  : minOutstanding(0), nextPermitNumber(0), unrestrictedPermits(unrestrictedPermits),
	    boundedPermits(boundedPermits) {}

	Future<int64_t> take() { return takeActor(this); }
	void release(int64_t permitNumber) {
		outstanding.erase(permitNumber);
		updateMinOutstanding();
	}

private:
	IndexedSet<int64_t, int64_t> outstanding;
	NotifiedInt minOutstanding;
	int64_t nextPermitNumber;
	const int64_t unrestrictedPermits;
	const int64_t boundedPermits;

	void updateMinOutstanding() {
		auto it = outstanding.index(unrestrictedPermits - 1);
		if (it == outstanding.end()) {
			minOutstanding.set(nextPermitNumber);
		} else {
			minOutstanding.set(*it);
		}
	}

																#line 21526 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
// This generated class is to be used only via takeActor()
															#line 1856 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class TakeActorActor1>
															#line 1856 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TakeActorActor1State {
															#line 21532 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1856 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TakeActorActor1State(BoundedFlowLock* const& lock) 
															#line 1856 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1856 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : lock(lock),
															#line 1857 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   permitNumber(++lock->nextPermitNumber)
															#line 21541 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("takeActor", reinterpret_cast<unsigned long>(this));

	}
	~TakeActorActor1State() 
	{
		fdb_probe_actor_destroy("takeActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1858 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			lock->outstanding.insert(permitNumber, 1);
															#line 1859 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			lock->updateMinOutstanding();
															#line 1860 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = lock->minOutstanding.whenAtLeast(std::max<int64_t>(0, permitNumber - lock->boundedPermits));
															#line 1860 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<TakeActorActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 21562 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<TakeActorActor1*>(this)->actor_wait_state = 1;
															#line 1860 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TakeActorActor1, 0, Void >*>(static_cast<TakeActorActor1*>(this)));
															#line 21567 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TakeActorActor1State();
		static_cast<TakeActorActor1*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1861 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TakeActorActor1*>(this)->SAV<int64_t>::futures) { (void)(permitNumber); this->~TakeActorActor1State(); static_cast<TakeActorActor1*>(this)->destroy(); return 0; }
															#line 21590 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TakeActorActor1*>(this)->SAV< int64_t >::value()) int64_t(std::move(permitNumber)); // state_var_RVO
		this->~TakeActorActor1State();
		static_cast<TakeActorActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1861 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TakeActorActor1*>(this)->SAV<int64_t>::futures) { (void)(permitNumber); this->~TakeActorActor1State(); static_cast<TakeActorActor1*>(this)->destroy(); return 0; }
															#line 21602 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TakeActorActor1*>(this)->SAV< int64_t >::value()) int64_t(std::move(permitNumber)); // state_var_RVO
		this->~TakeActorActor1State();
		static_cast<TakeActorActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TakeActorActor1*>(this)->actor_wait_state > 0) static_cast<TakeActorActor1*>(this)->actor_wait_state = 0;
		static_cast<TakeActorActor1*>(this)->ActorCallback< TakeActorActor1, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TakeActorActor1, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TakeActorActor1, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TakeActorActor1, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1856 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	BoundedFlowLock* lock;
															#line 1857 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	int64_t permitNumber;
															#line 21689 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via takeActor()
															#line 1856 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TakeActorActor1 final : public Actor<int64_t>, public ActorCallback< TakeActorActor1, 0, Void >, public FastAllocated<TakeActorActor1>, public TakeActorActor1State<TakeActorActor1> {
															#line 21694 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TakeActorActor1>::operator new;
	using FastAllocated<TakeActorActor1>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(7148833908383611136UL, 3724253158014701824UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<int64_t>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TakeActorActor1, 0, Void >;
															#line 1856 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TakeActorActor1(BoundedFlowLock* const& lock) 
															#line 21711 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<int64_t>(),
		   TakeActorActor1State<TakeActorActor1>(lock),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("takeActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(11162012666822952704UL, 804007398116564480UL);
		ActorExecutionContextHelper __helper(static_cast<TakeActorActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("takeActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("takeActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TakeActorActor1, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1856 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] static Future<int64_t> takeActor( BoundedFlowLock* const& lock ) {
															#line 1856 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<int64_t>(new TakeActorActor1(lock));
															#line 21743 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1863 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
};

															#line 21749 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via yieldPromiseStream()
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class YieldPromiseStreamActor>
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class YieldPromiseStreamActorState {
															#line 21756 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	YieldPromiseStreamActorState(FutureStream<T> const& input,PromiseStream<T> const& output,TaskPriority const& taskID = TaskPriority::DefaultYield) 
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : input(input),
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   output(output),
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   taskID(taskID)
															#line 21767 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("yieldPromiseStream", reinterpret_cast<unsigned long>(this));

	}
	~YieldPromiseStreamActorState() 
	{
		fdb_probe_actor_destroy("yieldPromiseStream", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1869 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 21782 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~YieldPromiseStreamActorState();
		static_cast<YieldPromiseStreamActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 1870 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		FutureStream<T> __when_expr_0 = input;
															#line 1870 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<YieldPromiseStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 21814 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.pop(), loopDepth); };
		static_cast<YieldPromiseStreamActor*>(this)->actor_wait_state = 1;
															#line 1870 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< YieldPromiseStreamActor, 0, T >*>(static_cast<YieldPromiseStreamActor*>(this)));
															#line 21819 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(T const& f,int loopDepth) 
	{
															#line 1871 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(f);
															#line 1872 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_1 = yield(taskID);
															#line 1872 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<YieldPromiseStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 21832 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<YieldPromiseStreamActor*>(this)->actor_wait_state = 2;
															#line 1872 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< YieldPromiseStreamActor, 1, Void >*>(static_cast<YieldPromiseStreamActor*>(this)));
															#line 21837 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(T && f,int loopDepth) 
	{
															#line 1871 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(f);
															#line 1872 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_1 = yield(taskID);
															#line 1872 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<YieldPromiseStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 21850 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<YieldPromiseStreamActor*>(this)->actor_wait_state = 2;
															#line 1872 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< YieldPromiseStreamActor, 1, Void >*>(static_cast<YieldPromiseStreamActor*>(this)));
															#line 21855 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(T const& f,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(f, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T && f,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(f), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<YieldPromiseStreamActor*>(this)->actor_wait_state > 0) static_cast<YieldPromiseStreamActor*>(this)->actor_wait_state = 0;
		static_cast<YieldPromiseStreamActor*>(this)->ActorSingleCallback< YieldPromiseStreamActor, 0, T >::remove();

	}
	void a_callback_fire(ActorSingleCallback< YieldPromiseStreamActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("yieldPromiseStream", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<YieldPromiseStreamActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("yieldPromiseStream", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< YieldPromiseStreamActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("yieldPromiseStream", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<YieldPromiseStreamActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("yieldPromiseStream", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< YieldPromiseStreamActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("yieldPromiseStream", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<YieldPromiseStreamActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("yieldPromiseStream", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(Void const& _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void && _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<YieldPromiseStreamActor*>(this)->actor_wait_state > 0) static_cast<YieldPromiseStreamActor*>(this)->actor_wait_state = 0;
		static_cast<YieldPromiseStreamActor*>(this)->ActorCallback< YieldPromiseStreamActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< YieldPromiseStreamActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("yieldPromiseStream", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<YieldPromiseStreamActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("yieldPromiseStream", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< YieldPromiseStreamActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("yieldPromiseStream", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<YieldPromiseStreamActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("yieldPromiseStream", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< YieldPromiseStreamActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("yieldPromiseStream", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<YieldPromiseStreamActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("yieldPromiseStream", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FutureStream<T> input;
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<T> output;
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TaskPriority taskID;
															#line 22028 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via yieldPromiseStream()
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class YieldPromiseStreamActor final : public Actor<Void>, public ActorSingleCallback< YieldPromiseStreamActor<T>, 0, T >, public ActorCallback< YieldPromiseStreamActor<T>, 1, Void >, public FastAllocated<YieldPromiseStreamActor<T>>, public YieldPromiseStreamActorState<T, YieldPromiseStreamActor<T>> {
															#line 22035 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<YieldPromiseStreamActor<T>>::operator new;
	using FastAllocated<YieldPromiseStreamActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(15289381197486347264UL, 9535141431537464576UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< YieldPromiseStreamActor<T>, 0, T >;
friend struct ActorCallback< YieldPromiseStreamActor<T>, 1, Void >;
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	YieldPromiseStreamActor(FutureStream<T> const& input,PromiseStream<T> const& output,TaskPriority const& taskID = TaskPriority::DefaultYield) 
															#line 22053 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   YieldPromiseStreamActorState<T, YieldPromiseStreamActor<T>>(input, output, taskID),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("yieldPromiseStream", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(18355913032905922816UL, 6942837055676937216UL);
		ActorExecutionContextHelper __helper(static_cast<YieldPromiseStreamActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("yieldPromiseStream");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("yieldPromiseStream", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< YieldPromiseStreamActor<T>, 0, T >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< YieldPromiseStreamActor<T>, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> yieldPromiseStream( FutureStream<T> const& input, PromiseStream<T> const& output, TaskPriority const& taskID = TaskPriority::DefaultYield ) {
															#line 1865 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new YieldPromiseStreamActor<T>(input, output, taskID));
															#line 22089 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1875 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

struct YieldedFutureActor final : SAV<Void>,
                                  ActorCallback<YieldedFutureActor, 1, Void>,
                                  FastAllocated<YieldedFutureActor> {
	Error in_error_state;

	typedef ActorCallback<YieldedFutureActor, 1, Void> CB1;

	using FastAllocated<YieldedFutureActor>::operator new;
	using FastAllocated<YieldedFutureActor>::operator delete;

	YieldedFutureActor(Future<Void>&& f) : SAV<Void>(1, 1), in_error_state(Error::fromCode(UNSET_ERROR_CODE)) {
		f.addYieldedCallbackAndClear(static_cast<ActorCallback<YieldedFutureActor, 1, Void>*>(this));
	}

	void cancel() override {
		if (!SAV<Void>::canBeSet())
			return; // Cancel could be invoked *by* a callback within finish().  Otherwise it's guaranteed that we are
			        // waiting either on the original future or on a delay().
		ActorCallback<YieldedFutureActor, 1, Void>::remove();
		SAV<Void>::sendErrorAndDelPromiseRef(actor_cancelled());
	}

	void destroy() override { delete this; }

#ifdef ENABLE_SAMPLING
	LineageReference* lineageAddr() { return currentLineage; }
#endif

	void a_callback_fire(ActorCallback<YieldedFutureActor, 1, Void>*, Void) {
		if (int16_t(in_error_state.code()) == UNSET_ERROR_CODE) {
			in_error_state = Error::fromCode(SET_ERROR_CODE);
			if (check_yield())
				doYield();
			else
				finish();
		} else {
			// We hit this case when and only when the delay() created by a previous doYield() fires.  Then we want to
			// get at least one task done, regardless of what check_yield() would say.
			finish();
		}
	}
	void a_callback_error(ActorCallback<YieldedFutureActor, 1, Void>*, Error const& err) {
		ASSERT(int16_t(in_error_state.code()) == UNSET_ERROR_CODE);
		in_error_state = err;
		if (check_yield())
			doYield();
		else
			finish();
	}
	void finish() {
		ActorCallback<YieldedFutureActor, 1, Void>::remove();
		if (int16_t(in_error_state.code()) == SET_ERROR_CODE)
			SAV<Void>::sendAndDelPromiseRef(Void());
		else
			SAV<Void>::sendErrorAndDelPromiseRef(in_error_state);
	}
	void doYield() {
		// Since we are being fired, we are the first callback in the ring, and `prev` is the source future
		Callback<Void>* source = CB1::prev;
		ASSERT(source->next == static_cast<CB1*>(this));

		// Remove the source future from the ring.  All the remaining callbacks in the ring should be yielded, since
		// yielded callbacks are installed at the end
		CB1::prev = source->prev;
		CB1::prev->next = static_cast<CB1*>(this);

		// The source future's ring is now empty, since we have removed all the callbacks
		source->next = source->prev = source;
		source->unwait();

		// Link all the callbacks, including this one, into the ring of a delay future so that after a short time they
		// will be fired again
		delay(0, g_network->getCurrentTask()).addCallbackChainAndClear(static_cast<CB1*>(this));
	}
};

inline Future<Void> yieldedFuture(Future<Void> f) {
	if (f.isReady())
		return yield();
	else
		return Future<Void>(new YieldedFutureActor(std::move(f)));
}

// An AsyncMap that uses a yieldedFuture in its onChange method.
template <class K, class V>
class YieldedAsyncMap : public AsyncMap<K, V> {
public:
	Future<Void> onChange(K const& k) override { // throws broken_promise if this is destroyed
		auto& item = AsyncMap<K, V>::items[k];
		if (item.value == AsyncMap<K, V>::defaultValue)
			return destroyOnCancelYield(this, k, item.change.getFuture());
		return yieldedFuture(item.change.getFuture());
	}

																#line 22188 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
// This generated class is to be used only via destroyOnCancelYield()
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class DestroyOnCancelYieldActor>
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DestroyOnCancelYieldActorState {
															#line 22194 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DestroyOnCancelYieldActorState(YieldedAsyncMap* const& self,K const& key,Future<Void> const& change) 
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : self(self),
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   key(key),
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   change(change)
															#line 22205 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("destroyOnCancelYield", reinterpret_cast<unsigned long>(this));

	}
	~DestroyOnCancelYieldActorState() 
	{
		fdb_probe_actor_destroy("destroyOnCancelYield", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 1972 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<Void> __when_expr_0 = yieldedFuture(change);
															#line 1972 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<DestroyOnCancelYieldActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 22223 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<DestroyOnCancelYieldActor*>(this)->actor_wait_state = 1;
															#line 1972 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< DestroyOnCancelYieldActor, 0, Void >*>(static_cast<DestroyOnCancelYieldActor*>(this)));
															#line 22228 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~DestroyOnCancelYieldActorState();
		static_cast<DestroyOnCancelYieldActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1975 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == error_code_actor_cancelled && !self->destructing && change.getFutureReferenceCount() == 1 && change.getPromiseReferenceCount() == 1)
															#line 22258 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 1977 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (EXPENSIVE_VALIDATION)
															#line 22262 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				{
															#line 1978 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
					auto& p = self->items[key];
															#line 1979 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
					ASSERT(p.change.getFuture() == change);
															#line 22268 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				}
															#line 1981 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				self->items.erase(key);
															#line 22272 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 1983 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(e, loopDepth);
															#line 22276 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 1973 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<DestroyOnCancelYieldActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~DestroyOnCancelYieldActorState(); static_cast<DestroyOnCancelYieldActor*>(this)->destroy(); return 0; }
															#line 22290 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<DestroyOnCancelYieldActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~DestroyOnCancelYieldActorState();
		static_cast<DestroyOnCancelYieldActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 1973 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<DestroyOnCancelYieldActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~DestroyOnCancelYieldActorState(); static_cast<DestroyOnCancelYieldActor*>(this)->destroy(); return 0; }
															#line 22302 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<DestroyOnCancelYieldActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~DestroyOnCancelYieldActorState();
		static_cast<DestroyOnCancelYieldActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<DestroyOnCancelYieldActor*>(this)->actor_wait_state > 0) static_cast<DestroyOnCancelYieldActor*>(this)->actor_wait_state = 0;
		static_cast<DestroyOnCancelYieldActor*>(this)->ActorCallback< DestroyOnCancelYieldActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DestroyOnCancelYieldActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("destroyOnCancelYield", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DestroyOnCancelYieldActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("destroyOnCancelYield", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< DestroyOnCancelYieldActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("destroyOnCancelYield", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DestroyOnCancelYieldActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("destroyOnCancelYield", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< DestroyOnCancelYieldActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("destroyOnCancelYield", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<DestroyOnCancelYieldActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("destroyOnCancelYield", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	YieldedAsyncMap* self;
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	K key;
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<Void> change;
															#line 22391 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via destroyOnCancelYield()
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DestroyOnCancelYieldActor final : public Actor<Void>, public ActorCallback< DestroyOnCancelYieldActor, 0, Void >, public FastAllocated<DestroyOnCancelYieldActor>, public DestroyOnCancelYieldActorState<DestroyOnCancelYieldActor> {
															#line 22396 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<DestroyOnCancelYieldActor>::operator new;
	using FastAllocated<DestroyOnCancelYieldActor>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(16326412965096594176UL, 6731575155563120896UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< DestroyOnCancelYieldActor, 0, Void >;
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DestroyOnCancelYieldActor(YieldedAsyncMap* const& self,K const& key,Future<Void> const& change) 
															#line 22413 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   DestroyOnCancelYieldActorState<DestroyOnCancelYieldActor>(self, key, change),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("destroyOnCancelYield", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(7713615447991428096UL, 8541803921432000512UL);
		ActorExecutionContextHelper __helper(static_cast<DestroyOnCancelYieldActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("destroyOnCancelYield");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("destroyOnCancelYield", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< DestroyOnCancelYieldActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] static Future<Void> destroyOnCancelYield( YieldedAsyncMap* const& self, K const& key, Future<Void> const& change ) {
															#line 1970 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new DestroyOnCancelYieldActor(self, key, change));
															#line 22445 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1986 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
};

															#line 22451 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via delayActionJittered()
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class DelayActionJitteredActor>
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DelayActionJitteredActorState {
															#line 22458 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DelayActionJitteredActorState(Future<T> const& what,double const& time) 
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : what(what),
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   time(time)
															#line 22467 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("delayActionJittered", reinterpret_cast<unsigned long>(this));

	}
	~DelayActionJitteredActorState() 
	{
		fdb_probe_actor_destroy("delayActionJittered", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1990 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_0 = delayJittered(time);
															#line 1990 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<DelayActionJitteredActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 22484 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<DelayActionJitteredActor*>(this)->actor_wait_state = 1;
															#line 1990 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< DelayActionJitteredActor, 0, Void >*>(static_cast<DelayActionJitteredActor*>(this)));
															#line 22489 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~DelayActionJitteredActorState();
		static_cast<DelayActionJitteredActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1991 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<T> __when_expr_1 = what;
															#line 1991 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<DelayActionJitteredActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 22514 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<DelayActionJitteredActor*>(this)->actor_wait_state = 2;
															#line 1991 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< DelayActionJitteredActor, 1, T >*>(static_cast<DelayActionJitteredActor*>(this)));
															#line 22519 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1991 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<T> __when_expr_1 = what;
															#line 1991 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<DelayActionJitteredActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 22530 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<DelayActionJitteredActor*>(this)->actor_wait_state = 2;
															#line 1991 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< DelayActionJitteredActor, 1, T >*>(static_cast<DelayActionJitteredActor*>(this)));
															#line 22535 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<DelayActionJitteredActor*>(this)->actor_wait_state > 0) static_cast<DelayActionJitteredActor*>(this)->actor_wait_state = 0;
		static_cast<DelayActionJitteredActor*>(this)->ActorCallback< DelayActionJitteredActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DelayActionJitteredActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("delayActionJittered", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayActionJitteredActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayActionJittered", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< DelayActionJitteredActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("delayActionJittered", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayActionJitteredActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayActionJittered", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< DelayActionJitteredActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("delayActionJittered", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<DelayActionJitteredActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayActionJittered", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(T const& t,int loopDepth) 
	{
															#line 1992 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<DelayActionJitteredActor*>(this)->SAV<T>::futures) { (void)(t); this->~DelayActionJitteredActorState(); static_cast<DelayActionJitteredActor*>(this)->destroy(); return 0; }
															#line 22619 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<DelayActionJitteredActor*>(this)->SAV< T >::value()) T(t);
		this->~DelayActionJitteredActorState();
		static_cast<DelayActionJitteredActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(T && t,int loopDepth) 
	{
															#line 1992 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<DelayActionJitteredActor*>(this)->SAV<T>::futures) { (void)(t); this->~DelayActionJitteredActorState(); static_cast<DelayActionJitteredActor*>(this)->destroy(); return 0; }
															#line 22631 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<DelayActionJitteredActor*>(this)->SAV< T >::value()) T(t);
		this->~DelayActionJitteredActorState();
		static_cast<DelayActionJitteredActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(T const& t,int loopDepth) 
	{
		loopDepth = a_body1cont2(t, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(T && t,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(t), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<DelayActionJitteredActor*>(this)->actor_wait_state > 0) static_cast<DelayActionJitteredActor*>(this)->actor_wait_state = 0;
		static_cast<DelayActionJitteredActor*>(this)->ActorCallback< DelayActionJitteredActor, 1, T >::remove();

	}
	void a_callback_fire(ActorCallback< DelayActionJitteredActor, 1, T >*,T const& value) 
	{
		fdb_probe_actor_enter("delayActionJittered", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayActionJitteredActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayActionJittered", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< DelayActionJitteredActor, 1, T >*,T && value) 
	{
		fdb_probe_actor_enter("delayActionJittered", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<DelayActionJitteredActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayActionJittered", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< DelayActionJitteredActor, 1, T >*,Error err) 
	{
		fdb_probe_actor_enter("delayActionJittered", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<DelayActionJitteredActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delayActionJittered", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> what;
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double time;
															#line 22718 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via delayActionJittered()
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class DelayActionJitteredActor final : public Actor<T>, public ActorCallback< DelayActionJitteredActor<T>, 0, Void >, public ActorCallback< DelayActionJitteredActor<T>, 1, T >, public FastAllocated<DelayActionJitteredActor<T>>, public DelayActionJitteredActorState<T, DelayActionJitteredActor<T>> {
															#line 22725 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<DelayActionJitteredActor<T>>::operator new;
	using FastAllocated<DelayActionJitteredActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(10073282254776689408UL, 17818122731167738368UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< DelayActionJitteredActor<T>, 0, Void >;
friend struct ActorCallback< DelayActionJitteredActor<T>, 1, T >;
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	DelayActionJitteredActor(Future<T> const& what,double const& time) 
															#line 22743 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   DelayActionJitteredActorState<T, DelayActionJitteredActor<T>>(what, time),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("delayActionJittered", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5626974929922853888UL, 17655757398320213760UL);
		ActorExecutionContextHelper __helper(static_cast<DelayActionJitteredActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("delayActionJittered");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("delayActionJittered", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< DelayActionJitteredActor<T>, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< DelayActionJitteredActor<T>, 1, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> delayActionJittered( Future<T> const& what, double const& time ) {
															#line 1988 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new DelayActionJitteredActor<T>(what, time));
															#line 22779 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 1994 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

class AndFuture {
public:
	AndFuture() = default;
	AndFuture(AndFuture const& f) = default;
	AndFuture(AndFuture&& f) noexcept = default;
	AndFuture& operator=(AndFuture const& f) = default;
	AndFuture& operator=(AndFuture&& f) noexcept = default;

	AndFuture(Future<Void> const& f) : futureCount(1), futures{ f } {}

	AndFuture(Error const& e) : futureCount(1), futures{ Future<Void>(e) } {}

	operator Future<Void>() { return getFuture(); }

	Future<Void> getFuture() {
		if (futures.empty())
			return Void();

		if (futures.size() == 1)
			return futures[0];

		Future<Void> f = waitForAll(futures);
		futures = std::vector<Future<Void>>{ f };
		return f;
	}

	bool isReady() {
		for (int i = futures.size() - 1; i >= 0; --i) {
			if (!futures[i].isReady()) {
				return false;
			} else if (!futures[i].isError()) {
				swapAndPop(&futures, i);
			}
		}
		return true;
	}

	bool isError() const {
		for (int i = 0; i < futures.size(); i++)
			if (futures[i].isError())
				return true;
		return false;
	}

	void cleanup() {
		for (int i = 0; i < futures.size(); i++) {
			if (futures[i].isReady() && !futures[i].isError()) {
				swapAndPop(&futures, i--);
			}
		}
	}

	void add(Future<Void> const& f) {
		++futureCount;
		if (!f.isReady() || f.isError())
			futures.push_back(f);
	}

	void add(AndFuture f) { add(f.getFuture()); }

	// The total number of futures which have ever been added to this AndFuture
	int64_t getFutureCount() const { return futureCount; }

private:
	int64_t futureCount = 0;
	std::vector<Future<Void>> futures;
};

// Performs an unordered merge of a and b.
															#line 22853 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via unorderedMergeStreams()
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class UnorderedMergeStreamsActor>
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class UnorderedMergeStreamsActorState {
															#line 22860 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	UnorderedMergeStreamsActorState(FutureStream<T> const& a,FutureStream<T> const& b,PromiseStream<T> const& output) 
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : a(a),
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   b(b),
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   output(output),
															#line 2066 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   aFuture(waitAndForward(a)),
															#line 2067 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   bFuture(waitAndForward(b)),
															#line 2068 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   aOpen(true),
															#line 2069 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   bOpen(true)
															#line 22879 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("unorderedMergeStreams", reinterpret_cast<unsigned long>(this));

	}
	~UnorderedMergeStreamsActorState() 
	{
		fdb_probe_actor_destroy("unorderedMergeStreams", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2071 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 22894 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~UnorderedMergeStreamsActorState();
		static_cast<UnorderedMergeStreamsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 2107 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<UnorderedMergeStreamsActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~UnorderedMergeStreamsActorState(); static_cast<UnorderedMergeStreamsActor*>(this)->destroy(); return 0; }
															#line 22917 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<UnorderedMergeStreamsActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~UnorderedMergeStreamsActorState();
		static_cast<UnorderedMergeStreamsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 2074 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = aFuture;
															#line 2073 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<UnorderedMergeStreamsActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 22939 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
															#line 2078 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_1 = bFuture;
															#line 22943 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
			static_cast<UnorderedMergeStreamsActor*>(this)->actor_wait_state = 1;
															#line 2074 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< UnorderedMergeStreamsActor, 0, T >*>(static_cast<UnorderedMergeStreamsActor*>(this)));
															#line 2078 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< UnorderedMergeStreamsActor, 1, T >*>(static_cast<UnorderedMergeStreamsActor*>(this)));
															#line 22950 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2084 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() != error_code_end_of_stream)
															#line 22985 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 2085 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				output.sendError(e);
															#line 22989 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				return a_body1break1(loopDepth==0?0:loopDepth-1); // break
			}
															#line 2089 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			ASSERT(!aFuture.isError() || !bFuture.isError() || aFuture.getError().code() == bFuture.getError().code());
															#line 2091 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (aFuture.isError())
															#line 22996 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 2092 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				aFuture = Never();
															#line 2093 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				aOpen = false;
															#line 23002 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 2095 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (bFuture.isError())
															#line 23006 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 2096 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				bFuture = Never();
															#line 2097 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				bOpen = false;
															#line 23012 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 2100 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (!aOpen && !bOpen)
															#line 23016 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 2101 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				output.sendError(e);
															#line 23020 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				return a_body1break1(loopDepth==0?0:loopDepth-1); // break
			}
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T const& val,int loopDepth) 
	{
															#line 2075 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(val);
															#line 2076 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		aFuture = waitAndForward(a);
															#line 23045 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T && val,int loopDepth) 
	{
															#line 2075 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(val);
															#line 2076 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		aFuture = waitAndForward(a);
															#line 23056 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(T const& val,int loopDepth) 
	{
															#line 2079 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(val);
															#line 2080 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		bFuture = waitAndForward(b);
															#line 23067 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(T && val,int loopDepth) 
	{
															#line 2079 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output.send(val);
															#line 2080 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		bFuture = waitAndForward(b);
															#line 23078 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<UnorderedMergeStreamsActor*>(this)->actor_wait_state > 0) static_cast<UnorderedMergeStreamsActor*>(this)->actor_wait_state = 0;
		static_cast<UnorderedMergeStreamsActor*>(this)->ActorCallback< UnorderedMergeStreamsActor, 0, T >::remove();
		static_cast<UnorderedMergeStreamsActor*>(this)->ActorCallback< UnorderedMergeStreamsActor, 1, T >::remove();

	}
	void a_callback_fire(ActorCallback< UnorderedMergeStreamsActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<UnorderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< UnorderedMergeStreamsActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<UnorderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< UnorderedMergeStreamsActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<UnorderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< UnorderedMergeStreamsActor, 1, T >*,T const& value) 
	{
		fdb_probe_actor_enter("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<UnorderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< UnorderedMergeStreamsActor, 1, T >*,T && value) 
	{
		fdb_probe_actor_enter("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<UnorderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< UnorderedMergeStreamsActor, 1, T >*,Error err) 
	{
		fdb_probe_actor_enter("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<UnorderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FutureStream<T> a;
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FutureStream<T> b;
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<T> output;
															#line 2066 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> aFuture;
															#line 2067 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> bFuture;
															#line 2068 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	bool aOpen;
															#line 2069 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	bool bOpen;
															#line 23231 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via unorderedMergeStreams()
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class UnorderedMergeStreamsActor final : public Actor<Void>, public ActorCallback< UnorderedMergeStreamsActor<T>, 0, T >, public ActorCallback< UnorderedMergeStreamsActor<T>, 1, T >, public FastAllocated<UnorderedMergeStreamsActor<T>>, public UnorderedMergeStreamsActorState<T, UnorderedMergeStreamsActor<T>> {
															#line 23238 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<UnorderedMergeStreamsActor<T>>::operator new;
	using FastAllocated<UnorderedMergeStreamsActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(16696440389551968000UL, 6087465437579829248UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< UnorderedMergeStreamsActor<T>, 0, T >;
friend struct ActorCallback< UnorderedMergeStreamsActor<T>, 1, T >;
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	UnorderedMergeStreamsActor(FutureStream<T> const& a,FutureStream<T> const& b,PromiseStream<T> const& output) 
															#line 23256 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   UnorderedMergeStreamsActorState<T, UnorderedMergeStreamsActor<T>>(a, b, output),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(6433910378776870144UL, 438119925606429440UL);
		ActorExecutionContextHelper __helper(static_cast<UnorderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("unorderedMergeStreams");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("unorderedMergeStreams", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< UnorderedMergeStreamsActor<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> unorderedMergeStreams( FutureStream<T> const& a, FutureStream<T> const& b, PromiseStream<T> const& output ) {
															#line 2064 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new UnorderedMergeStreamsActor<T>(a, b, output));
															#line 23291 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 2109 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// Returns the ordered merge of a and b, assuming that a and b are both already ordered (prefer a over b if keys are
// equal). T must be a class that implements compare()
															#line 23298 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via orderedMergeStreams()
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class OrderedMergeStreamsActor>
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class OrderedMergeStreamsActorState {
															#line 23305 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	OrderedMergeStreamsActorState(FutureStream<T> const& a,FutureStream<T> const& b,PromiseStream<T> const& output) 
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : a(a),
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   b(b),
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   output(output),
															#line 2114 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   savedKVa(),
															#line 2115 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   aOpen(),
															#line 2116 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   savedKVb(),
															#line 2117 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   bOpen()
															#line 23324 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("orderedMergeStreams", reinterpret_cast<unsigned long>(this));

	}
	~OrderedMergeStreamsActorState() 
	{
		fdb_probe_actor_destroy("orderedMergeStreams", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2119 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			aOpen = bOpen = true;
															#line 2121 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 23341 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~OrderedMergeStreamsActorState();
		static_cast<OrderedMergeStreamsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 2179 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<OrderedMergeStreamsActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~OrderedMergeStreamsActorState(); static_cast<OrderedMergeStreamsActor*>(this)->destroy(); return 0; }
															#line 23364 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<OrderedMergeStreamsActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~OrderedMergeStreamsActorState();
		static_cast<OrderedMergeStreamsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 2122 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (aOpen && !savedKVa.present())
															#line 23383 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
			try {
															#line 2124 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				FutureStream<T> __when_expr_0 = a;
															#line 2124 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<OrderedMergeStreamsActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 23390 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.pop(), loopDepth); };
				static_cast<OrderedMergeStreamsActor*>(this)->actor_wait_state = 1;
															#line 2124 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< OrderedMergeStreamsActor, 0, T >*>(static_cast<OrderedMergeStreamsActor*>(this)));
															#line 23395 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1loopBody1Catch1(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
			}
		}
		else
		{
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
															#line 2138 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (bOpen && !savedKVb.present())
															#line 23428 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
			try {
															#line 2140 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				FutureStream<T> __when_expr_1 = b;
															#line 2140 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<OrderedMergeStreamsActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 23435 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont1when1(__when_expr_1.pop(), loopDepth); };
				static_cast<OrderedMergeStreamsActor*>(this)->actor_wait_state = 2;
															#line 2140 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_1.addCallbackAndClear(static_cast<ActorSingleCallback< OrderedMergeStreamsActor, 1, T >*>(static_cast<OrderedMergeStreamsActor*>(this)));
															#line 23440 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
			}
		}
		else
		{
			loopDepth = a_body1loopBody1cont6(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2127 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == error_code_end_of_stream)
															#line 23467 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 2128 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				aOpen = false;
															#line 2129 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (!bOpen)
															#line 23473 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				{
															#line 2130 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
					output.sendError(e);
															#line 23477 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				}
			}
			else
			{
															#line 2133 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				output.sendError(e);
															#line 23484 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				return a_body1break1(loopDepth==0?0:loopDepth-1); // break
			}
			loopDepth = a_body1loopBody1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3(T const& KVa,int loopDepth) 
	{
															#line 2125 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		savedKVa = Optional<T>(KVa);
															#line 23501 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3(T && KVa,int loopDepth) 
	{
															#line 2125 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		savedKVa = Optional<T>(KVa);
															#line 23510 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T const& KVa,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(KVa, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(T && KVa,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(std::move(KVa), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<OrderedMergeStreamsActor*>(this)->actor_wait_state > 0) static_cast<OrderedMergeStreamsActor*>(this)->actor_wait_state = 0;
		static_cast<OrderedMergeStreamsActor*>(this)->ActorSingleCallback< OrderedMergeStreamsActor, 0, T >::remove();

	}
	void a_callback_fire(ActorSingleCallback< OrderedMergeStreamsActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("orderedMergeStreams", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<OrderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("orderedMergeStreams", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< OrderedMergeStreamsActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("orderedMergeStreams", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<OrderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("orderedMergeStreams", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< OrderedMergeStreamsActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("orderedMergeStreams", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<OrderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("orderedMergeStreams", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont5(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont6(int loopDepth) 
	{
															#line 2155 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!aOpen)
															#line 23607 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 2156 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			output.send(savedKVb.get());
															#line 2157 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			savedKVb = Optional<T>();
															#line 23613 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		else
		{
															#line 2158 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (!bOpen)
															#line 23619 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 2159 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				output.send(savedKVa.get());
															#line 2160 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				savedKVa = Optional<T>();
															#line 23625 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
			else
			{
															#line 2162 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				int cmp = savedKVa.get().compare(savedKVb.get());
															#line 2164 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (cmp == 0)
															#line 23633 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				{
															#line 2166 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
					output.send(savedKVa.get());
															#line 2167 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
					savedKVa = Optional<T>();
															#line 2168 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
					savedKVb = Optional<T>();
															#line 23641 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				}
				else
				{
															#line 2169 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
					if (cmp < 0)
															#line 23647 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
					{
															#line 2170 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
						output.send(savedKVa.get());
															#line 2171 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
						savedKVa = Optional<T>();
															#line 23653 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
					}
					else
					{
															#line 2173 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
						output.send(savedKVb.get());
															#line 2174 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
						savedKVb = Optional<T>();
															#line 23661 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
					}
				}
			}
		}
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont7(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2143 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() == error_code_end_of_stream)
															#line 23681 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 2144 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				bOpen = false;
															#line 2145 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (!aOpen)
															#line 23687 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				{
															#line 2146 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
					output.sendError(e);
															#line 23691 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				}
			}
			else
			{
															#line 2149 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				output.sendError(e);
															#line 23698 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				return a_body1break1(loopDepth==0?0:loopDepth-1); // break
			}
			loopDepth = a_body1loopBody1cont7(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont8(T const& KVb,int loopDepth) 
	{
															#line 2141 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		savedKVb = Optional<T>(KVb);
															#line 23715 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont10(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont8(T && KVb,int loopDepth) 
	{
															#line 2141 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		savedKVb = Optional<T>(KVb);
															#line 23724 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1loopBody1cont10(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(T const& KVb,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont8(KVb, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(T && KVb,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont8(std::move(KVb), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<OrderedMergeStreamsActor*>(this)->actor_wait_state > 0) static_cast<OrderedMergeStreamsActor*>(this)->actor_wait_state = 0;
		static_cast<OrderedMergeStreamsActor*>(this)->ActorSingleCallback< OrderedMergeStreamsActor, 1, T >::remove();

	}
	void a_callback_fire(ActorSingleCallback< OrderedMergeStreamsActor, 1, T >*,T const& value) 
	{
		fdb_probe_actor_enter("orderedMergeStreams", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<OrderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("orderedMergeStreams", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorSingleCallback< OrderedMergeStreamsActor, 1, T >*,T && value) 
	{
		fdb_probe_actor_enter("orderedMergeStreams", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<OrderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("orderedMergeStreams", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorSingleCallback< OrderedMergeStreamsActor, 1, T >*,Error err) 
	{
		fdb_probe_actor_enter("orderedMergeStreams", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<OrderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("orderedMergeStreams", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont10(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont7(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FutureStream<T> a;
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FutureStream<T> b;
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<T> output;
															#line 2114 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Optional<T> savedKVa;
															#line 2115 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	bool aOpen;
															#line 2116 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Optional<T> savedKVb;
															#line 2117 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	bool bOpen;
															#line 23831 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via orderedMergeStreams()
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class OrderedMergeStreamsActor final : public Actor<Void>, public ActorSingleCallback< OrderedMergeStreamsActor<T>, 0, T >, public ActorSingleCallback< OrderedMergeStreamsActor<T>, 1, T >, public FastAllocated<OrderedMergeStreamsActor<T>>, public OrderedMergeStreamsActorState<T, OrderedMergeStreamsActor<T>> {
															#line 23838 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<OrderedMergeStreamsActor<T>>::operator new;
	using FastAllocated<OrderedMergeStreamsActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(7204603766638628352UL, 17183891108420704768UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< OrderedMergeStreamsActor<T>, 0, T >;
friend struct ActorSingleCallback< OrderedMergeStreamsActor<T>, 1, T >;
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	OrderedMergeStreamsActor(FutureStream<T> const& a,FutureStream<T> const& b,PromiseStream<T> const& output) 
															#line 23856 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   OrderedMergeStreamsActorState<T, OrderedMergeStreamsActor<T>>(a, b, output),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("orderedMergeStreams", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(4614755500775404288UL, 9396632073556844800UL);
		ActorExecutionContextHelper __helper(static_cast<OrderedMergeStreamsActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("orderedMergeStreams");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("orderedMergeStreams", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< OrderedMergeStreamsActor<T>, 0, T >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorSingleCallback< OrderedMergeStreamsActor<T>, 1, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> orderedMergeStreams( FutureStream<T> const& a, FutureStream<T> const& b, PromiseStream<T> const& output ) {
															#line 2112 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new OrderedMergeStreamsActor<T>(a, b, output));
															#line 23892 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 2181 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 23897 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via timeReply()
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class TimeReplyActor>
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TimeReplyActorState {
															#line 23904 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TimeReplyActorState(Future<T> const& replyToTime,PromiseStream<double> const& timeOutput) 
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : replyToTime(replyToTime),
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   timeOutput(timeOutput),
															#line 2184 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   startTime(now())
															#line 23915 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("timeReply", reinterpret_cast<unsigned long>(this));

	}
	~TimeReplyActorState() 
	{
		fdb_probe_actor_destroy("timeReply", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 2186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = replyToTime;
															#line 2186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<TimeReplyActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 23933 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<TimeReplyActor*>(this)->actor_wait_state = 1;
															#line 2186 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TimeReplyActor, 0, T >*>(static_cast<TimeReplyActor*>(this)));
															#line 23938 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TimeReplyActorState();
		static_cast<TimeReplyActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 2196 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<TimeReplyActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TimeReplyActorState(); static_cast<TimeReplyActor*>(this)->destroy(); return 0; }
															#line 23967 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<TimeReplyActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~TimeReplyActorState();
		static_cast<TimeReplyActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2193 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() != error_code_broken_promise)
															#line 23980 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 2194 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				return a_body1Catch1(e, loopDepth);
															#line 23984 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& _,int loopDepth) 
	{
															#line 2187 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_1 = delay(0);
															#line 2187 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<TimeReplyActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 24002 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), loopDepth); else return a_body1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<TimeReplyActor*>(this)->actor_wait_state = 2;
															#line 2187 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< TimeReplyActor, 1, Void >*>(static_cast<TimeReplyActor*>(this)));
															#line 24007 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2(T && _,int loopDepth) 
	{
															#line 2187 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_1 = delay(0);
															#line 2187 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<TimeReplyActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 24018 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), loopDepth); else return a_body1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<TimeReplyActor*>(this)->actor_wait_state = 2;
															#line 2187 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< TimeReplyActor, 1, Void >*>(static_cast<TimeReplyActor*>(this)));
															#line 24023 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(T const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TimeReplyActor*>(this)->actor_wait_state > 0) static_cast<TimeReplyActor*>(this)->actor_wait_state = 0;
		static_cast<TimeReplyActor*>(this)->ActorCallback< TimeReplyActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< TimeReplyActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("timeReply", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeReplyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeReply", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TimeReplyActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("timeReply", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeReplyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeReply", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TimeReplyActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("timeReply", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TimeReplyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeReply", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(Void const& _,int loopDepth) 
	{
															#line 2188 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		timeOutput.send(now() - startTime);
															#line 24107 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont3(Void && _,int loopDepth) 
	{
															#line 2188 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		timeOutput.send(now() - startTime);
															#line 24116 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<TimeReplyActor*>(this)->actor_wait_state > 0) static_cast<TimeReplyActor*>(this)->actor_wait_state = 0;
		static_cast<TimeReplyActor*>(this)->ActorCallback< TimeReplyActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TimeReplyActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("timeReply", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeReplyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeReply", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< TimeReplyActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("timeReply", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<TimeReplyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeReply", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< TimeReplyActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("timeReply", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<TimeReplyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("timeReply", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont5(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> replyToTime;
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	PromiseStream<double> timeOutput;
															#line 2184 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	double startTime;
															#line 24215 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via timeReply()
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class TimeReplyActor final : public Actor<Void>, public ActorCallback< TimeReplyActor<T>, 0, T >, public ActorCallback< TimeReplyActor<T>, 1, Void >, public FastAllocated<TimeReplyActor<T>>, public TimeReplyActorState<T, TimeReplyActor<T>> {
															#line 24222 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<TimeReplyActor<T>>::operator new;
	using FastAllocated<TimeReplyActor<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(12931903639603328512UL, 16762101926700732160UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< TimeReplyActor<T>, 0, T >;
friend struct ActorCallback< TimeReplyActor<T>, 1, Void >;
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	TimeReplyActor(Future<T> const& replyToTime,PromiseStream<double> const& timeOutput) 
															#line 24240 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   TimeReplyActorState<T, TimeReplyActor<T>>(replyToTime, timeOutput),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("timeReply", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9815766858051106304UL, 2244999537167756800UL);
		ActorExecutionContextHelper __helper(static_cast<TimeReplyActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("timeReply");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("timeReply", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TimeReplyActor<T>, 0, T >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< TimeReplyActor<T>, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> timeReply( Future<T> const& replyToTime, PromiseStream<double> const& timeOutput ) {
															#line 2182 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new TimeReplyActor<T>(replyToTime, timeOutput));
															#line 24276 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 2198 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 24281 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via forward()
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class ForwardActor1>
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ForwardActor1State {
															#line 24288 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ForwardActor1State(Future<T> const& from,Promise<T> const& to) 
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : from(from),
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   to(to)
															#line 24297 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("forward", reinterpret_cast<unsigned long>(this));

	}
	~ForwardActor1State() 
	{
		fdb_probe_actor_destroy("forward", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 2202 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<T> __when_expr_0 = from;
															#line 2202 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<ForwardActor1*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 24315 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<ForwardActor1*>(this)->actor_wait_state = 1;
															#line 2202 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ForwardActor1, 0, T >*>(static_cast<ForwardActor1*>(this)));
															#line 24320 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ForwardActor1State();
		static_cast<ForwardActor1*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2206 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (e.code() != error_code_actor_cancelled)
															#line 24350 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 2207 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				to.sendError(e);
															#line 24354 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 2209 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(e, loopDepth);
															#line 24358 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(T const& res,int loopDepth) 
	{
															#line 2203 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		to.send(res);
															#line 2204 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ForwardActor1*>(this)->SAV<T>::futures) { (void)(res); this->~ForwardActor1State(); static_cast<ForwardActor1*>(this)->destroy(); return 0; }
															#line 24374 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ForwardActor1*>(this)->SAV< T >::value()) T(res);
		this->~ForwardActor1State();
		static_cast<ForwardActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(T && res,int loopDepth) 
	{
															#line 2203 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		to.send(res);
															#line 2204 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<ForwardActor1*>(this)->SAV<T>::futures) { (void)(res); this->~ForwardActor1State(); static_cast<ForwardActor1*>(this)->destroy(); return 0; }
															#line 24388 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<ForwardActor1*>(this)->SAV< T >::value()) T(res);
		this->~ForwardActor1State();
		static_cast<ForwardActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& res,int loopDepth) 
	{
		loopDepth = a_body1cont2(res, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && res,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(res), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ForwardActor1*>(this)->actor_wait_state > 0) static_cast<ForwardActor1*>(this)->actor_wait_state = 0;
		static_cast<ForwardActor1*>(this)->ActorCallback< ForwardActor1, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< ForwardActor1, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("forward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forward", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ForwardActor1, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("forward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forward", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ForwardActor1, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("forward", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("forward", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> from;
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Promise<T> to;
															#line 24475 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via forward()
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class ForwardActor1 final : public Actor<T>, public ActorCallback< ForwardActor1<T>, 0, T >, public FastAllocated<ForwardActor1<T>>, public ForwardActor1State<T, ForwardActor1<T>> {
															#line 24482 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<ForwardActor1<T>>::operator new;
	using FastAllocated<ForwardActor1<T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(5886494081918704896UL, 3316517890409155328UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<T>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< ForwardActor1<T>, 0, T >;
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	ForwardActor1(Future<T> const& from,Promise<T> const& to) 
															#line 24499 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<T>(),
		   ForwardActor1State<T, ForwardActor1<T>>(from, to),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("forward", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(7317429319873398016UL, 13500045107497038848UL);
		ActorExecutionContextHelper __helper(static_cast<ForwardActor1*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("forward");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("forward", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ForwardActor1<T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T>
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<T> forward( Future<T> const& from, Promise<T> const& to ) {
															#line 2199 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<T>(new ForwardActor1<T>(from, to));
															#line 24534 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 2212 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 24539 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via buggifiedCommit()
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Transaction, class BuggifiedCommitActor>
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class BuggifiedCommitActorState {
															#line 24546 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	BuggifiedCommitActorState(Transaction const& tr,bool const& buggify,int const& maxDelayDuration = 60.0) 
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : tr(tr),
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   buggify(buggify),
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   maxDelayDuration(maxDelayDuration),
															#line 2215 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   buggifyUnknownResultPoint(0),
															#line 2216 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   buggifyDelayPoint(0)
															#line 24561 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("buggifiedCommit", reinterpret_cast<unsigned long>(this));

	}
	~BuggifiedCommitActorState() 
	{
		fdb_probe_actor_destroy("buggifiedCommit", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2218 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (buggify)
															#line 24576 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 2219 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				int choice = deterministicRandom()->randomInt(1, 9);
															#line 2220 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				buggifyUnknownResultPoint = choice / 3;
															#line 2221 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				buggifyDelayPoint = choice % 3;
															#line 24584 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			}
															#line 2225 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (buggifyDelayPoint == 1)
															#line 24588 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 2226 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<Void> __when_expr_0 = delay(deterministicRandom()->random01() * maxDelayDuration);
															#line 2226 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<BuggifiedCommitActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24594 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<BuggifiedCommitActor*>(this)->actor_wait_state = 1;
															#line 2226 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< BuggifiedCommitActor, 0, Void >*>(static_cast<BuggifiedCommitActor*>(this)));
															#line 24599 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			else
			{
				loopDepth = a_body1cont1(loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~BuggifiedCommitActorState();
		static_cast<BuggifiedCommitActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 2230 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (buggifyUnknownResultPoint == 1)
															#line 24627 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 2232 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (!BUGGIFY)
															#line 24631 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			{
															#line 2233 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				StrictFuture<Void> __when_expr_1 = delay(0);
															#line 2233 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				if (static_cast<BuggifiedCommitActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24637 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
				static_cast<BuggifiedCommitActor*>(this)->actor_wait_state = 2;
															#line 2233 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< BuggifiedCommitActor, 1, Void >*>(static_cast<BuggifiedCommitActor*>(this)));
															#line 24642 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
				loopDepth = 0;
			}
			else
			{
				loopDepth = a_body1cont5(loopDepth);
			}
		}
		else
		{
			loopDepth = a_body1cont4(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<BuggifiedCommitActor*>(this)->actor_wait_state > 0) static_cast<BuggifiedCommitActor*>(this)->actor_wait_state = 0;
		static_cast<BuggifiedCommitActor*>(this)->ActorCallback< BuggifiedCommitActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< BuggifiedCommitActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("buggifiedCommit", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BuggifiedCommitActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("buggifiedCommit", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< BuggifiedCommitActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("buggifiedCommit", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BuggifiedCommitActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("buggifiedCommit", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< BuggifiedCommitActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("buggifiedCommit", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<BuggifiedCommitActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("buggifiedCommit", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont4(int loopDepth) 
	{
															#line 2239 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_2 = safeThreadFutureToFuture(tr->commit());
															#line 2239 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<BuggifiedCommitActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24750 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont4when1(__when_expr_2.get(), loopDepth); };
		static_cast<BuggifiedCommitActor*>(this)->actor_wait_state = 3;
															#line 2239 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< BuggifiedCommitActor, 2, Void >*>(static_cast<BuggifiedCommitActor*>(this)));
															#line 24755 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont5(int loopDepth) 
	{
															#line 2236 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		return a_body1Catch1(commit_unknown_result(), loopDepth);
															#line 24764 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"

		return loopDepth;
	}
	int a_body1cont6(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont6(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont6(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont6(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<BuggifiedCommitActor*>(this)->actor_wait_state > 0) static_cast<BuggifiedCommitActor*>(this)->actor_wait_state = 0;
		static_cast<BuggifiedCommitActor*>(this)->ActorCallback< BuggifiedCommitActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< BuggifiedCommitActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("buggifiedCommit", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BuggifiedCommitActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("buggifiedCommit", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< BuggifiedCommitActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("buggifiedCommit", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BuggifiedCommitActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("buggifiedCommit", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< BuggifiedCommitActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("buggifiedCommit", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<BuggifiedCommitActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("buggifiedCommit", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont8(Void const& _,int loopDepth) 
	{
															#line 2242 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (buggifyDelayPoint == 2)
															#line 24859 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 2243 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_3 = delay(deterministicRandom()->random01() * maxDelayDuration);
															#line 2243 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<BuggifiedCommitActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24865 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont8when1(__when_expr_3.get(), loopDepth); };
			static_cast<BuggifiedCommitActor*>(this)->actor_wait_state = 4;
															#line 2243 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< BuggifiedCommitActor, 3, Void >*>(static_cast<BuggifiedCommitActor*>(this)));
															#line 24870 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont9(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont8(Void && _,int loopDepth) 
	{
															#line 2242 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (buggifyDelayPoint == 2)
															#line 24884 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 2243 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Void> __when_expr_3 = delay(deterministicRandom()->random01() * maxDelayDuration);
															#line 2243 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<BuggifiedCommitActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24890 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont8when1(__when_expr_3.get(), loopDepth); };
			static_cast<BuggifiedCommitActor*>(this)->actor_wait_state = 4;
															#line 2243 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< BuggifiedCommitActor, 3, Void >*>(static_cast<BuggifiedCommitActor*>(this)));
															#line 24895 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont9(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont4when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont8(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont4when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont8(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<BuggifiedCommitActor*>(this)->actor_wait_state > 0) static_cast<BuggifiedCommitActor*>(this)->actor_wait_state = 0;
		static_cast<BuggifiedCommitActor*>(this)->ActorCallback< BuggifiedCommitActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< BuggifiedCommitActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("buggifiedCommit", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BuggifiedCommitActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose3();
		try {
			a_body1cont4when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("buggifiedCommit", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< BuggifiedCommitActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("buggifiedCommit", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BuggifiedCommitActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose3();
		try {
			a_body1cont4when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("buggifiedCommit", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< BuggifiedCommitActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("buggifiedCommit", reinterpret_cast<unsigned long>(this), 2);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<BuggifiedCommitActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("buggifiedCommit", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont9(int loopDepth) 
	{
															#line 2247 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (buggifyUnknownResultPoint == 2)
															#line 24984 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		{
															#line 2248 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			return a_body1Catch1(commit_unknown_result(), loopDepth);
															#line 24988 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		}
															#line 2251 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<BuggifiedCommitActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~BuggifiedCommitActorState(); static_cast<BuggifiedCommitActor*>(this)->destroy(); return 0; }
															#line 24992 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<BuggifiedCommitActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~BuggifiedCommitActorState();
		static_cast<BuggifiedCommitActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont10(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1cont10(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1cont8when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont10(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont8when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont10(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<BuggifiedCommitActor*>(this)->actor_wait_state > 0) static_cast<BuggifiedCommitActor*>(this)->actor_wait_state = 0;
		static_cast<BuggifiedCommitActor*>(this)->ActorCallback< BuggifiedCommitActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< BuggifiedCommitActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("buggifiedCommit", reinterpret_cast<unsigned long>(this), 3);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BuggifiedCommitActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose4();
		try {
			a_body1cont8when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("buggifiedCommit", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< BuggifiedCommitActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("buggifiedCommit", reinterpret_cast<unsigned long>(this), 3);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<BuggifiedCommitActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose4();
		try {
			a_body1cont8when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("buggifiedCommit", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< BuggifiedCommitActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("buggifiedCommit", reinterpret_cast<unsigned long>(this), 3);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<BuggifiedCommitActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("buggifiedCommit", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Transaction tr;
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	bool buggify;
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	int maxDelayDuration;
															#line 2215 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	int buggifyUnknownResultPoint;
															#line 2216 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	int buggifyDelayPoint;
															#line 25097 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via buggifiedCommit()
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Transaction>
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class BuggifiedCommitActor final : public Actor<Void>, public ActorCallback< BuggifiedCommitActor<Transaction>, 0, Void >, public ActorCallback< BuggifiedCommitActor<Transaction>, 1, Void >, public ActorCallback< BuggifiedCommitActor<Transaction>, 2, Void >, public ActorCallback< BuggifiedCommitActor<Transaction>, 3, Void >, public FastAllocated<BuggifiedCommitActor<Transaction>>, public BuggifiedCommitActorState<Transaction, BuggifiedCommitActor<Transaction>> {
															#line 25104 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<BuggifiedCommitActor<Transaction>>::operator new;
	using FastAllocated<BuggifiedCommitActor<Transaction>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(14951127163182691328UL, 5305296160964786944UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< BuggifiedCommitActor<Transaction>, 0, Void >;
friend struct ActorCallback< BuggifiedCommitActor<Transaction>, 1, Void >;
friend struct ActorCallback< BuggifiedCommitActor<Transaction>, 2, Void >;
friend struct ActorCallback< BuggifiedCommitActor<Transaction>, 3, Void >;
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	BuggifiedCommitActor(Transaction const& tr,bool const& buggify,int const& maxDelayDuration = 60.0) 
															#line 25124 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   BuggifiedCommitActorState<Transaction, BuggifiedCommitActor<Transaction>>(tr, buggify, maxDelayDuration),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("buggifiedCommit", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(18426668805626877184UL, 1284464981043312384UL);
		ActorExecutionContextHelper __helper(static_cast<BuggifiedCommitActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("buggifiedCommit");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("buggifiedCommit", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< BuggifiedCommitActor<Transaction>, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< BuggifiedCommitActor<Transaction>, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< BuggifiedCommitActor<Transaction>, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< BuggifiedCommitActor<Transaction>, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Transaction>
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> buggifiedCommit( Transaction const& tr, bool const& buggify, int const& maxDelayDuration = 60.0 ) {
															#line 2213 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new BuggifiedCommitActor<Transaction>(tr, buggify, maxDelayDuration));
															#line 25162 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 2253 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

// Monad

															#line 25169 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via fmap()
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Fun, class T, class FmapActor>
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class FmapActorState {
															#line 25176 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FmapActorState(Fun const& fun,Future<T> const& f) 
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : fun(fun),
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   f(f)
															#line 25185 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("fmap", reinterpret_cast<unsigned long>(this));

	}
	~FmapActorState() 
	{
		fdb_probe_actor_destroy("fmap", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2258 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = f;
															#line 2258 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<FmapActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25202 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<FmapActor*>(this)->actor_wait_state = 1;
															#line 2258 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< FmapActor, 0, T >*>(static_cast<FmapActor*>(this)));
															#line 25207 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~FmapActorState();
		static_cast<FmapActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T const& val,int loopDepth) 
	{
															#line 2259 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<FmapActor*>(this)->SAV<decltype(std::declval<Fun>()(std::declval<T>()))>::futures) { (void)(fun(val)); this->~FmapActorState(); static_cast<FmapActor*>(this)->destroy(); return 0; }
															#line 25230 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<FmapActor*>(this)->SAV< decltype(std::declval<Fun>()(std::declval<T>())) >::value()) decltype(std::declval<Fun>()(std::declval<T>()))(fun(val));
		this->~FmapActorState();
		static_cast<FmapActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(T && val,int loopDepth) 
	{
															#line 2259 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<FmapActor*>(this)->SAV<decltype(std::declval<Fun>()(std::declval<T>()))>::futures) { (void)(fun(val)); this->~FmapActorState(); static_cast<FmapActor*>(this)->destroy(); return 0; }
															#line 25242 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<FmapActor*>(this)->SAV< decltype(std::declval<Fun>()(std::declval<T>())) >::value()) decltype(std::declval<Fun>()(std::declval<T>()))(fun(val));
		this->~FmapActorState();
		static_cast<FmapActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(T const& val,int loopDepth) 
	{
		loopDepth = a_body1cont1(val, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && val,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(val), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<FmapActor*>(this)->actor_wait_state > 0) static_cast<FmapActor*>(this)->actor_wait_state = 0;
		static_cast<FmapActor*>(this)->ActorCallback< FmapActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< FmapActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("fmap", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<FmapActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("fmap", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< FmapActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("fmap", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<FmapActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("fmap", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< FmapActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("fmap", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<FmapActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("fmap", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Fun fun;
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> f;
															#line 25329 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via fmap()
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Fun, class T>
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class FmapActor final : public Actor<decltype(std::declval<Fun>()(std::declval<T>()))>, public ActorCallback< FmapActor<Fun, T>, 0, T >, public FastAllocated<FmapActor<Fun, T>>, public FmapActorState<Fun, T, FmapActor<Fun, T>> {
															#line 25336 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<FmapActor<Fun, T>>::operator new;
	using FastAllocated<FmapActor<Fun, T>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(16643463177153533952UL, 6514020622038617600UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<decltype(std::declval<Fun>()(std::declval<T>()))>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< FmapActor<Fun, T>, 0, T >;
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	FmapActor(Fun const& fun,Future<T> const& f) 
															#line 25353 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<decltype(std::declval<Fun>()(std::declval<T>()))>(),
		   FmapActorState<Fun, T, FmapActor<Fun, T>>(fun, f),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("fmap", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(4997567031253067520UL, 1001287968638380032UL);
		ActorExecutionContextHelper __helper(static_cast<FmapActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("fmap");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("fmap", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< FmapActor<Fun, T>, 0, T >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class Fun, class T>
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<decltype(std::declval<Fun>()(std::declval<T>()))> fmap( Fun const& fun, Future<T> const& f ) {
															#line 2256 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<decltype(std::declval<Fun>()(std::declval<T>()))>(new FmapActor<Fun, T>(fun, f));
															#line 25388 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 2261 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

															#line 25393 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
namespace {
// This generated class is to be used only via runAfter()
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class Fun, class RunAfterActor>
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class RunAfterActorState {
															#line 25400 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	RunAfterActorState(Future<T> const& lhs,Fun const& rhs) 
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : lhs(lhs),
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   rhs(rhs)
															#line 25409 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("runAfter", reinterpret_cast<unsigned long>(this));

	}
	~RunAfterActorState() 
	{
		fdb_probe_actor_destroy("runAfter", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2264 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<T> __when_expr_0 = lhs;
															#line 2264 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<RunAfterActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25426 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<RunAfterActor*>(this)->actor_wait_state = 1;
															#line 2264 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< RunAfterActor, 0, T >*>(static_cast<RunAfterActor*>(this)));
															#line 25431 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~RunAfterActorState();
		static_cast<RunAfterActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T const& val1,int loopDepth) 
	{
															#line 2265 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<decltype(std::declval<Fun>()(std::declval<T>()).getValue())> __when_expr_1 = rhs(val1);
															#line 2265 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<RunAfterActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25456 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<RunAfterActor*>(this)->actor_wait_state = 2;
															#line 2265 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< RunAfterActor, 1, decltype(std::declval<Fun>()(std::declval<T>()).getValue()) >*>(static_cast<RunAfterActor*>(this)));
															#line 25461 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(T && val1,int loopDepth) 
	{
															#line 2265 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<decltype(std::declval<Fun>()(std::declval<T>()).getValue())> __when_expr_1 = rhs(val1);
															#line 2265 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<RunAfterActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25472 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<RunAfterActor*>(this)->actor_wait_state = 2;
															#line 2265 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< RunAfterActor, 1, decltype(std::declval<Fun>()(std::declval<T>()).getValue()) >*>(static_cast<RunAfterActor*>(this)));
															#line 25477 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(T const& val1,int loopDepth) 
	{
		loopDepth = a_body1cont1(val1, loopDepth);

		return loopDepth;
	}
	int a_body1when1(T && val1,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(val1), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<RunAfterActor*>(this)->actor_wait_state > 0) static_cast<RunAfterActor*>(this)->actor_wait_state = 0;
		static_cast<RunAfterActor*>(this)->ActorCallback< RunAfterActor, 0, T >::remove();

	}
	void a_callback_fire(ActorCallback< RunAfterActor, 0, T >*,T const& value) 
	{
		fdb_probe_actor_enter("runAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RunAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("runAfter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< RunAfterActor, 0, T >*,T && value) 
	{
		fdb_probe_actor_enter("runAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RunAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("runAfter", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< RunAfterActor, 0, T >*,Error err) 
	{
		fdb_probe_actor_enter("runAfter", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<RunAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("runAfter", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(decltype(std::declval<Fun>()(std::declval<T>()).getValue()) const& res,int loopDepth) 
	{
															#line 2266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<RunAfterActor*>(this)->SAV<decltype(std::declval<Fun>()(std::declval<T>()).getValue())>::futures) { (void)(res); this->~RunAfterActorState(); static_cast<RunAfterActor*>(this)->destroy(); return 0; }
															#line 25561 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<RunAfterActor*>(this)->SAV< decltype(std::declval<Fun>()(std::declval<T>()).getValue()) >::value()) decltype(std::declval<Fun>()(std::declval<T>()).getValue())(res);
		this->~RunAfterActorState();
		static_cast<RunAfterActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(decltype(std::declval<Fun>()(std::declval<T>()).getValue()) && res,int loopDepth) 
	{
															#line 2266 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<RunAfterActor*>(this)->SAV<decltype(std::declval<Fun>()(std::declval<T>()).getValue())>::futures) { (void)(res); this->~RunAfterActorState(); static_cast<RunAfterActor*>(this)->destroy(); return 0; }
															#line 25573 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<RunAfterActor*>(this)->SAV< decltype(std::declval<Fun>()(std::declval<T>()).getValue()) >::value()) decltype(std::declval<Fun>()(std::declval<T>()).getValue())(res);
		this->~RunAfterActorState();
		static_cast<RunAfterActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(decltype(std::declval<Fun>()(std::declval<T>()).getValue()) const& res,int loopDepth) 
	{
		loopDepth = a_body1cont2(res, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(decltype(std::declval<Fun>()(std::declval<T>()).getValue()) && res,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(res), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<RunAfterActor*>(this)->actor_wait_state > 0) static_cast<RunAfterActor*>(this)->actor_wait_state = 0;
		static_cast<RunAfterActor*>(this)->ActorCallback< RunAfterActor, 1, decltype(std::declval<Fun>()(std::declval<T>()).getValue()) >::remove();

	}
	void a_callback_fire(ActorCallback< RunAfterActor, 1, decltype(std::declval<Fun>()(std::declval<T>()).getValue()) >*,decltype(std::declval<Fun>()(std::declval<T>()).getValue()) const& value) 
	{
		fdb_probe_actor_enter("runAfter", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RunAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("runAfter", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< RunAfterActor, 1, decltype(std::declval<Fun>()(std::declval<T>()).getValue()) >*,decltype(std::declval<Fun>()(std::declval<T>()).getValue()) && value) 
	{
		fdb_probe_actor_enter("runAfter", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<RunAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("runAfter", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< RunAfterActor, 1, decltype(std::declval<Fun>()(std::declval<T>()).getValue()) >*,Error err) 
	{
		fdb_probe_actor_enter("runAfter", reinterpret_cast<unsigned long>(this), 1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<RunAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("runAfter", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Future<T> lhs;
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Fun rhs;
															#line 25660 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via runAfter()
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class Fun>
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class RunAfterActor final : public Actor<decltype(std::declval<Fun>()(std::declval<T>()).getValue())>, public ActorCallback< RunAfterActor<T, Fun>, 0, T >, public ActorCallback< RunAfterActor<T, Fun>, 1, decltype(std::declval<Fun>()(std::declval<T>()).getValue()) >, public FastAllocated<RunAfterActor<T, Fun>>, public RunAfterActorState<T, Fun, RunAfterActor<T, Fun>> {
															#line 25667 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<RunAfterActor<T, Fun>>::operator new;
	using FastAllocated<RunAfterActor<T, Fun>>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(232582858454315264UL, 8086277601117778688UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<decltype(std::declval<Fun>()(std::declval<T>()).getValue())>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< RunAfterActor<T, Fun>, 0, T >;
friend struct ActorCallback< RunAfterActor<T, Fun>, 1, decltype(std::declval<Fun>()(std::declval<T>()).getValue()) >;
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	RunAfterActor(Future<T> const& lhs,Fun const& rhs) 
															#line 25685 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<decltype(std::declval<Fun>()(std::declval<T>()).getValue())>(),
		   RunAfterActorState<T, Fun, RunAfterActor<T, Fun>>(lhs, rhs),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("runAfter", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(8336524017053668352UL, 10054685519443045632UL);
		ActorExecutionContextHelper __helper(static_cast<RunAfterActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("runAfter");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("runAfter", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< RunAfterActor<T, Fun>, 0, T >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< RunAfterActor<T, Fun>, 1, decltype(std::declval<Fun>()(std::declval<T>()).getValue()) >*)0, actor_cancelled()); break;
		}

	}
};
} // namespace
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class T, class Fun>
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<decltype(std::declval<Fun>()(std::declval<T>()).getValue())> runAfter( Future<T> const& lhs, Fun const& rhs ) {
															#line 2262 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<decltype(std::declval<Fun>()(std::declval<T>()).getValue())>(new RunAfterActor<T, Fun>(lhs, rhs));
															#line 25721 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 2268 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

template <class T, class Fun>
auto operator>>=(Future<T> lhs, Fun&& rhs) -> Future<decltype(rhs(std::declval<T>()))> {
	return runAfter(lhs, std::forward<Fun>(rhs));
}

/*
 * NOTE: This implementation can't guarantee the doesn't really enforce the ACTOR execution order. See issue #7708
ACTOR template <class T, class U>
Future<U> runAfter(Future<T> lhs, Future<U> rhs) {
    T val1 = wait(lhs);
    U res = wait(rhs);
    return res;
}

template <class T, class U>
Future<U> operator>>(Future<T> const& lhs, Future<U> const& rhs) {
    return runAfter(lhs, rhs);
}
 */

/*
 * IAsyncListener is similar to AsyncVar, but it decouples the input and output, so the translation unit
 * responsible for handling the output does not need to have knowledge of how the output is generated
 */

template <class Output>
class IAsyncListener : public ReferenceCounted<IAsyncListener<Output>> {
public:
	virtual ~IAsyncListener() = default;
	virtual Output const& get() const = 0;
	virtual Future<Void> onChange() const = 0;
	template <class Input, class F>
	static Reference<IAsyncListener> create(Reference<AsyncVar<Input> const> const& input, F const& f);
	template <class Input, class F>
	static Reference<IAsyncListener> create(Reference<AsyncVar<Input>> const& input, F const& f);
	static Reference<IAsyncListener> create(Reference<AsyncVar<Output>> const& output);
};

namespace IAsyncListenerImpl {

template <class Input, class Output, class F>
class AsyncListener final : public IAsyncListener<Output> {
	// Order matters here, output must outlive monitorActor
	AsyncVar<Output> output;
	Future<Void> monitorActor;
																#line 25771 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
// This generated class is to be used only via monitor()
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class MonitorActor>
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class MonitorActorState {
															#line 25777 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	MonitorActorState(Reference<AsyncVar<Input> const> const& input,AsyncVar<Output>* const& output,F const& f) 
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : input(input),
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   output(output),
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		   f(f)
															#line 25788 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("monitor", reinterpret_cast<unsigned long>(this));

	}
	~MonitorActorState() 
	{
		fdb_probe_actor_destroy("monitor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2315 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			;
															#line 25803 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~MonitorActorState();
		static_cast<MonitorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 2316 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		StrictFuture<Void> __when_expr_0 = input->onChange();
															#line 2316 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (static_cast<MonitorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 25835 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<MonitorActor*>(this)->actor_wait_state = 1;
															#line 2316 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< MonitorActor, 0, Void >*>(static_cast<MonitorActor*>(this)));
															#line 25840 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 2317 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output->set(f(input->get()));
															#line 25849 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 2317 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		output->set(f(input->get()));
															#line 25858 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<MonitorActor*>(this)->actor_wait_state > 0) static_cast<MonitorActor*>(this)->actor_wait_state = 0;
		static_cast<MonitorActor*>(this)->ActorCallback< MonitorActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< MonitorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("monitor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MonitorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< MonitorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("monitor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MonitorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< MonitorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("monitor", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<MonitorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitor", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	Reference<AsyncVar<Input> const> input;
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	AsyncVar<Output>* output;
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	F f;
															#line 25944 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via monitor()
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class MonitorActor final : public Actor<Void>, public ActorCallback< MonitorActor, 0, Void >, public FastAllocated<MonitorActor>, public MonitorActorState<MonitorActor> {
															#line 25949 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<MonitorActor>::operator new;
	using FastAllocated<MonitorActor>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(1323539257019114496UL, 6376186597074788864UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< MonitorActor, 0, Void >;
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	MonitorActor(Reference<AsyncVar<Input> const> const& input,AsyncVar<Output>* const& output,F const& f) 
															#line 25966 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   MonitorActorState<MonitorActor>(input, output, f),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("monitor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(10225923525820399360UL, 15284508221724187392UL);
		ActorExecutionContextHelper __helper(static_cast<MonitorActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("monitor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("monitor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< MonitorActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] static Future<Void> monitor( Reference<AsyncVar<Input> const> const& input, AsyncVar<Output>* const& output, F const& f ) {
															#line 2314 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new MonitorActor(input, output, f));
															#line 25998 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 2320 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"

public:
	AsyncListener(Reference<AsyncVar<Input> const> const& input, F const& f)
	  : output(f(input->get())), monitorActor(monitor(input, &output, f)) {}
	Output const& get() const override { return output.get(); }
	Future<Void> onChange() const override { return output.onChange(); }
};

} // namespace IAsyncListenerImpl

template <class Output>
template <class Input, class F>
Reference<IAsyncListener<Output>> IAsyncListener<Output>::create(Reference<AsyncVar<Input> const> const& input,
                                                                 F const& f) {
	return makeReference<IAsyncListenerImpl::AsyncListener<Input, Output, F>>(input, f);
}

template <class Output>
template <class Input, class F>
Reference<IAsyncListener<Output>> IAsyncListener<Output>::create(Reference<AsyncVar<Input>> const& input, F const& f) {
	return create(Reference<AsyncVar<Input> const>(input), f);
}

template <class Output>
Reference<IAsyncListener<Output>> IAsyncListener<Output>::create(Reference<AsyncVar<Output>> const& input) {
	auto identity = [](const auto& x) { return x; };
	return makeReference<IAsyncListenerImpl::AsyncListener<Output, Output, decltype(identity)>>(input, identity);
}

// A weak reference type to wrap a future Reference<T> object.
// Once the future is complete, this object holds a pointer to the referenced object but does
// not contribute to its reference count.
//
// WARNING: this class will not be aware when the underlying object is destroyed. It is up to the
// user to make sure that an UnsafeWeakFutureReference is discarded at the same time the object is.
template <class T>
class UnsafeWeakFutureReference {
public:
	UnsafeWeakFutureReference() {}
	UnsafeWeakFutureReference(Future<Reference<T>> future) : data(new UnsafeWeakFutureReferenceData(future)) {}

	// Returns a future to obtain a normal reference handle
	// If the future is ready, this creates a Reference<T> to wrap the object
	Future<Reference<T>> get() {
		if (!data) {
			return Reference<T>();
		} else if (data->ptr.present()) {
			return Reference<T>::addRef(data->ptr.get());
		} else {
			return data->future;
		}
	}

	// Returns the raw pointer, if the object is ready
	// Note: this should be used with care, as this pointer is not counted as a reference to the object and
	// it could be deleted if all normal references are destroyed.
	Optional<T*> getPtrIfReady() { return data->ptr; }

private:
	// A class to hold the state for an UnsafeWeakFutureReference
	struct UnsafeWeakFutureReferenceData : public ReferenceCounted<UnsafeWeakFutureReferenceData>, NonCopyable {
		Optional<T*> ptr;
		Future<Reference<T>> future;
		Future<Void> moveResultFuture;

		UnsafeWeakFutureReferenceData(Future<Reference<T>> future) : future(future) {
			moveResultFuture = moveResult(this);
		}

		// Waits for the future to complete and then stores the pointer in local storage
		// When this completes, we will no longer be counted toward the reference count of the object
																	#line 26073 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
// This generated class is to be used only via moveResult()
															#line 2391 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
template <class MoveResultActor>
															#line 2391 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class MoveResultActorState {
															#line 26079 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
															#line 2391 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	MoveResultActorState(UnsafeWeakFutureReferenceData* const& self) 
															#line 2391 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
															#line 2391 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		 : self(self)
															#line 26086 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
	{
		fdb_probe_actor_create("moveResult", reinterpret_cast<unsigned long>(this));

	}
	~MoveResultActorState() 
	{
		fdb_probe_actor_destroy("moveResult", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2392 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			StrictFuture<Reference<T>> __when_expr_0 = self->future;
															#line 2392 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			if (static_cast<MoveResultActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 26103 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<MoveResultActor*>(this)->actor_wait_state = 1;
															#line 2392 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< MoveResultActor, 0, Reference<T> >*>(static_cast<MoveResultActor*>(this)));
															#line 26108 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~MoveResultActorState();
		static_cast<MoveResultActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Reference<T> const& result,int loopDepth) 
	{
															#line 2393 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		self->ptr = result.getPtr();
															#line 2394 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		self->future = Future<Reference<T>>();
															#line 2395 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<MoveResultActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~MoveResultActorState(); static_cast<MoveResultActor*>(this)->destroy(); return 0; }
															#line 26135 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<MoveResultActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~MoveResultActorState();
		static_cast<MoveResultActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Reference<T> && result,int loopDepth) 
	{
															#line 2393 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		self->ptr = result.getPtr();
															#line 2394 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		self->future = Future<Reference<T>>();
															#line 2395 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
		if (!static_cast<MoveResultActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~MoveResultActorState(); static_cast<MoveResultActor*>(this)->destroy(); return 0; }
															#line 26151 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		new (&static_cast<MoveResultActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~MoveResultActorState();
		static_cast<MoveResultActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Reference<T> const& result,int loopDepth) 
	{
		loopDepth = a_body1cont1(result, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Reference<T> && result,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(result), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<MoveResultActor*>(this)->actor_wait_state > 0) static_cast<MoveResultActor*>(this)->actor_wait_state = 0;
		static_cast<MoveResultActor*>(this)->ActorCallback< MoveResultActor, 0, Reference<T> >::remove();

	}
	void a_callback_fire(ActorCallback< MoveResultActor, 0, Reference<T> >*,Reference<T> const& value) 
	{
		fdb_probe_actor_enter("moveResult", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MoveResultActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("moveResult", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< MoveResultActor, 0, Reference<T> >*,Reference<T> && value) 
	{
		fdb_probe_actor_enter("moveResult", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(9578512156108914944UL, 107643746863906816UL);
		ActorExecutionContextHelper __helper(static_cast<MoveResultActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("moveResult", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< MoveResultActor, 0, Reference<T> >*,Error err) 
	{
		fdb_probe_actor_enter("moveResult", reinterpret_cast<unsigned long>(this), 0);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5187328219730237440UL, 3113259079076601088UL);
		ActorExecutionContextHelper __helper(static_cast<MoveResultActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("moveResult", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 2391 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	UnsafeWeakFutureReferenceData* self;
															#line 26236 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
};
// This generated class is to be used only via moveResult()
															#line 2391 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
class MoveResultActor final : public Actor<Void>, public ActorCallback< MoveResultActor, 0, Reference<T> >, public FastAllocated<MoveResultActor>, public MoveResultActorState<MoveResultActor> {
															#line 26241 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
public:
	using FastAllocated<MoveResultActor>::operator new;
	using FastAllocated<MoveResultActor>::operator delete;
	static constexpr ActorIdentifier __actorIdentifier = UID(5114606682383115008UL, 3024561239558729472UL);
	ActiveActorHelper activeActorHelper;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
    void destroy() override {
        activeActorHelper.~ActiveActorHelper();
        static_cast<Actor<Void>*>(this)->~Actor();
        operator delete(this);
    }
#pragma clang diagnostic pop
friend struct ActorCallback< MoveResultActor, 0, Reference<T> >;
															#line 2391 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	MoveResultActor(UnsafeWeakFutureReferenceData* const& self) 
															#line 26258 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
		 : Actor<Void>(),
		   MoveResultActorState<MoveResultActor>(self),
		   activeActorHelper(__actorIdentifier)
	{
		fdb_probe_actor_enter("moveResult", reinterpret_cast<unsigned long>(this), -1);
		#ifdef WITH_ACAC
		static constexpr ActorBlockIdentifier __identifier = UID(5839807800672587776UL, 8547874577817464320UL);
		ActorExecutionContextHelper __helper(static_cast<MoveResultActor*>(this)->activeActorHelper.actorID, __identifier);
		#endif // WITH_ACAC
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("moveResult");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("moveResult", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< MoveResultActor, 0, Reference<T> >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2391 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
[[nodiscard]] Future<Void> moveResult( UnsafeWeakFutureReferenceData* const& self ) {
															#line 2391 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	return Future<Void>(new MoveResultActor(self));
															#line 26290 "/Users/gyming/Documents/USC/CATPS/Task/build/flow/include/flow/genericactors.actor.g.h"
}

#line 2397 "/Users/gyming/Documents/USC/CATPS/Task/foundationdb/flow/include/flow/genericactors.actor.h"
	};

	Reference<UnsafeWeakFutureReferenceData> data;
};

// Utility class to provide FLOW compliant singleton pattern.
// In similuation, the approach allows per-virtual process singleton as desired compared to one singleton instance
// shared across all virtual processes if 'static singleton' pattern is implemented.
//
// API NOTE: Client are expected to pass functor allowing instantiation of the template class
template <class T>
class FlowSingleton {
public:
	static Reference<T> getInstance(std::function<Reference<T>()> func) {
		ASSERT(g_network->isSimulated());

		auto cItr = instanceMap.find(g_network->getLocalAddress());
		if (cItr == instanceMap.end()) {
			instanceMap.emplace(g_network->getLocalAddress(), func());
			return instanceMap[g_network->getLocalAddress()];
		} else {
			return cItr->second;
		}
	}

	static int getCount() { return instanceMap.size(); }
	static void resetInstances() { instanceMap.clear(); }

private:
	static std::unordered_map<NetworkAddress, Reference<T>> instanceMap;
};

template <class T>
std::unordered_map<NetworkAddress, Reference<T>> FlowSingleton<T>::instanceMap;

#include "flow/unactorcompiler.h"

#endif
